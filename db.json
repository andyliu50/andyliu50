{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/cactus/source/css/rtl.styl","path":"css/rtl.styl","modified":0,"renderable":1},{"_id":"themes/cactus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/favicon-192x192.png","path":"images/favicon-192x192.png","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/cactus/source/js/main.js.bak","path":"js/main.js.bak","modified":0,"renderable":1},{"_id":"themes/cactus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/cactus/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/clipboard/clipboard.min.js","path":"lib/clipboard/clipboard.min.js","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/jquery/jquery.min.js","path":"lib/jquery/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff2","path":"lib/vazir-font/Vazir-Black.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff","path":"lib/vazir-font/Vazir-Black.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.eot","path":"lib/vazir-font/Vazir-Black.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.ttf","path":"lib/vazir-font/Vazir-Black.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.eot","path":"lib/vazir-font/Vazir-Bold.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.ttf","path":"lib/vazir-font/Vazir-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff","path":"lib/vazir-font/Vazir-Bold.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff2","path":"lib/vazir-font/Vazir-Bold.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.eot","path":"lib/vazir-font/Vazir-Light.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.ttf","path":"lib/vazir-font/Vazir-Light.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff","path":"lib/vazir-font/Vazir-Light.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff2","path":"lib/vazir-font/Vazir-Light.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.eot","path":"lib/vazir-font/Vazir-Medium.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.ttf","path":"lib/vazir-font/Vazir-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff","path":"lib/vazir-font/Vazir-Medium.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff2","path":"lib/vazir-font/Vazir-Medium.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.eot","path":"lib/vazir-font/Vazir-Regular.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.ttf","path":"lib/vazir-font/Vazir-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.woff","path":"lib/vazir-font/Vazir-Regular.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.woff2","path":"lib/vazir-font/Vazir-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.eot","path":"lib/vazir-font/Vazir-Thin.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.ttf","path":"lib/vazir-font/Vazir-Thin.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff","path":"lib/vazir-font/Vazir-Thin.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff2","path":"lib/vazir-font/Vazir-Thin.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.eot","path":"lib/vazir-font/Vazir-Variable.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.woff","path":"lib/vazir-font/Vazir-Variable.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.ttf","path":"lib/vazir-font/Vazir-Variable.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.woff2","path":"lib/vazir-font/Vazir-Variable.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/font-face.css","path":"lib/vazir-font/font-face.css","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Bold.ttf","path":"lib/meslo-LG/MesloLGL-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Italic.ttf","path":"lib/meslo-LG/MesloLGL-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGL-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Regular.ttf","path":"lib/meslo-LG/MesloLGL-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Bold.ttf","path":"lib/meslo-LG/MesloLGM-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGM-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Italic.ttf","path":"lib/meslo-LG/MesloLGM-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Regular.ttf","path":"lib/meslo-LG/MesloLGM-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Bold.ttf","path":"lib/meslo-LG/MesloLGS-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGS-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Italic.ttf","path":"lib/meslo-LG/MesloLGS-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Regular.ttf","path":"lib/meslo-LG/MesloLGS-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.ttf","path":"lib/font-awesome/webfonts/fa-brands-400.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.ttf","path":"lib/font-awesome/webfonts/fa-regular-400.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.ttf","path":"lib/font-awesome/webfonts/fa-solid-900.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-v4compatibility.ttf","path":"lib/font-awesome/webfonts/fa-v4compatibility.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-v4compatibility.woff2","path":"lib/font-awesome/webfonts/fa-v4compatibility.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/justified-gallery/css/justifiedGallery.min.css","path":"lib/justified-gallery/css/justifiedGallery.min.css","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/justified-gallery/js/jquery.justifiedGallery.min.js","path":"lib/justified-gallery/js/jquery.justifiedGallery.min.js","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/IMG_6262_副本.png","path":"images/IMG_6262_副本.png","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/apple-touch-icon_bak.png","path":"images/apple-touch-icon_bak.png","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/favicon-192x192_bak.png","path":"images/favicon-192x192_bak.png","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/favicon_bak.ico","path":"images/favicon_bak.ico","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/logo_bak.png","path":"images/logo_bak.png","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/IMG_6262.JPG","path":"images/IMG_6262.JPG","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/apple-touch-icon_bak1.png","path":"images/apple-touch-icon_bak1.png","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"f30d4922ca0c81ce86228bd0f0bb397de41caf75","modified":1727600237785},{"_id":"source/search/index.md","hash":"4d914c75e00fb63fc892c0344697c7ef2e67d77c","modified":1706759003163},{"_id":"source/_posts/.DS_Store","hash":"e958574242a6a5390fa9bb7a57d4a6c044e10816","modified":1727600253472},{"_id":"source/categories/index.md","hash":"d00af02337375208f30a3e005b91f081644121f3","modified":1702364510394},{"_id":"source/tags/index.md","hash":"ac99ad1b12bf2090983807e8f12c225215504ad2","modified":1702364510395},{"_id":"source/_posts/Home_Assistant/安装Home_Assistant.md","hash":"6b7b02cd7baed1c56eafd021e9b1bbe2717b978b","modified":1725259584682},{"_id":"source/_posts/RaspberryPi/在树莓派上部署Hexo博客.md","hash":"ba06c64fa7532a812296d6cdee109e5628385a4b","modified":1703738533294},{"_id":"themes/cactus/.DS_Store","hash":"9f041014b47f994648e925425200b64446ac4df0","modified":1725857506089},{"_id":"themes/cactus/.jshintrc","hash":"2548bd6ce44422edc7e6f9f68061ab47f26c4f57","modified":1706681926671},{"_id":"themes/cactus/.stylintrc","hash":"eb5f48e83657928cb0cbee031373b2cd36ca0083","modified":1706681926671},{"_id":"themes/cactus/README.md","hash":"52fafba48b0c792478e134a659bc8f0f61b4557b","modified":1706681926672},{"_id":"themes/cactus/LICENSE","hash":"346ece39a983b0e7858c11f785cd846cef9eb875","modified":1706681926671},{"_id":"themes/cactus/_config.yml","hash":"e8695f457de9dcdc85e5cd5c3787eb42c648ce2f","modified":1706842377425},{"_id":"themes/cactus/gulpfile.js","hash":"70d419549ba72e0906fd2fc8103701142eb883a7","modified":1706681926672},{"_id":"themes/cactus/package.json","hash":"dbb0a486006e7d4ecdb4b005b6a9b264b5d542dc","modified":1706681926682},{"_id":"themes/cactus/languages/ar.yml","hash":"81a88b0593fc89de3118d686681b1f69883c847b","modified":1706681926672},{"_id":"themes/cactus/languages/ca.yml","hash":"b79dd2c21dc6697c635e92db1f661a4b8d5d2305","modified":1706681926673},{"_id":"themes/cactus/languages/de.yml","hash":"43b2f4e078b042aaae0377a4235216a51ed82e0d","modified":1706681926673},{"_id":"themes/cactus/languages/en.yml","hash":"6a84970bf69c3e9490e5382747ca2b4c4b4dccde","modified":1706681926673},{"_id":"themes/cactus/languages/default.yml","hash":"6a84970bf69c3e9490e5382747ca2b4c4b4dccde","modified":1706681926673},{"_id":"themes/cactus/languages/es.yml","hash":"2b1fc8b0d636123e9ee39017fa20053bd1913a5a","modified":1706681926674},{"_id":"themes/cactus/languages/fa.yml","hash":"63f32e50953af1c4bd0308a4fca5862b5287c2cb","modified":1706681926674},{"_id":"themes/cactus/languages/fr.yml","hash":"5c07406998f19d219a5a7b65c0d88b6b023f85b2","modified":1706681926674},{"_id":"themes/cactus/languages/it.yml","hash":"62800bcae1f2d2454f87f4bcf4d7593848424f61","modified":1706681926675},{"_id":"themes/cactus/languages/pl.yml","hash":"8a2d6dc874d86c38d42c2c861c39590647b5d536","modified":1706681926675},{"_id":"themes/cactus/languages/pt-br.yml","hash":"4859aba788a050c2d5d0b997693b0c8c24b349f7","modified":1706681926676},{"_id":"themes/cactus/languages/nl.yml","hash":"ac0573352ad2c737a7686bcca498b985e7bd6447","modified":1706681926675},{"_id":"themes/cactus/languages/kr.yml","hash":"651fb83991c91b13b53ed55740e5402cf0f1c5e8","modified":1706681926675},{"_id":"themes/cactus/languages/tr.yml","hash":"2702914007e6bade9d6861078c0e179ac05bf48c","modified":1706681926676},{"_id":"themes/cactus/languages/ru.yml","hash":"81b57fcd1977ef534f4bf303dbc1b4710cc7f057","modified":1706681926676},{"_id":"themes/cactus/languages/zh-TW.yml","hash":"2f4e050c9b35a67f4a7278cec3a949533c2ac16a","modified":1706681926677},{"_id":"themes/cactus/languages/zh-CN.yml","hash":"d016060817311addb4c528de440126b975038c31","modified":1706681926677},{"_id":"themes/cactus/languages/vi.yml","hash":"f84893c3ec3e45875c90069e14b17ed3016ed973","modified":1706681926676},{"_id":"themes/cactus/layout/404.ejs","hash":"b911da998c160cceb8cd7c4dae709a1374ed2491","modified":1706681926677},{"_id":"themes/cactus/layout/archive.ejs","hash":"8e9bb1199694b229d2a3de1c3a55188a28e6f5e7","modified":1706681926681},{"_id":"themes/cactus/layout/page.ejs","hash":"c5465d5315a7544aa466b01fd8cfb62917a8bb1d","modified":1706681926682},{"_id":"themes/cactus/layout/index.ejs","hash":"fb73e020655ec4696eb7f91a350bf3b9c0fa2755","modified":1706681926681},{"_id":"themes/cactus/layout/layout.ejs","hash":"03d503c37edbfddb982a5fce35febb81502ec295","modified":1706754999961},{"_id":"themes/cactus/layout/layout.ejs.bak","hash":"e03062a5a70d71dff9f09dd86769d1a13b33afd9","modified":1706695085535},{"_id":"themes/cactus/scripts/meta.js","hash":"654868666b6573b2cee7e750b47ad8a3c2ee13a0","modified":1706681926683},{"_id":"themes/cactus/layout/post.ejs","hash":"8b2a90b15608d71f5cb1b8cb4a65b25e088bd696","modified":1706703132910},{"_id":"themes/cactus/scripts/cdn.js","hash":"887edec364d51efa7c524446483188c6ad05adaf","modified":1706681926682},{"_id":"themes/cactus/scripts/error_404.js","hash":"f83b290e47cb78a2754152fccc34e571a72087bd","modified":1706681926682},{"_id":"themes/cactus/scripts/merge-configs.js","hash":"2048c3415d96b17b9d84aa44bc0c25f1210525f8","modified":1706681926682},{"_id":"themes/cactus/layout/post.ejs.bak","hash":"f8eac342118298447ef38c21f9560a359e488395","modified":1706693047603},{"_id":"themes/cactus/scripts/page_title.js","hash":"fa662dbdb82779af1b95e35ed7ccdf4866a53dee","modified":1706681926683},{"_id":"themes/cactus/scripts/thumbnail.js","hash":"df8829fd8c3119650037eba5ec11bdce06acff9d","modified":1706681926683},{"_id":"themes/cactus/layout/_partial/comments.ejs","hash":"4e75035a427fd137ae7f12940209e8e97845df3b","modified":1706681926677},{"_id":"themes/cactus/layout/_partial/footer.ejs","hash":"12fd63b51472c9c5b8b7d167eb1a96bf1d686c20","modified":1706681926678},{"_id":"themes/cactus/layout/_partial/header.ejs","hash":"21d60f0bb82367cc2bee0c7eb3c06c7f5ab56a6d","modified":1706681926678},{"_id":"themes/cactus/layout/_partial/google_analytics.ejs","hash":"64aeee0fdfc06207573ddbf8b91f6d3f007ccea9","modified":1706681926678},{"_id":"themes/cactus/layout/_partial/head.ejs","hash":"4709e17487315e8f0a5b38f0611f0244f16fdd87","modified":1706681926678},{"_id":"themes/cactus/layout/_partial/pagination.ejs","hash":"247bf8ec39965fe07b52f5a3d04e02e0aaf2da57","modified":1706681926678},{"_id":"themes/cactus/layout/_partial/umami_analytics.ejs","hash":"3e79be7343c4d0a5971d3aa659e3750672a91e72","modified":1706681926681},{"_id":"themes/cactus/layout/_partial/scripts.ejs","hash":"9bbc0cf2dd0d7cdaafe827c3945a9bea1503da83","modified":1706681926680},{"_id":"themes/cactus/layout/_partial/search.ejs","hash":"8b4bf9cf5db0ce762a31fc3baae0f2fc004bece4","modified":1706681926680},{"_id":"themes/cactus/layout/_partial/styles.ejs","hash":"c6bc7e8a422c5bb57f88fed1d1b0694d03e24e74","modified":1706681926681},{"_id":"themes/cactus/source/css/_extend.styl","hash":"3d03a18cbd5ff9cbe156d1de09fd7d4e18aed3ce","modified":1706698314563},{"_id":"themes/cactus/source/css/_extend.styl.bak","hash":"b6a4e5905a7515dda66919167531a5ab2b3d1fe2","modified":1706693948485},{"_id":"themes/cactus/source/css/_util.styl","hash":"2bfeb2e2605dd5235693b00c71a212646d2e0410","modified":1706681926700},{"_id":"themes/cactus/source/css/_mixins.styl","hash":"1a9e309523df9685e8d088dcff0a809c58e2c392","modified":1706681926697},{"_id":"themes/cactus/source/css/_fonts.styl","hash":"354809b5a64e8a47a66c66fd1a28ac597c1460a6","modified":1706681926684},{"_id":"themes/cactus/source/css/_variables.styl","hash":"2c0e7074d0a8a39e25ae93af18a2ee5f93c633cf","modified":1706688459342},{"_id":"themes/cactus/source/css/rtl.styl","hash":"ff8700e1626feeb53d905a2df2777bda7d1eca50","modified":1706681926700},{"_id":"themes/cactus/source/images/favicon.ico","hash":"d9b938e585a60ced3a5eaec44e136ebedd7b7afd","modified":1725621592061},{"_id":"themes/cactus/source/css/style.styl","hash":"4ee0091bfa3cf43fa528d54df378f3d977257342","modified":1706681926700},{"_id":"themes/cactus/source/images/favicon-192x192.png","hash":"4634f92fde7a1feeca8bae1a5c36f09f8b1919af","modified":1725621671853},{"_id":"themes/cactus/source/images/apple-touch-icon.png","hash":"585bc2f4664addf10d161d7af3346757c0b9c42f","modified":1725857793126},{"_id":"themes/cactus/source/js/main.js","hash":"50531951ae728ae01c6ce1bcc8c5872a9e5d69b4","modified":1706694842013},{"_id":"themes/cactus/layout/_partial/post/actions_mobile.ejs","hash":"5ee47fffaf428802cfe47dd2e6186c6bbff85067","modified":1706681926679},{"_id":"themes/cactus/source/js/search.js","hash":"914a2ce72fb325106c61600200be823b72bfb39f","modified":1706681926703},{"_id":"themes/cactus/source/js/main.js.bak","hash":"619ac6529d140711e3b14f739a192bb31c4824ff","modified":1706694784264},{"_id":"themes/cactus/layout/_partial/post/actions_desktop.ejs","hash":"54a590e39e2d6e9ee41b8a1423a7bc67ab03363d","modified":1706681926679},{"_id":"themes/cactus/layout/_partial/post/category.ejs","hash":"aeb99694d8492d4fcda320493b259fb68bf21830","modified":1706681926679},{"_id":"themes/cactus/layout/_partial/post/gallery.ejs","hash":"9aecd8908e8a684f33dc20c02497c0f1774137c7","modified":1706681926679},{"_id":"themes/cactus/layout/_partial/post/tag.ejs","hash":"80bd2afd49b296e6441ab977a0614add710c32a3","modified":1706681926680},{"_id":"themes/cactus/layout/_partial/post/date.ejs","hash":"23770328c7d900ecc7fd87930dc24b095eb272ac","modified":1706681926679},{"_id":"themes/cactus/layout/_partial/post/share.ejs","hash":"9a15a7c005cfe518fdc9ec61a5107c76012f49d0","modified":1706681926679},{"_id":"themes/cactus/layout/_partial/post/title.ejs","hash":"b2a00781d1301ff4d362b5d2a97480052ee4cae1","modified":1706681926680},{"_id":"themes/cactus/source/css/_colors/classic.styl","hash":"bc09f8777a6c99030da953dfdb84f793c5e4fd85","modified":1706681926683},{"_id":"themes/cactus/source/css/_colors/light.styl","hash":"d14ef1aa02d0895b6f9321ebfc23a1ec84b054b8","modified":1706681926683},{"_id":"themes/cactus/source/css/_colors/white.styl.bak","hash":"1d1cfcb2a095da2732a52ed92fa6f662780d383a","modified":1706691332283},{"_id":"themes/cactus/source/css/_colors/white.styl","hash":"49ade4956c516d803806a10a38bdd1fba555efe6","modified":1706704708481},{"_id":"themes/cactus/source/css/_colors/dark.styl","hash":"9aa43b1f23d5d268dfa36bd942d6ce97b7677c4d","modified":1706681926683},{"_id":"themes/cactus/source/css/_highlight/agate.styl","hash":"53027913ed8d4f75ac3e49e76aad824f0df62da3","modified":1706681926684},{"_id":"themes/cactus/source/css/_highlight/androidstudio.styl","hash":"2af0861725f97f0ee2ded67c3d2d4548c62b2d16","modified":1706681926684},{"_id":"themes/cactus/source/css/_highlight/arta.styl","hash":"b3e81e3e694ceb8deed178adb8b91013c5120e30","modified":1706681926685},{"_id":"themes/cactus/source/css/_highlight/ascetic.styl","hash":"32cff3bef6fac3760fe78f203096477052a90552","modified":1706681926685},{"_id":"themes/cactus/source/css/_highlight/arduino-light.styl","hash":"15e8572585cd708221c513dea4bdd89d8fe56c10","modified":1706681926685},{"_id":"themes/cactus/source/css/_highlight/atelier-cave-dark.styl","hash":"ce63dd8548688d88254405eedfa75b1d7c82449e","modified":1706681926685},{"_id":"themes/cactus/source/css/_highlight/atelier-cave-light.styl","hash":"a5be0744a7ecf4a08f600ade4cfd555afc67bc15","modified":1706681926685},{"_id":"themes/cactus/source/css/_highlight/atelier-estuary-dark.styl","hash":"0bb16a4eff93688f40787abc2f9e56e7d5cc93e7","modified":1706681926686},{"_id":"themes/cactus/source/css/_highlight/atelier-estuary-light.styl","hash":"344276ca9b27e51d4c907f76afe5d13cf8e60bdf","modified":1706681926686},{"_id":"themes/cactus/source/css/_highlight/atelier-dune-dark.styl","hash":"c196ff0ee064af0e507823694ae39020addfc280","modified":1706681926685},{"_id":"themes/cactus/source/css/_highlight/atelier-forest-dark.styl","hash":"effbc5d75fa87203c847039869c22031b40d5b7d","modified":1706681926686},{"_id":"themes/cactus/source/css/_highlight/atelier-dune-light.styl","hash":"931435fbc6f974e8ce9e32722680035d248a9dc1","modified":1706681926686},{"_id":"themes/cactus/source/css/_highlight/atelier-forest-light.styl","hash":"95228d9f2102fad425536aac44b80b2cba1f5950","modified":1706681926686},{"_id":"themes/cactus/source/css/_highlight/atelier-heath-dark.styl","hash":"9a2e9a1d0a01bbdf158560c3ed1c134e098b2c68","modified":1706681926686},{"_id":"themes/cactus/source/css/_highlight/atelier-heath-light.styl","hash":"8c8c2e445abef85273be966d59770e9ced6aac21","modified":1706681926686},{"_id":"themes/cactus/source/css/_highlight/atelier-lakeside-dark.styl","hash":"10ee3882fca7b97a37bd309d2d35fce9868647bb","modified":1706681926687},{"_id":"themes/cactus/source/css/_highlight/atelier-lakeside-light.styl","hash":"2c54cb9bdb259ae3b5b29f63ac2469ed34b08578","modified":1706681926687},{"_id":"themes/cactus/source/css/_highlight/atelier-plateau-dark.styl","hash":"84c80e6f67f62fce958d25817c277d2360272617","modified":1706681926687},{"_id":"themes/cactus/source/css/_highlight/atelier-plateau-light.styl","hash":"d1a05fdd1ededc9063d181ab25bad55a164aeb4a","modified":1706681926687},{"_id":"themes/cactus/source/css/_highlight/atelier-savanna-light.styl","hash":"f8244c93711c7cb59dd79d2df966806b30d171ea","modified":1706681926687},{"_id":"themes/cactus/source/css/_highlight/atelier-seaside-dark.styl","hash":"2edf385215bbe1985b1a10106525d362667d28c2","modified":1706681926687},{"_id":"themes/cactus/source/css/_highlight/atelier-savanna-dark.styl","hash":"e32c1c70def8060fce5e790979a126da650ac642","modified":1706681926687},{"_id":"themes/cactus/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"538a14321193cd8abf2ddc484306631e54149ffb","modified":1706681926688},{"_id":"themes/cactus/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"efa52713efc468abeeb2b9299704371583b857de","modified":1706681926688},{"_id":"themes/cactus/source/css/_highlight/atelier-seaside-light.styl","hash":"0597342da6e2d0c5bdcc7d42dabb07322b1a4177","modified":1706681926688},{"_id":"themes/cactus/source/css/_highlight/brown-paper.styl","hash":"c2326ba20a5020a66ca7895258d18833327d4334","modified":1706681926688},{"_id":"themes/cactus/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1706681926688},{"_id":"themes/cactus/source/css/_highlight/codepen-embed.styl","hash":"8b7b34484f76a6c2c3b1a9e49abb9b382f439ae8","modified":1706681926688},{"_id":"themes/cactus/source/css/_highlight/color-brewer.styl","hash":"2a439d6214430e2f45dd4939b4dfe1fe1a20aa0f","modified":1706681926689},{"_id":"themes/cactus/source/css/_highlight/dark.styl","hash":"f5e6e75958de59e87fc6be3a1668e870e20bc836","modified":1706681926689},{"_id":"themes/cactus/source/css/_highlight/darkula.styl","hash":"9717efa9194837ba3fb4d762997d33075dcf8bfa","modified":1706681926689},{"_id":"themes/cactus/source/css/_highlight/docco.styl","hash":"b1c176378bb275f2e8caa759f36294e42d614bf1","modified":1706681926689},{"_id":"themes/cactus/source/css/_highlight/github.styl","hash":"3336aeba324c6d34a6fd41fef9b47bc598f7064c","modified":1706681926690},{"_id":"themes/cactus/source/css/_highlight/github-gist.styl","hash":"48211a03d33e7f7ada0b261162bea06676155a71","modified":1706681926690},{"_id":"themes/cactus/source/css/_highlight/far.styl","hash":"aaac3028f5e33123cd123a583cddc9290c45ec8e","modified":1706681926689},{"_id":"themes/cactus/source/css/_highlight/foundation.styl","hash":"bf8ddc94b4ad995b8b8805b5a4cf95004553fdac","modified":1706681926690},{"_id":"themes/cactus/source/css/_highlight/googlecode.styl","hash":"bda816beee7b439814b514e6869dc678822be1bc","modified":1706681926690},{"_id":"themes/cactus/source/css/_highlight/grayscale.styl","hash":"bf37d8b8d1e602126c51526f0cc28807440228ed","modified":1706681926691},{"_id":"themes/cactus/source/css/_highlight/gruvbox-dark.styl","hash":"76b744c14fd5600bea64731c05df97c2df75523f","modified":1706681926691},{"_id":"themes/cactus/source/css/_highlight/highlightjs.styl","hash":"0e198b7a59191c7a39b641a4ddd22c948edb9358","modified":1706681926691},{"_id":"themes/cactus/source/css/_highlight/hopscotch.styl","hash":"1378a6bc67a32c0cbff72ab771268b53f9aa586d","modified":1706681926691},{"_id":"themes/cactus/source/css/_highlight/idea.styl","hash":"a02967cb51c16a34e0ee895d33ded2b823d35b21","modified":1706681926692},{"_id":"themes/cactus/source/css/_highlight/ir-black.styl","hash":"53e5d74326a4527b92272bbd6946d4fec92720e8","modified":1706681926692},{"_id":"themes/cactus/source/css/_highlight/kimbie.dark.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1706681926692},{"_id":"themes/cactus/source/css/_highlight/index.styl","hash":"002d5596f6379cc87dbd43d9145bc764aa666be1","modified":1706681926692},{"_id":"themes/cactus/source/css/_highlight/hybrid.styl","hash":"b8eb5c69d12f2ee5ebc50265ae271699d7f1a8d3","modified":1706681926692},{"_id":"themes/cactus/source/css/_highlight/kimbie.light.styl","hash":"61f8baed25be05288c8604d5070afbcd9f183f49","modified":1706681926692},{"_id":"themes/cactus/source/css/_highlight/magula.styl","hash":"16d323f989b1420a0f72ef989242ece9bf17a456","modified":1706681926693},{"_id":"themes/cactus/source/css/_highlight/kimbie.styl","hash":"51b889ca7c6fe178cfbbe28d875a6ea427184441","modified":1706681926692},{"_id":"themes/cactus/source/css/_highlight/mono-blue.styl","hash":"4c89a6ae29de67c0700585af82a60607e85df928","modified":1706681926693},{"_id":"themes/cactus/source/css/_highlight/monokai-sublime.styl","hash":"c385b11345894be7e6ce3c5f08663e199933b8e4","modified":1706681926693},{"_id":"themes/cactus/source/css/_highlight/obsidian.styl","hash":"199e28326be8590883f0813ebbd54fcfaa4750fd","modified":1706681926694},{"_id":"themes/cactus/source/css/_highlight/paraiso-dark.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1706681926694},{"_id":"themes/cactus/source/css/_highlight/paraiso-light.styl","hash":"d224d1df0eb3395d9eea1344cee945c228af2911","modified":1706681926694},{"_id":"themes/cactus/source/css/_highlight/monokai.styl","hash":"f87be027848ea6bee623a08ad1e17b2f5b7937ee","modified":1706681926693},{"_id":"themes/cactus/source/css/_highlight/paraiso.styl","hash":"75f181eece6b71d033ea0c8d6cf00ae7efb9e29b","modified":1706681926694},{"_id":"themes/cactus/source/css/_highlight/rainbow.styl","hash":"c0cf97aae3e10fdcd10414547a711c9effbc39b8","modified":1706681926695},{"_id":"themes/cactus/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1706681926694},{"_id":"themes/cactus/source/css/_highlight/railscasts.styl","hash":"b6674db9210e0c4444e4835fff2d1361f3ebd64c","modified":1706681926694},{"_id":"themes/cactus/source/css/_highlight/pojoaque.styl","hash":"4e7b6b046b8575ac749f6aec4e953a62ada27a36","modified":1706681926694},{"_id":"themes/cactus/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1706681926695},{"_id":"themes/cactus/source/css/_highlight/school-book.styl","hash":"d43560fe519a931ce6da7d57416d7aa148441b83","modified":1706681926695},{"_id":"themes/cactus/source/css/_highlight/solarized-light.styl","hash":"aa0dd3fd25c464183b59c5575c9bee8756b397f2","modified":1706681926696},{"_id":"themes/cactus/source/css/_highlight/solarized-dark.styl","hash":"90c9da5aa594383697e5b18892a7f95beb053f55","modified":1706681926695},{"_id":"themes/cactus/source/css/_highlight/sunburst.styl","hash":"af3eec0fd56151e55bbd49c31b151f36717611d8","modified":1706681926696},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night-blue.styl","hash":"f24c17d0ab815dcfaab3438cb9fe2ab4839f5e0d","modified":1706681926696},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night.styl","hash":"16ba09b2db501e4e3e2e7d62595d9bf935bf27c4","modified":1706681926697},{"_id":"themes/cactus/source/css/_highlight/tomorrow.styl","hash":"15779cf6846725c7c35fc56cac39047d7e0aec1c","modified":1706681926697},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night-bright.styl","hash":"7674fecb6d27350727dc0d2dc93bc018382ebbd0","modified":1706681926696},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night-eighties.styl","hash":"28d751075ebabf7d0327a36f725076fe82fdf626","modified":1706681926696},{"_id":"themes/cactus/source/css/_highlight/vs.styl","hash":"959a746f4b37aacb5d1d6ff1d57e0c045289d75d","modified":1706681926697},{"_id":"themes/cactus/source/css/_highlight/xcode.styl","hash":"5e8532ae8366dcf6a4ef5e4813dc3d42ab3d0a50","modified":1706681926697},{"_id":"themes/cactus/source/css/_highlight/zenburn.styl","hash":"68ff9332ccc03f9389b15b713415cde016f8088f","modified":1706681926697},{"_id":"themes/cactus/source/css/_partial/archive.styl","hash":"b4a741b426364fa7ec55212c4878e733ad67934e","modified":1706765010462},{"_id":"themes/cactus/source/css/_partial/article.styl.bak","hash":"258370d8ab98e63804ead9bc030f633ca97a1235","modified":1706694448015},{"_id":"themes/cactus/source/css/_partial/categories.styl","hash":"a43f00e61b3507f130b8a3f8108a4eeca147c2a0","modified":1706681926698},{"_id":"themes/cactus/source/css/_partial/comments.styl","hash":"1e90f1fb9d4c155df518cacb5a537e9de9c042c1","modified":1706681926698},{"_id":"themes/cactus/source/css/_partial/article.styl","hash":"05e4eaff25986a1a16e14d7d3cdc7a4da812b484","modified":1706698007036},{"_id":"themes/cactus/source/css/_partial/footer.styl","hash":"61c2c7c5f73a0022ec41830bea0812a97f522d7c","modified":1706681926698},{"_id":"themes/cactus/source/css/_partial/header.styl","hash":"bda03ce341a9faf63ac3e359f1dabe04e7fe0471","modified":1706698245000},{"_id":"themes/cactus/source/css/_partial/index.styl","hash":"50e607d95d7c6d3ba054932a05936e480dabb552","modified":1706765021200},{"_id":"themes/cactus/source/css/_partial/search.styl","hash":"159be002780c62a77f46947cf854a7342fba24f4","modified":1706681926699},{"_id":"themes/cactus/source/css/_partial/pagination.styl","hash":"950bf517bbe7adb9a9aa4eb5ddec74ffc7598787","modified":1706681926699},{"_id":"themes/cactus/source/css/_partial/header.styl.bak","hash":"8ce12f14382b6d471e3fe1266573b34fa84deaa0","modified":1706691479624},{"_id":"themes/cactus/source/css/_partial/tags.styl","hash":"d571d5c7c960300d29c5f0ec3fe1140322ecd6b3","modified":1706681926700},{"_id":"themes/cactus/source/css/_partial/tooltip.styl","hash":"2daff581ec3efaec840cbfdee512195919c32629","modified":1706681926700},{"_id":"themes/cactus/source/lib/clipboard/clipboard.min.js","hash":"9a7cb405f9beed005891587d41f76a0720893ffc","modified":1706681926703},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff2","hash":"7ea4fd7dd4cd4f480af78a0e2c5849eb921b1aeb","modified":1706681926740},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff","hash":"f6fda2de0348b3e3b7de73267f9f8e97a62f8353","modified":1706681926740},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff2","hash":"6e40d0c7669c1adbcbf034bdc459f7bed4d6676d","modified":1706681926743},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff","hash":"56e632c9196fac364c66f812a3b4635dd999ad1c","modified":1706681926743},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff","hash":"1c3dbf17411b1f6a6b22c2b76e9d8511586643d0","modified":1706681926745},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff2","hash":"50b654d916204c30987d1987abd890ef92085ae3","modified":1706681926746},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff2","hash":"14b3e257c51a6a11d23b2a078017ff340c9777e4","modified":1706681926749},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff","hash":"43a8aaa3fca8721dd32a5d20f7a98dfbc87c97fd","modified":1706681926748},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.woff","hash":"235889d59ddad2b1f3243ccaab7733bd713a2a21","modified":1706681926750},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.woff2","hash":"a9714ffb842afc74836e64de04b52d8c37c87c8a","modified":1706681926750},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff","hash":"c0e784de2eb5261cca244928f8a81fd893c3fe16","modified":1706681926752},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff2","hash":"9b03b1a9071709f5b7dbca13412ecef6cb7a2a67","modified":1706681926752},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.woff","hash":"2e8e6d38d361def5f48baac366f04e3db3ed4828","modified":1706681926754},{"_id":"themes/cactus/source/lib/vazir-font/font-face.css","hash":"ba0030e1cd28a8caa7a5bb74b98da7c7bb185c90","modified":1706681926754},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.woff2","hash":"e213bb26bc7f10e1df3fe2d03d3ecaecd6e6d371","modified":1706681926754},{"_id":"themes/cactus/source/css/_partial/post/actions_mobile.styl","hash":"0d2966c1d870392476864af8ee3ba312ba30cb82","modified":1706681926699},{"_id":"themes/cactus/source/css/_partial/post/actions_desktop.styl","hash":"c899306e44deddf0e4bf4aebfc16742d861169a1","modified":1706755435550},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-v4compatibility.ttf","hash":"a9d072aca9e0fadc2a7167671ce3d6b18d9cd2cc","modified":1706681926711},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"fb363d27cfdfe71a243fa2ac3dab2815232b9b7e","modified":1706681926708},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.ttf","hash":"67afa6237670ab99125056f2899129f22912dcf3","modified":1706681926707},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-v4compatibility.woff2","hash":"8f80d0bbe995f7fe92320fdaec10cd5ccd710a51","modified":1706681926711},{"_id":"themes/cactus/source/lib/justified-gallery/js/jquery.justifiedGallery.min.js","hash":"ad8f48b4022498078b089fcdd1e8b47faf496931","modified":1706681926712},{"_id":"themes/cactus/source/lib/justified-gallery/css/justifiedGallery.min.css","hash":"dd3052149d3054f35efb823c68dd78e78aad5875","modified":1706681926712},{"_id":"themes/cactus/source/lib/jquery/jquery.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1706681926712},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.eot","hash":"91152bd73e7ff8d943e3bde3ddb0fa0a018e1c21","modified":1706681926739},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.ttf","hash":"b65915e3fa57b5c19995d15dc2341d115c1971b9","modified":1706681926740},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.eot","hash":"5c1c680fade45393e4a5bb4548a092cd5ea6811e","modified":1706681926742},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.ttf","hash":"122bb778b17a152c426a825ee981610a4bd59bf3","modified":1706681926743},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.ttf","hash":"df82b80c4d3b11e70dcd269fc62ac97cbfa0414d","modified":1706681926745},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.eot","hash":"a059359e9bea17dc2ff2ede955a05bf0dc4d00d0","modified":1706681926744},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.eot","hash":"d9ec1f9f3fefd57e446cbe86dc297f1ff269b6de","modified":1706681926747},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.ttf","hash":"948a091f0fdb8c7ae17d5ef8e51bd8830d65dd9a","modified":1706681926748},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.ttf","hash":"643c28c8f8a2bce1a0d62525aa045cd9883773cd","modified":1706681926749},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.eot","hash":"521c01f0eb79a48025e972ecbe21b0d7fb15437b","modified":1706681926749},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.eot","hash":"a0ea0bdaef00b35544f9a21d25d35db9a79f7189","modified":1706681926751},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.ttf","hash":"6aacb0eecb03c660570b6e159ba5ca97ca7461cf","modified":1706681926751},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.eot","hash":"af46f7f4e10a1440a4c97b350622d279143e6798","modified":1706681926753},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.ttf","hash":"1e08b6373c2e086f24776df9b11e4be6bbcc8a4a","modified":1706681926754},{"_id":"themes/cactus/source/lib/font-awesome/css/all.min.css","hash":"8c06d82739d14b094ff6d9036021a252bd1d985d","modified":1706681926704},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"4350f9ba93384634faf35f41c503c99c767f1069","modified":1706681926706},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.ttf","hash":"f0982a77285d53653845b0a78170b4688db972f1","modified":1706681926706},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"6b99aa650bd12a36caa14e0127435d8f4cd3ba73","modified":1706681926710},{"_id":"themes/cactus/source/images/logo.png","hash":"8f9ecdb0b8a748e62f9d3fa33b7e67cfd2f900e5","modified":1725621503284},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.ttf","hash":"20bd663830188cbadd2264e1daf9497c3ffc3621","modified":1706681926710},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Italic.ttf","hash":"96c97a0a098ca40802f948ae56fa37aa6683d034","modified":1706681926722},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Italic.ttf","hash":"68700db02debd4b922304134da83b829cbfddfc9","modified":1706681926732},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Italic.ttf","hash":"7f7cdbdcc26279c04046632e22d872f111bc9399","modified":1706681926737},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Bold.ttf","hash":"bfa1ed9a263ed78462f06d322de13bd5bd0906b2","modified":1706681926716},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-BoldItalic.ttf","hash":"a9a431fc7a6c3a67c98021d4035c12a07a4f1070","modified":1706681926719},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Regular.ttf","hash":"2b912dd13f052f645ee19951604610bb350d50af","modified":1706681926725},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-BoldItalic.ttf","hash":"65ddb11e75ee93909e845ab912a36717c48f1c94","modified":1706681926729},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Bold.ttf","hash":"a8a8df3393bccc365335fc5eb0a62a6b7ccd32b9","modified":1706681926726},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-BoldItalic.ttf","hash":"d895a1bd25e36c58b7f463ebe14de09f186d5ab4","modified":1706681926736},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Bold.ttf","hash":"df202ce09cbdc70bc16b81983a13ef0f94e46f10","modified":1706681926735},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Regular.ttf","hash":"5e220152adefe905b2197f873d7cee99eca50e91","modified":1706681926734},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Regular.ttf","hash":"56fa0e33a390b704afc56af93a31576ccdbbdd9e","modified":1706681926738},{"_id":"public/search.xml","hash":"79d3f4e67ebc3db8fa50718004e2fa777894bd3d","modified":1727600262891},{"_id":"public/search/index.html","hash":"4d234de22be9b28b41d3f0057c5d03e63dca5e5a","modified":1727334891107},{"_id":"public/categories/index.html","hash":"a3a42f269e6521f6a87ea6b8853b965d571be796","modified":1727599846542},{"_id":"public/tags/index.html","hash":"53abf06ae80b57767e69f27d8ab1b6a03d87d698","modified":1727334891107},{"_id":"public/2023/12/28/raspberrypi/zai-shu-mei-pai-shang-bu-shu-hexo-bo-ke/index.html","hash":"a07d022a7fde0734c690e61de8d3f49c662fd435","modified":1727334891107},{"_id":"public/2021/10/17/home-assistant/an-zhuang-home-assistant/index.html","hash":"feffc99f09138e889b3b0e81e185c52244512e83","modified":1725260426950},{"_id":"public/archives/index.html","hash":"7b4b9d9f1e2e7321dd2772528dc6ebd2589bd11f","modified":1727599846542},{"_id":"public/archives/2021/index.html","hash":"cccfc3ab63c6d70629a5be2859ba596d5aa73e8a","modified":1727334891107},{"_id":"public/archives/2021/10/index.html","hash":"0fd5d1640b08e496793348715ec1a20ceea64532","modified":1727334891107},{"_id":"public/archives/2023/index.html","hash":"b6887740f05eb55882559a6aab861ab64dd3f715","modified":1727334891107},{"_id":"public/archives/2023/12/index.html","hash":"cf9d65f0ba60a654838fb0d334ca3fc481ae6da2","modified":1727334891107},{"_id":"public/categories/RaspberryPi/index.html","hash":"e2537dd18546f834291414d2f286f482cb09e95c","modified":1727334891107},{"_id":"public/categories/Home-Assistant/index.html","hash":"77ca79e5e2c529094a266d675c57ad93cad7d72b","modified":1727599846542},{"_id":"public/index.html","hash":"ab7758869413ba497c949199c9e541b074fb2eb0","modified":1727599846542},{"_id":"public/tags/raspberrypi/index.html","hash":"246e83dd402dd8d3d4a6f3c95ceb443c23a37ca8","modified":1727334891107},{"_id":"public/tags/hexo/index.html","hash":"a026b7f0780cbde3d26ffc861dcf67bf29b8fa36","modified":1727334891107},{"_id":"public/tags/home-assistant/index.html","hash":"fc4bd97c4696c217e68be3a6bda7124d3ad160dc","modified":1727599846542},{"_id":"public/404.html","hash":"66ba134ac7c91fe3129d30c5437a147c02ef1403","modified":1727334891107},{"_id":"public/images/favicon-192x192.png","hash":"4634f92fde7a1feeca8bae1a5c36f09f8b1919af","modified":1725621871854},{"_id":"public/images/favicon.ico","hash":"d9b938e585a60ced3a5eaec44e136ebedd7b7afd","modified":1725621871854},{"_id":"public/images/apple-touch-icon.png","hash":"585bc2f4664addf10d161d7af3346757c0b9c42f","modified":1725857855725},{"_id":"public/lib/vazir-font/Vazir-Black.woff2","hash":"7ea4fd7dd4cd4f480af78a0e2c5849eb921b1aeb","modified":1706765032184},{"_id":"public/js/main.js.bak","hash":"619ac6529d140711e3b14f739a192bb31c4824ff","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Black.woff","hash":"f6fda2de0348b3e3b7de73267f9f8e97a62f8353","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Bold.woff2","hash":"6e40d0c7669c1adbcbf034bdc459f7bed4d6676d","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Light.woff","hash":"1c3dbf17411b1f6a6b22c2b76e9d8511586643d0","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Bold.woff","hash":"56e632c9196fac364c66f812a3b4635dd999ad1c","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Medium.woff","hash":"43a8aaa3fca8721dd32a5d20f7a98dfbc87c97fd","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Medium.woff2","hash":"14b3e257c51a6a11d23b2a078017ff340c9777e4","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Light.woff2","hash":"50b654d916204c30987d1987abd890ef92085ae3","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Regular.woff2","hash":"a9714ffb842afc74836e64de04b52d8c37c87c8a","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Regular.woff","hash":"235889d59ddad2b1f3243ccaab7733bd713a2a21","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Thin.woff2","hash":"9b03b1a9071709f5b7dbca13412ecef6cb7a2a67","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Thin.woff","hash":"c0e784de2eb5261cca244928f8a81fd893c3fe16","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Variable.woff","hash":"2e8e6d38d361def5f48baac366f04e3db3ed4828","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Variable.woff2","hash":"e213bb26bc7f10e1df3fe2d03d3ecaecd6e6d371","modified":1706765032184},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.ttf","hash":"67afa6237670ab99125056f2899129f22912dcf3","modified":1706765032184},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"fb363d27cfdfe71a243fa2ac3dab2815232b9b7e","modified":1706765032184},{"_id":"public/lib/font-awesome/webfonts/fa-v4compatibility.ttf","hash":"a9d072aca9e0fadc2a7167671ce3d6b18d9cd2cc","modified":1706765032184},{"_id":"public/lib/font-awesome/webfonts/fa-v4compatibility.woff2","hash":"8f80d0bbe995f7fe92320fdaec10cd5ccd710a51","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Black.eot","hash":"91152bd73e7ff8d943e3bde3ddb0fa0a018e1c21","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Bold.eot","hash":"5c1c680fade45393e4a5bb4548a092cd5ea6811e","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Bold.ttf","hash":"122bb778b17a152c426a825ee981610a4bd59bf3","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Black.ttf","hash":"b65915e3fa57b5c19995d15dc2341d115c1971b9","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Light.ttf","hash":"df82b80c4d3b11e70dcd269fc62ac97cbfa0414d","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Light.eot","hash":"a059359e9bea17dc2ff2ede955a05bf0dc4d00d0","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Medium.eot","hash":"d9ec1f9f3fefd57e446cbe86dc297f1ff269b6de","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Medium.ttf","hash":"948a091f0fdb8c7ae17d5ef8e51bd8830d65dd9a","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Regular.eot","hash":"521c01f0eb79a48025e972ecbe21b0d7fb15437b","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Regular.ttf","hash":"643c28c8f8a2bce1a0d62525aa045cd9883773cd","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Thin.eot","hash":"a0ea0bdaef00b35544f9a21d25d35db9a79f7189","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Thin.ttf","hash":"6aacb0eecb03c660570b6e159ba5ca97ca7461cf","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Variable.eot","hash":"af46f7f4e10a1440a4c97b350622d279143e6798","modified":1706765032184},{"_id":"public/lib/vazir-font/Vazir-Variable.ttf","hash":"1e08b6373c2e086f24776df9b11e4be6bbcc8a4a","modified":1706765032184},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"4350f9ba93384634faf35f41c503c99c767f1069","modified":1706765032184},{"_id":"public/css/rtl.css","hash":"9589fac02a34fd9084f805f801889028756bbb65","modified":1706765032184},{"_id":"public/css/style.css","hash":"3d3a93cdc3f51c8f409c149b66d2bebd059488a0","modified":1706765032184},{"_id":"public/js/search.js","hash":"914a2ce72fb325106c61600200be823b72bfb39f","modified":1706765032184},{"_id":"public/lib/clipboard/clipboard.min.js","hash":"9a7cb405f9beed005891587d41f76a0720893ffc","modified":1706765032184},{"_id":"public/js/main.js","hash":"50531951ae728ae01c6ce1bcc8c5872a9e5d69b4","modified":1706765032184},{"_id":"public/lib/vazir-font/font-face.css","hash":"ba0030e1cd28a8caa7a5bb74b98da7c7bb185c90","modified":1706765032184},{"_id":"public/lib/jquery/jquery.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1706765032184},{"_id":"public/lib/justified-gallery/css/justifiedGallery.min.css","hash":"dd3052149d3054f35efb823c68dd78e78aad5875","modified":1706765032184},{"_id":"public/lib/justified-gallery/js/jquery.justifiedGallery.min.js","hash":"ad8f48b4022498078b089fcdd1e8b47faf496931","modified":1706765032184},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"8c06d82739d14b094ff6d9036021a252bd1d985d","modified":1706765032184},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.ttf","hash":"f0982a77285d53653845b0a78170b4688db972f1","modified":1706765032184},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"6b99aa650bd12a36caa14e0127435d8f4cd3ba73","modified":1706765032184},{"_id":"public/images/logo.png","hash":"8f9ecdb0b8a748e62f9d3fa33b7e67cfd2f900e5","modified":1725621871854},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.ttf","hash":"20bd663830188cbadd2264e1daf9497c3ffc3621","modified":1706765032184},{"_id":"public/lib/meslo-LG/MesloLGL-Italic.ttf","hash":"96c97a0a098ca40802f948ae56fa37aa6683d034","modified":1706765032184},{"_id":"public/lib/meslo-LG/MesloLGM-Italic.ttf","hash":"68700db02debd4b922304134da83b829cbfddfc9","modified":1706765032184},{"_id":"public/lib/meslo-LG/MesloLGS-Italic.ttf","hash":"7f7cdbdcc26279c04046632e22d872f111bc9399","modified":1706765032184},{"_id":"public/lib/meslo-LG/MesloLGL-BoldItalic.ttf","hash":"a9a431fc7a6c3a67c98021d4035c12a07a4f1070","modified":1706765032184},{"_id":"public/lib/meslo-LG/MesloLGL-Bold.ttf","hash":"bfa1ed9a263ed78462f06d322de13bd5bd0906b2","modified":1706765032184},{"_id":"public/lib/meslo-LG/MesloLGM-Bold.ttf","hash":"a8a8df3393bccc365335fc5eb0a62a6b7ccd32b9","modified":1706765032184},{"_id":"public/lib/meslo-LG/MesloLGM-BoldItalic.ttf","hash":"65ddb11e75ee93909e845ab912a36717c48f1c94","modified":1706765032184},{"_id":"public/lib/meslo-LG/MesloLGL-Regular.ttf","hash":"2b912dd13f052f645ee19951604610bb350d50af","modified":1706765032184},{"_id":"public/lib/meslo-LG/MesloLGS-BoldItalic.ttf","hash":"d895a1bd25e36c58b7f463ebe14de09f186d5ab4","modified":1706765032184},{"_id":"public/lib/meslo-LG/MesloLGS-Bold.ttf","hash":"df202ce09cbdc70bc16b81983a13ef0f94e46f10","modified":1706765032184},{"_id":"public/lib/meslo-LG/MesloLGM-Regular.ttf","hash":"5e220152adefe905b2197f873d7cee99eca50e91","modified":1706765032184},{"_id":"public/lib/meslo-LG/MesloLGS-Regular.ttf","hash":"56fa0e33a390b704afc56af93a31576ccdbbdd9e","modified":1706765032184},{"_id":"source/_posts/Home_Assistant/.DS_Store","hash":"339cf75ba4daa757e9fc9e63f0b96c80bbc959a1","modified":1727600253475},{"_id":"source/_posts/Home_Assistant/Home_Assistant_HTTPS.md","hash":"8812a3075e87911c50d1b27588ea30ac9820f5ba","modified":1706767943569},{"_id":"source/_posts/Home_Assistant/Home_Assistant_HTTPS/20211019_001515000_iOS.png","hash":"bf96eb64a35defdcb2f798d579edfde38bc0408b","modified":1702257806379},{"_id":"source/_posts/Home_Assistant/Home_Assistant_HTTPS/20211019_001547000_iOS.png","hash":"abeddc4591f0543f82770f0fd79818f75bc1fdb1","modified":1702257806380},{"_id":"source/_posts/Home_Assistant/Home_Assistant_HTTPS/20211019_001714000_iOS.png","hash":"c3936d989fc26af49e645695ec25705938af0522","modified":1702257806381},{"_id":"public/2021/10/19/home-assistant/home-assistant-https/index.html","hash":"a574eb27fdb952297b4c07c47a072e69a5dc3193","modified":1726639938994},{"_id":"public/2021/10/19/home-assistant/home-assistant-https/20211019_001714000_iOS.png","hash":"c3936d989fc26af49e645695ec25705938af0522","modified":1706768488070},{"_id":"public/2021/10/19/home-assistant/home-assistant-https/20211019_001515000_iOS.png","hash":"bf96eb64a35defdcb2f798d579edfde38bc0408b","modified":1706768488070},{"_id":"public/2021/10/19/home-assistant/home-assistant-https/20211019_001547000_iOS.png","hash":"abeddc4591f0543f82770f0fd79818f75bc1fdb1","modified":1706768488070},{"_id":"source/_posts/Home_Assistant/安装Home_Assistant容器.md","hash":"2d9d3a55ee39b766ff90d24ac59da0036d4bff84","modified":1725261555486},{"_id":"public/2021/10/17/home-assistant/an-zhuang-home-assistant-rong-qi/index.html","hash":"20db2ac5878b0e6cd638e9b7d2d6abfaf7f35f6a","modified":1725261593522},{"_id":"themes/cactus/source/.DS_Store","hash":"e1a24a83e70a624f055bd072a1eb35c30c098306","modified":1725872567827},{"_id":"themes/cactus/source/images/apple-touch-icon_bak.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1706681926701},{"_id":"themes/cactus/source/images/favicon-192x192_bak.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1706681926701},{"_id":"themes/cactus/source/images/favicon_bak.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1706681926701},{"_id":"themes/cactus/source/images/IMG_6262_副本.png","hash":"8f9ecdb0b8a748e62f9d3fa33b7e67cfd2f900e5","modified":1725621503284},{"_id":"themes/cactus/source/images/logo_bak.png","hash":"0e3029251dfda26adee2761f71377297e8c26871","modified":1706681926703},{"_id":"public/images/apple-touch-icon_bak.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1725621871854},{"_id":"public/images/favicon-192x192_bak.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1725621871854},{"_id":"public/images/favicon_bak.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1725621871854},{"_id":"public/images/IMG_6262_副本.png","hash":"8f9ecdb0b8a748e62f9d3fa33b7e67cfd2f900e5","modified":1725621871854},{"_id":"public/images/logo_bak.png","hash":"0e3029251dfda26adee2761f71377297e8c26871","modified":1725621871854},{"_id":"themes/cactus/source/images/apple-touch-icon_bak1.png","hash":"09b2c5fae40487d7998845bba363890946ef2527","modified":1725621742107},{"_id":"themes/cactus/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1725857802235},{"_id":"themes/cactus/source/images/IMG_6262.JPG","hash":"6aaa7e63fcbbfca0a20f8d60fc1055e2ca0a3246","modified":1679540538369},{"_id":"public/images/apple-touch-icon_bak1.png","hash":"09b2c5fae40487d7998845bba363890946ef2527","modified":1725857855725},{"_id":"public/images/IMG_6262.JPG","hash":"6aaa7e63fcbbfca0a20f8d60fc1055e2ca0a3246","modified":1725857855725},{"_id":"source/_posts/Python/Requests库使用指南.md","hash":"2cc9aa63c70065cacfd5f2c6ec40cb76774f6903","modified":1726640510506},{"_id":"public/2022/02/08/python/requests-ku-shi-yong-zhi-nan/index.html","hash":"a43eb208ce069934050b50ebee1303d00b01fffd","modified":1726640533322},{"_id":"public/archives/2022/index.html","hash":"14fdb94e7de318879636dcad7af154e369ff65a6","modified":1727334891107},{"_id":"public/archives/2022/02/index.html","hash":"55eae081e0d5cd9a4ce9e5f6ee4328525f9a6656","modified":1727334891107},{"_id":"public/categories/Python/index.html","hash":"d1ace6d3b5c26affc80867323351e92a8bbc5c36","modified":1727334891107},{"_id":"public/tags/requests/index.html","hash":"7061c6ad2a58aaa62e81a5f21d817b790036fafe","modified":1727334891107},{"_id":"source/_posts/Home_Assistant/如何使用Home Assistant更新DDNS记录.md","hash":"fc2c73503510c84569b0329d081f62545cef02b6","modified":1727334745426},{"_id":"source/_posts/Home_Assistant/如何使用Home Assistant更新DDNS记录/openapi.json","hash":"e2f4e1831f19db09f1cce6f5a4cfc2aef737e7c6","modified":1727329066640},{"_id":"public/2024/09/26/home-assistant/ru-he-shi-yong-home-assistant-geng-xin-ddns-ji-lu/index.html","hash":"0a33e3a99ffd95c4f73899e84ddb4bd0ec8e100f","modified":1727599846542},{"_id":"public/archives/2024/09/index.html","hash":"e25b17bc2686e37ebe211aab2c8db8cc909aa755","modified":1727599846542},{"_id":"public/archives/2024/index.html","hash":"e958dece3ea21f0805a3eb17bbd02479d1c54b48","modified":1727599846542},{"_id":"public/2024/09/26/home-assistant/ru-he-shi-yong-home-assistant-geng-xin-ddns-ji-lu/openapi.json","hash":"1a90a0d92451529cd68a5466e28e8b465eb57b82","modified":1727334891107},{"_id":"source/CNAME","hash":"fab913a9f3de9fd309efb22bd057b819ab11e1da","modified":1727340728179},{"_id":"source/_posts/Home_Assistant/用Home Assistanat跟踪汽油价格.md","hash":"80f4d3705a1d01d1f6c724ae8db674b98ca5723b","modified":1727600181121},{"_id":"source/_posts/Home_Assistant/用Home Assistanat跟踪汽油价格/Pasted image 20240929162823.png","hash":"e1fb4933af5df40e95ea6a5b498a64ef06e35c70","modified":1727598503293},{"_id":"source/_posts/Home_Assistant/用Home Assistanat跟踪汽油价格/F8B7D9EE-6145-4C58-AF0D-72244715D40B_1_201_a.jpeg","hash":"3a74b4f25afc7b314ae72761c27db2d79f17a678","modified":1727598039854},{"_id":"public/2024/09/29/home-assistant/yong-home-assistanat-gen-zong-qi-you-jie-ge/index.html","hash":"f81e6d22b6b77f551e9bfaeb2880be27f3c7d36e","modified":1727600262891},{"_id":"public/CNAME","hash":"fab913a9f3de9fd309efb22bd057b819ab11e1da","modified":1727599846542},{"_id":"public/2024/09/29/home-assistant/yong-home-assistanat-gen-zong-qi-you-jie-ge/Pasted image 20240929162823.png","hash":"e1fb4933af5df40e95ea6a5b498a64ef06e35c70","modified":1727599846542},{"_id":"public/2024/09/29/home-assistant/yong-home-assistanat-gen-zong-qi-you-jie-ge/F8B7D9EE-6145-4C58-AF0D-72244715D40B_1_201_a.jpeg","hash":"3a74b4f25afc7b314ae72761c27db2d79f17a678","modified":1727599846542},{"_id":"source/_posts/Home_Assistant/用Home Assistanat跟踪汽油价格/Pasted_image_20240929162823.png","hash":"e1fb4933af5df40e95ea6a5b498a64ef06e35c70","modified":1727598503293},{"_id":"public/2024/09/29/home-assistant/yong-home-assistanat-gen-zong-qi-you-jie-ge/Pasted_image_20240929162823.png","hash":"e1fb4933af5df40e95ea6a5b498a64ef06e35c70","modified":1727600262891}],"Category":[{"name":"RaspberryPi","_id":"cls2rtzhn00042yec71sv7tha"},{"name":"Home_Assistant","_id":"cls2rtzhq00072yecd8c3cgt1"},{"name":"Python","_id":"cm17gu7x400013tec0qlrbqsn"}],"Data":[],"Page":[{"title":"search","type":"search","date":"2024-02-01T03:42:53.000Z","_content":"","source":"search/index.md","raw":"---\ntitle: search\ntype: search\ndate: 2024-02-01 11:42:53\n---\n","updated":"2024-02-01T03:43:23.163Z","path":"search/index.html","comments":1,"layout":"page","_id":"cls2rtzhf00002yec2bxe9jn4","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2022-02-25T04:18:38.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2022-02-25 12:18:38\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2023-12-12T07:01:50.394Z","path":"categories/index.html","comments":1,"_id":"cls2rtzhl00022yecbo99bw30","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2022-02-25T04:18:27.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2022-02-25 12:18:27\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2023-12-12T07:01:50.395Z","path":"tags/index.html","comments":1,"_id":"cls2rtzhp00062yec12bzh4pr","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"在树莓派上部署Hexo博客","date":"2023-12-28T00:37:00.000Z","_content":"本文主要介绍如何将Hexo博客部署在树莓派上，从而实现在本地局域网直接访问博客内容。由于博客的源码保存在本地PC，并已经同步到Github。因此，只需将Hexo生成的网页文件发布到树莓派的Nginx服务器。\n\n## 安装nginx\n\n首先在树莓派上安装nginx服务器，用于发布博客网站。\n\n获取并更新软件列表。\n\n```bash\nsudo apt-get update\n```\n\n安装 nginx服务器。\n\n```bash\nsudo apt-get install nginx\n```\n\n<!-- more -->\n查看nginx服务器的版本，确认已安装成功。\n\n```bash\n$ nginx -v\nnginx version: nginx/1.18.0\n```\n\n配置nginx服务器随机启动。\n\n```\nsudo systemctl enable nginx.service\n```\n\n创建一个新的文件夹`/var/www/hexo`，用于存放博客的网页文件，并将该文件夹作为nginx服务器的根目录。\n\n```bash\nsudo mkdir -p /var/www/hexo\nsudo chown -R $USER:$USER /var/www/hexo\nsudo chmod -R 755 /var/www/hexo\n```\n\n打开nginx的配置文件，将根目录设置为`/var/www/hexo`。\n\n```bash\nsudo vi /etc/nginx/sites-available/default\n```\n\n将配置文件中默认的根目录`root /var/www/html`用#号注释掉，并在下方添加新的根目录为`root /var/www/hexo`。\n\n```text\n# Default server configuration\n#\nserver {\n\tlisten 80 default_server;\n\tlisten [::]:80 default_server;\n\n\t# SSL configuration\n\t#\n\t# listen 443 ssl default_server;\n\t# listen [::]:443 ssl default_server;\n\t#\n\t# Note: You should disable gzip for SSL traffic.\n\t# See: https://bugs.debian.org/773332\n\t#\n\t# Read up on ssl_ciphers to ensure a secure configuration.\n\t# See: https://bugs.debian.org/765782\n\t#\n\t# Self signed certs generated by the ssl-cert package\n\t# Don't use them in a production server!\n\t#\n\t# include snippets/snakeoil.conf;\n\n\t#root /var/www/html;\n\troot /var/www/hexo;\n```\n\n配置完成后，重启 nginx服务器。\n\n```bash\nsudo service nginx restart\n```\n\n## 安装 git\n\n查看树莓派上是否已安装git，如果没有安装，可以执行以下命令。\n\n```bash\nsudo apt-get install git\n```\n\n安装完成后，查看版本，确认已安装成功。\n\n```bash\n$ git --version\ngit version 2.30.2\n```\n\n## 远程Git仓库\n\n在树莓派上建立一个远程仓库，这样本地PC就可以将网页文件提交到该仓库。\n\n创建一个新的文件夹，并在该文件夹下面建立一个新的Git仓库。\n\n```bash\nmkdir /home/pi/myapps/git_repository\ncd /home/pi/myapps/git_repository\ngit init --bare myblog.git\n```\n\n**git init** - 创建一个空的Git仓库或者重新初始化现有的仓库。\n**--bare** - 创建一个全新的Git仓库。\n**myblog.git** - 仓库的名称为myblog，并添加后缀.git。\n\n然后在仓库 `myblog.git` 下创建一个钩子，将网页文件传送到nginx服务器的根目录下，即 `/var/www/hexo`下面：\n\n```text\n#在仓库下创建一个新的钩子文件\nsudo vi /home/pi/myblog.git/hooks/post-receive\n```\n\n在文件中添加以下命令，然后保存文件。该命令中的`--work-tree`参数可以将目录`/var/www/hexo`映射到仓库中，本地提交的网页文件会自动存储到`/var/www/hexo`目录下。\n\n```text\n#!/bin/bash\ngit --work-tree=/var/www/hexo --git-dir=/home/pi/myapps/git_repository/myblog.git checkout -f\n```\n\n为文件`post-receive`添加可执行权限。\n\n```text\nsudo chmod +x /var/repo/web_blog.git/hooks/post-receive\n```\n\n## 配置SSH公钥登录\n\n在本地 PC上生成公钥文件`id_rsa.pub`。\n\n```\n$ ssh-keygen -t rsa -P ''\n\t\t\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/user/.ssh/id_rsa):\nYour identification has been saved in /user/.ssh/id_rsa.\nYour public key has been saved in /user/.ssh/id_rsa.pub.\nThe key fingerprint is:\n3f:35:7c:d2:33:65:d6:69:7f:34:92:31:38:1d:c1:94 user@bogon\nThe key's randomart image is:\n+--[ RSA 2048]----+\n|            =B==B|\n|           o E*o=|\n|            ... o|\n|         . . .  .|\n|        S + o    |\n|         o o     |\n|          +      |\n|         . .     |\n|                 |\n+————————+\n```\n\n本地PC的公钥上传到树莓派。\n\n```text\nssh-copy-id -i ~/.ssh/id_rsa.pub pi@pi\n```\n\n以上命令会将本地PC的公钥写入到树莓派的`~/.ssh/authorized_keys`文件中。如果树莓派上不存在文件`authorized_keys`，`ssh-copy-id`会新建文件。\n\n## 配置本地Hexo\n\n打开Hexo的配置文件`_config.yml`，设置部署博客的方式。\n\ntype: git\nrepo: pi@pi:/home/pi/myapps/git_repository/myblog\nbranch: main\n\n```text\ndeploy:\n  - type: git\n    repo: pi@pi:/home/pi/myapps/git_repository/myblog\n    branch: main\n```\n\n在本地PC执行命令`hexo g -d`后，本地生成的网页文件会自动部署到树莓派上。\n\n```\nhexo g -d\n```","source":"_posts/RaspberryPi/在树莓派上部署Hexo博客.md","raw":"---\ntitle: 在树莓派上部署Hexo博客\ndate: 2023-12-28 08:37:00\ntags:\n  - \"#raspberrypi\"\n  - \"#hexo\"\ncategories:\n  - RaspberryPi\n---\n本文主要介绍如何将Hexo博客部署在树莓派上，从而实现在本地局域网直接访问博客内容。由于博客的源码保存在本地PC，并已经同步到Github。因此，只需将Hexo生成的网页文件发布到树莓派的Nginx服务器。\n\n## 安装nginx\n\n首先在树莓派上安装nginx服务器，用于发布博客网站。\n\n获取并更新软件列表。\n\n```bash\nsudo apt-get update\n```\n\n安装 nginx服务器。\n\n```bash\nsudo apt-get install nginx\n```\n\n<!-- more -->\n查看nginx服务器的版本，确认已安装成功。\n\n```bash\n$ nginx -v\nnginx version: nginx/1.18.0\n```\n\n配置nginx服务器随机启动。\n\n```\nsudo systemctl enable nginx.service\n```\n\n创建一个新的文件夹`/var/www/hexo`，用于存放博客的网页文件，并将该文件夹作为nginx服务器的根目录。\n\n```bash\nsudo mkdir -p /var/www/hexo\nsudo chown -R $USER:$USER /var/www/hexo\nsudo chmod -R 755 /var/www/hexo\n```\n\n打开nginx的配置文件，将根目录设置为`/var/www/hexo`。\n\n```bash\nsudo vi /etc/nginx/sites-available/default\n```\n\n将配置文件中默认的根目录`root /var/www/html`用#号注释掉，并在下方添加新的根目录为`root /var/www/hexo`。\n\n```text\n# Default server configuration\n#\nserver {\n\tlisten 80 default_server;\n\tlisten [::]:80 default_server;\n\n\t# SSL configuration\n\t#\n\t# listen 443 ssl default_server;\n\t# listen [::]:443 ssl default_server;\n\t#\n\t# Note: You should disable gzip for SSL traffic.\n\t# See: https://bugs.debian.org/773332\n\t#\n\t# Read up on ssl_ciphers to ensure a secure configuration.\n\t# See: https://bugs.debian.org/765782\n\t#\n\t# Self signed certs generated by the ssl-cert package\n\t# Don't use them in a production server!\n\t#\n\t# include snippets/snakeoil.conf;\n\n\t#root /var/www/html;\n\troot /var/www/hexo;\n```\n\n配置完成后，重启 nginx服务器。\n\n```bash\nsudo service nginx restart\n```\n\n## 安装 git\n\n查看树莓派上是否已安装git，如果没有安装，可以执行以下命令。\n\n```bash\nsudo apt-get install git\n```\n\n安装完成后，查看版本，确认已安装成功。\n\n```bash\n$ git --version\ngit version 2.30.2\n```\n\n## 远程Git仓库\n\n在树莓派上建立一个远程仓库，这样本地PC就可以将网页文件提交到该仓库。\n\n创建一个新的文件夹，并在该文件夹下面建立一个新的Git仓库。\n\n```bash\nmkdir /home/pi/myapps/git_repository\ncd /home/pi/myapps/git_repository\ngit init --bare myblog.git\n```\n\n**git init** - 创建一个空的Git仓库或者重新初始化现有的仓库。\n**--bare** - 创建一个全新的Git仓库。\n**myblog.git** - 仓库的名称为myblog，并添加后缀.git。\n\n然后在仓库 `myblog.git` 下创建一个钩子，将网页文件传送到nginx服务器的根目录下，即 `/var/www/hexo`下面：\n\n```text\n#在仓库下创建一个新的钩子文件\nsudo vi /home/pi/myblog.git/hooks/post-receive\n```\n\n在文件中添加以下命令，然后保存文件。该命令中的`--work-tree`参数可以将目录`/var/www/hexo`映射到仓库中，本地提交的网页文件会自动存储到`/var/www/hexo`目录下。\n\n```text\n#!/bin/bash\ngit --work-tree=/var/www/hexo --git-dir=/home/pi/myapps/git_repository/myblog.git checkout -f\n```\n\n为文件`post-receive`添加可执行权限。\n\n```text\nsudo chmod +x /var/repo/web_blog.git/hooks/post-receive\n```\n\n## 配置SSH公钥登录\n\n在本地 PC上生成公钥文件`id_rsa.pub`。\n\n```\n$ ssh-keygen -t rsa -P ''\n\t\t\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/user/.ssh/id_rsa):\nYour identification has been saved in /user/.ssh/id_rsa.\nYour public key has been saved in /user/.ssh/id_rsa.pub.\nThe key fingerprint is:\n3f:35:7c:d2:33:65:d6:69:7f:34:92:31:38:1d:c1:94 user@bogon\nThe key's randomart image is:\n+--[ RSA 2048]----+\n|            =B==B|\n|           o E*o=|\n|            ... o|\n|         . . .  .|\n|        S + o    |\n|         o o     |\n|          +      |\n|         . .     |\n|                 |\n+————————+\n```\n\n本地PC的公钥上传到树莓派。\n\n```text\nssh-copy-id -i ~/.ssh/id_rsa.pub pi@pi\n```\n\n以上命令会将本地PC的公钥写入到树莓派的`~/.ssh/authorized_keys`文件中。如果树莓派上不存在文件`authorized_keys`，`ssh-copy-id`会新建文件。\n\n## 配置本地Hexo\n\n打开Hexo的配置文件`_config.yml`，设置部署博客的方式。\n\ntype: git\nrepo: pi@pi:/home/pi/myapps/git_repository/myblog\nbranch: main\n\n```text\ndeploy:\n  - type: git\n    repo: pi@pi:/home/pi/myapps/git_repository/myblog\n    branch: main\n```\n\n在本地PC执行命令`hexo g -d`后，本地生成的网页文件会自动部署到树莓派上。\n\n```\nhexo g -d\n```","slug":"RaspberryPi/在树莓派上部署Hexo博客","published":1,"updated":"2023-12-28T04:42:13.294Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls2rtzhi00012yechax81l8w","content":"<p>本文主要介绍如何将Hexo博客部署在树莓派上，从而实现在本地局域网直接访问博客内容。由于博客的源码保存在本地PC，并已经同步到Github。因此，只需将Hexo生成的网页文件发布到树莓派的Nginx服务器。</p>\n<h2 id=\"安装nginx\"><a href=\"#安装nginx\" class=\"headerlink\" title=\"安装nginx\"></a>安装nginx</h2><p>首先在树莓派上安装nginx服务器，用于发布博客网站。</p>\n<p>获取并更新软件列表。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br></pre></td></tr></table></figure>\n\n<p>安装 nginx服务器。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install nginx</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n<p>查看nginx服务器的版本，确认已安装成功。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ nginx -v</span><br><span class=\"line\">nginx version: nginx/1.18.0</span><br></pre></td></tr></table></figure>\n\n<p>配置nginx服务器随机启动。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl enable nginx.service</span><br></pre></td></tr></table></figure>\n\n<p>创建一个新的文件夹<code>/var/www/hexo</code>，用于存放博客的网页文件，并将该文件夹作为nginx服务器的根目录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo <span class=\"built_in\">mkdir</span> -p /var/www/hexo</span><br><span class=\"line\">sudo <span class=\"built_in\">chown</span> -R <span class=\"variable\">$USER</span>:<span class=\"variable\">$USER</span> /var/www/hexo</span><br><span class=\"line\">sudo <span class=\"built_in\">chmod</span> -R 755 /var/www/hexo</span><br></pre></td></tr></table></figure>\n\n<p>打开nginx的配置文件，将根目录设置为<code>/var/www/hexo</code>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo vi /etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure>\n\n<p>将配置文件中默认的根目录<code>root /var/www/html</code>用#号注释掉，并在下方添加新的根目录为<code>root /var/www/hexo</code>。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Default server configuration</span><br><span class=\"line\">#</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">\tlisten 80 default_server;</span><br><span class=\"line\">\tlisten [::]:80 default_server;</span><br><span class=\"line\"></span><br><span class=\"line\">\t# SSL configuration</span><br><span class=\"line\">\t#</span><br><span class=\"line\">\t# listen 443 ssl default_server;</span><br><span class=\"line\">\t# listen [::]:443 ssl default_server;</span><br><span class=\"line\">\t#</span><br><span class=\"line\">\t# Note: You should disable gzip for SSL traffic.</span><br><span class=\"line\">\t# See: https://bugs.debian.org/773332</span><br><span class=\"line\">\t#</span><br><span class=\"line\">\t# Read up on ssl_ciphers to ensure a secure configuration.</span><br><span class=\"line\">\t# See: https://bugs.debian.org/765782</span><br><span class=\"line\">\t#</span><br><span class=\"line\">\t# Self signed certs generated by the ssl-cert package</span><br><span class=\"line\">\t# Don&#x27;t use them in a production server!</span><br><span class=\"line\">\t#</span><br><span class=\"line\">\t# include snippets/snakeoil.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">\t#root /var/www/html;</span><br><span class=\"line\">\troot /var/www/hexo;</span><br></pre></td></tr></table></figure>\n\n<p>配置完成后，重启 nginx服务器。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo service nginx restart</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"安装-git\"><a href=\"#安装-git\" class=\"headerlink\" title=\"安装 git\"></a>安装 git</h2><p>查看树莓派上是否已安装git，如果没有安装，可以执行以下命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install git</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后，查看版本，确认已安装成功。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git --version</span><br><span class=\"line\">git version 2.30.2</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"远程Git仓库\"><a href=\"#远程Git仓库\" class=\"headerlink\" title=\"远程Git仓库\"></a>远程Git仓库</h2><p>在树莓派上建立一个远程仓库，这样本地PC就可以将网页文件提交到该仓库。</p>\n<p>创建一个新的文件夹，并在该文件夹下面建立一个新的Git仓库。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> /home/pi/myapps/git_repository</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /home/pi/myapps/git_repository</span><br><span class=\"line\">git init --bare myblog.git</span><br></pre></td></tr></table></figure>\n\n<p><strong>git init</strong> - 创建一个空的Git仓库或者重新初始化现有的仓库。<br><strong>–bare</strong> - 创建一个全新的Git仓库。<br><strong>myblog.git</strong> - 仓库的名称为myblog，并添加后缀.git。</p>\n<p>然后在仓库 <code>myblog.git</code> 下创建一个钩子，将网页文件传送到nginx服务器的根目录下，即 <code>/var/www/hexo</code>下面：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">#在仓库下创建一个新的钩子文件</span><br><span class=\"line\">sudo vi /home/pi/myblog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>\n\n<p>在文件中添加以下命令，然后保存文件。该命令中的<code>--work-tree</code>参数可以将目录<code>/var/www/hexo</code>映射到仓库中，本地提交的网页文件会自动存储到<code>/var/www/hexo</code>目录下。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">git --work-tree=/var/www/hexo --git-dir=/home/pi/myapps/git_repository/myblog.git checkout -f</span><br></pre></td></tr></table></figure>\n\n<p>为文件<code>post-receive</code>添加可执行权限。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo chmod +x /var/repo/web_blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置SSH公钥登录\"><a href=\"#配置SSH公钥登录\" class=\"headerlink\" title=\"配置SSH公钥登录\"></a>配置SSH公钥登录</h2><p>在本地 PC上生成公钥文件<code>id_rsa.pub</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -P &#x27;&#x27;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">Generating public/private rsa key pair.</span><br><span class=\"line\">Enter file in which to save the key (/user/.ssh/id_rsa):</span><br><span class=\"line\">Your identification has been saved in /user/.ssh/id_rsa.</span><br><span class=\"line\">Your public key has been saved in /user/.ssh/id_rsa.pub.</span><br><span class=\"line\">The key fingerprint is:</span><br><span class=\"line\">3f:35:7c:d2:33:65:d6:69:7f:34:92:31:38:1d:c1:94 user@bogon</span><br><span class=\"line\">The key&#x27;s randomart image is:</span><br><span class=\"line\">+--[ RSA 2048]----+</span><br><span class=\"line\">|            =B==B|</span><br><span class=\"line\">|           o E*o=|</span><br><span class=\"line\">|            ... o|</span><br><span class=\"line\">|         . . .  .|</span><br><span class=\"line\">|        S + o    |</span><br><span class=\"line\">|         o o     |</span><br><span class=\"line\">|          +      |</span><br><span class=\"line\">|         . .     |</span><br><span class=\"line\">|                 |</span><br><span class=\"line\">+————————+</span><br></pre></td></tr></table></figure>\n\n<p>本地PC的公钥上传到树莓派。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-copy-id -i ~/.ssh/id_rsa.pub pi@pi</span><br></pre></td></tr></table></figure>\n\n<p>以上命令会将本地PC的公钥写入到树莓派的<code>~/.ssh/authorized_keys</code>文件中。如果树莓派上不存在文件<code>authorized_keys</code>，<code>ssh-copy-id</code>会新建文件。</p>\n<h2 id=\"配置本地Hexo\"><a href=\"#配置本地Hexo\" class=\"headerlink\" title=\"配置本地Hexo\"></a>配置本地Hexo</h2><p>打开Hexo的配置文件<code>_config.yml</code>，设置部署博客的方式。</p>\n<p>type: git<br>repo: pi@pi:&#x2F;home&#x2F;pi&#x2F;myapps&#x2F;git_repository&#x2F;myblog<br>branch: main</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  - type: git</span><br><span class=\"line\">    repo: pi@pi:/home/pi/myapps/git_repository/myblog</span><br><span class=\"line\">    branch: main</span><br></pre></td></tr></table></figure>\n\n<p>在本地PC执行命令<code>hexo g -d</code>后，本地生成的网页文件会自动部署到树莓派上。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo g -d</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>本文主要介绍如何将Hexo博客部署在树莓派上，从而实现在本地局域网直接访问博客内容。由于博客的源码保存在本地PC，并已经同步到Github。因此，只需将Hexo生成的网页文件发布到树莓派的Nginx服务器。</p>\n<h2 id=\"安装nginx\"><a href=\"#安装nginx\" class=\"headerlink\" title=\"安装nginx\"></a>安装nginx</h2><p>首先在树莓派上安装nginx服务器，用于发布博客网站。</p>\n<p>获取并更新软件列表。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br></pre></td></tr></table></figure>\n\n<p>安装 nginx服务器。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install nginx</span><br></pre></td></tr></table></figure>","more":"<p>查看nginx服务器的版本，确认已安装成功。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ nginx -v</span><br><span class=\"line\">nginx version: nginx/1.18.0</span><br></pre></td></tr></table></figure>\n\n<p>配置nginx服务器随机启动。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl enable nginx.service</span><br></pre></td></tr></table></figure>\n\n<p>创建一个新的文件夹<code>/var/www/hexo</code>，用于存放博客的网页文件，并将该文件夹作为nginx服务器的根目录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo <span class=\"built_in\">mkdir</span> -p /var/www/hexo</span><br><span class=\"line\">sudo <span class=\"built_in\">chown</span> -R <span class=\"variable\">$USER</span>:<span class=\"variable\">$USER</span> /var/www/hexo</span><br><span class=\"line\">sudo <span class=\"built_in\">chmod</span> -R 755 /var/www/hexo</span><br></pre></td></tr></table></figure>\n\n<p>打开nginx的配置文件，将根目录设置为<code>/var/www/hexo</code>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo vi /etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure>\n\n<p>将配置文件中默认的根目录<code>root /var/www/html</code>用#号注释掉，并在下方添加新的根目录为<code>root /var/www/hexo</code>。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Default server configuration</span><br><span class=\"line\">#</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">\tlisten 80 default_server;</span><br><span class=\"line\">\tlisten [::]:80 default_server;</span><br><span class=\"line\"></span><br><span class=\"line\">\t# SSL configuration</span><br><span class=\"line\">\t#</span><br><span class=\"line\">\t# listen 443 ssl default_server;</span><br><span class=\"line\">\t# listen [::]:443 ssl default_server;</span><br><span class=\"line\">\t#</span><br><span class=\"line\">\t# Note: You should disable gzip for SSL traffic.</span><br><span class=\"line\">\t# See: https://bugs.debian.org/773332</span><br><span class=\"line\">\t#</span><br><span class=\"line\">\t# Read up on ssl_ciphers to ensure a secure configuration.</span><br><span class=\"line\">\t# See: https://bugs.debian.org/765782</span><br><span class=\"line\">\t#</span><br><span class=\"line\">\t# Self signed certs generated by the ssl-cert package</span><br><span class=\"line\">\t# Don&#x27;t use them in a production server!</span><br><span class=\"line\">\t#</span><br><span class=\"line\">\t# include snippets/snakeoil.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">\t#root /var/www/html;</span><br><span class=\"line\">\troot /var/www/hexo;</span><br></pre></td></tr></table></figure>\n\n<p>配置完成后，重启 nginx服务器。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo service nginx restart</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"安装-git\"><a href=\"#安装-git\" class=\"headerlink\" title=\"安装 git\"></a>安装 git</h2><p>查看树莓派上是否已安装git，如果没有安装，可以执行以下命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install git</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后，查看版本，确认已安装成功。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git --version</span><br><span class=\"line\">git version 2.30.2</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"远程Git仓库\"><a href=\"#远程Git仓库\" class=\"headerlink\" title=\"远程Git仓库\"></a>远程Git仓库</h2><p>在树莓派上建立一个远程仓库，这样本地PC就可以将网页文件提交到该仓库。</p>\n<p>创建一个新的文件夹，并在该文件夹下面建立一个新的Git仓库。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> /home/pi/myapps/git_repository</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /home/pi/myapps/git_repository</span><br><span class=\"line\">git init --bare myblog.git</span><br></pre></td></tr></table></figure>\n\n<p><strong>git init</strong> - 创建一个空的Git仓库或者重新初始化现有的仓库。<br><strong>–bare</strong> - 创建一个全新的Git仓库。<br><strong>myblog.git</strong> - 仓库的名称为myblog，并添加后缀.git。</p>\n<p>然后在仓库 <code>myblog.git</code> 下创建一个钩子，将网页文件传送到nginx服务器的根目录下，即 <code>/var/www/hexo</code>下面：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">#在仓库下创建一个新的钩子文件</span><br><span class=\"line\">sudo vi /home/pi/myblog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>\n\n<p>在文件中添加以下命令，然后保存文件。该命令中的<code>--work-tree</code>参数可以将目录<code>/var/www/hexo</code>映射到仓库中，本地提交的网页文件会自动存储到<code>/var/www/hexo</code>目录下。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">git --work-tree=/var/www/hexo --git-dir=/home/pi/myapps/git_repository/myblog.git checkout -f</span><br></pre></td></tr></table></figure>\n\n<p>为文件<code>post-receive</code>添加可执行权限。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo chmod +x /var/repo/web_blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置SSH公钥登录\"><a href=\"#配置SSH公钥登录\" class=\"headerlink\" title=\"配置SSH公钥登录\"></a>配置SSH公钥登录</h2><p>在本地 PC上生成公钥文件<code>id_rsa.pub</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -P &#x27;&#x27;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">Generating public/private rsa key pair.</span><br><span class=\"line\">Enter file in which to save the key (/user/.ssh/id_rsa):</span><br><span class=\"line\">Your identification has been saved in /user/.ssh/id_rsa.</span><br><span class=\"line\">Your public key has been saved in /user/.ssh/id_rsa.pub.</span><br><span class=\"line\">The key fingerprint is:</span><br><span class=\"line\">3f:35:7c:d2:33:65:d6:69:7f:34:92:31:38:1d:c1:94 user@bogon</span><br><span class=\"line\">The key&#x27;s randomart image is:</span><br><span class=\"line\">+--[ RSA 2048]----+</span><br><span class=\"line\">|            =B==B|</span><br><span class=\"line\">|           o E*o=|</span><br><span class=\"line\">|            ... o|</span><br><span class=\"line\">|         . . .  .|</span><br><span class=\"line\">|        S + o    |</span><br><span class=\"line\">|         o o     |</span><br><span class=\"line\">|          +      |</span><br><span class=\"line\">|         . .     |</span><br><span class=\"line\">|                 |</span><br><span class=\"line\">+————————+</span><br></pre></td></tr></table></figure>\n\n<p>本地PC的公钥上传到树莓派。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-copy-id -i ~/.ssh/id_rsa.pub pi@pi</span><br></pre></td></tr></table></figure>\n\n<p>以上命令会将本地PC的公钥写入到树莓派的<code>~/.ssh/authorized_keys</code>文件中。如果树莓派上不存在文件<code>authorized_keys</code>，<code>ssh-copy-id</code>会新建文件。</p>\n<h2 id=\"配置本地Hexo\"><a href=\"#配置本地Hexo\" class=\"headerlink\" title=\"配置本地Hexo\"></a>配置本地Hexo</h2><p>打开Hexo的配置文件<code>_config.yml</code>，设置部署博客的方式。</p>\n<p>type: git<br>repo: pi@pi:&#x2F;home&#x2F;pi&#x2F;myapps&#x2F;git_repository&#x2F;myblog<br>branch: main</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  - type: git</span><br><span class=\"line\">    repo: pi@pi:/home/pi/myapps/git_repository/myblog</span><br><span class=\"line\">    branch: main</span><br></pre></td></tr></table></figure>\n\n<p>在本地PC执行命令<code>hexo g -d</code>后，本地生成的网页文件会自动部署到树莓派上。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo g -d</span><br></pre></td></tr></table></figure>"},{"title":"Home Assistant配置HTTPS","date":"2021-10-19T07:02:00.000Z","_content":"\n默认情况下，Home Assistant安装完成后，使用HTTP访问。如果在内网使用，HTTP相对还比较安全。但是，为了能让手机在外网访问HA网关，需要将其发布到外网（Internet）。因此，首先必须要配置HTTPS，确保数据传输的安全性。\n\n为了节约成本，可以使用自签的SSL证书。或者，也可以选用官方推荐的免费TLS/SSL证书服务：[Let’s Encrypt](https://www.home-assistant.io/docs/ecosystem/certificates/lets_encrypt/)和[Duck DNS integrating Let’s Encrypt](https://www.home-assistant.io/integrations/duckdns/)。\n\n## 制作自签的证书\n\n证书的制作过程都是在树莓派上使用`openssl`完成。\n\n首先创建目录`certs`，并进入该目录：\n\n```Shell\nmkdir certs\ncd certs\n```\n\n### 制作根证书\n\n首先，需要创建根证书密钥，该密钥用于为证书签名。安全起见，该密钥不能泄露给其他人：\n\n```bash\nopenssl genrsa -des3 -out rootCA.key 4096\n```\n\n**该命令生成的Key默认使用密码保护，如果要取消密码保护，只需要移除选项-des3。**\n\n然后用根证书密钥制作根证书：\n\n```bash\nopenssl req -x509 -new -nodes -key rootCA.key -sha256 -days 3650 -out rootCA.pem\n```\n\n如果需要使用苹果设备**macOS vs 10.15 / iOS 13 (or above)**，请使用以下命令制作根证书，区别是根证书的有效期只有 825 天：\n\n```bash\nopenssl req -x509 -new -nodes -key rootCA.key -sha256 -days 825 -out rootCA.pem\n```\n\n### 制作服务器证书\n\n请根据以下步骤，制作Home Assistant服务器的证书。\n\n创建`rootCA.csr.cnf`文件\n\n```\ntouch rootCA.csr.cnf\nvi rootCA.csr.cnf\n```\n\n将以下内容复制-粘贴到文件`rootCA.csr.cnf`：\n\n```\n# rootCA.csr.cnf\n[req]\ndefault_bits = 2048\nprompt = no\ndefault_md = sha256\ndistinguished_name = dn\n             \n[dn]\nC=CN\nST=Shanghai\nL=Shanghai\nO=HA\nOU=HAU\nemailAddress=admin@ha.com\nCN = ivpn.asuscomm.com   \n```\n\n创建`v3.ext`文件\n\n```\ntouch v3.ext\nvi v3.ext\n```\n\n将以下内容复制-粘贴到文件`v3.ext`：\n\n```\n# v3.ext\nauthorityKeyIdentifier=keyid,issuer\nbasicConstraints=CA:FALSE\nkeyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment\nsubjectAltName = @alt_names\nextendedKeyUsage=serverAuth\n                \n[alt_names]\nDNS.1 = ivpn.asuscomm.com\nIP.1 = 192.168.1.65\n```\n\n创建证书密钥`hassio.csr`:\n\n```bash\nopenssl req -new -sha256 -nodes -out hassio.csr -newkey rsa:2048 -keyout hassio.key -config <( cat rootCA.csr.cnf )\n```\n\n如果在Windows平台上运行该命令，需要注意-config参数后面rootCA.csr.cnf文件的路径地址。请参考以下例子：\n\n```bash\nopenssl req -new -sha256 -nodes -out hassio.csr -newkey rsa:2048 -keyout hassio.key -config \"C:\\Program Files\\Git\\usr\\bin\\rootCA.csr.cnf\"\n```\n\n创建证书`hassio.csr`:\n\n```bash\nopenssl x509 -req -in hassio.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out hassio.crt -days 3650 -sha256 -extfile v3.ext\n```\n\n如果需要使用苹果设备**macOS vs 10.15 / iOS 13 (or above)**，请使用以下命令：\n\n```bash\nopenssl x509 -req -in hassio.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out hassio.crt -days 825 -sha256 -extfile v3.ext\n```\n\n## 配置Home Assistant\n\n将服务器证书和私钥重新命名为.pem格式：\n\n```\nrename hassio.crt fullchain.pem\nrename hassio.key privkey.pem\n```\n\n将证书复制到`/PATH_TO_YOUR_CONFIG/ssl`目录：\n\n**这里需要注意的是，由于采用了Docker方式安装HA，没有权限访问/etc目录，所以，只能将证书复制到/PATH_TO_YOUR_CONFIG/ssl。**\n\n```bash\nmkdir /PATH_TO_YOUR_CONFIG/ssl\ncp fullchain.pem /PATH_TO_YOUR_CONFIG/ssl/\ncp privkey.pem /PATH_TO_YOUR_CONFIG/ssl/\n```\n\n修改配置文件`configuration.yaml`：\n\n```YAML\nhttp:                                                                       \n\tssl_certificate: ./ssl/fullchain.pem                                     \n\tssl_key: ./ssl/privkey.pem  \n```\n\n## 将Home Assistant发布到公网\n\n由于本地网络没有公网IP地址，因此通过SSH Tunnel的方式，将Home Assistant网关映射到远端网络，并发布到公网上。\n\n在HA网关上运行以下命令，该命令会将本地的8123端口映射到远端树莓派的10000端口。\n\n```Shell\nautossh -f -M 0 -NR 0.0.0.0:10000:localhost:8123 pi@ivpn.asuscomm.com -p 30100\n```\n\n然后，创建计划任务，每次HA网关重启后，会自动执行以上命令。\n\n```Text\ncrontab -e\n@reboot autossh -f -M 0 -NR 0.0.0.0:10000:localhost:8123 pi@ivpn.asuscomm.com -p 30100 &\n```\n\n在远端路由器上，选择**外部网络(WAN) - 端口转发 - 自定义设置** ，添加端口转发的条目。\n\n```Text\n服务名称：Home-Assistant\n通信协议：TCP\n外部端口：10000\n内部端口：10000\n本地IP地址：192.168.100.100\n```\n\n## iOS如何安装根证书\n\n点击`rootCA.pem`文件，安装根证书。\n\n![](20211019_001515000_iOS.png)\n\n打开**设置**应用，找到**已下载描述文件**，点击**安装**，安装过程中需要输入手机密码。\n\n![](20211019_001547000_iOS.png)\n\n安装完成后，需要在**设置 - 通用 - 关于本机 - 证书信任设置**中，启用安装的根证书。\n\n![](20211019_001714000_iOS.png)\n\n## Android如何安装根证书\n\n重新命名`rootCA.pem`文件为`rootCA.crt`。\n\n```\nrename rootCA.pem rootCA.crt\n```\n\n在Android设备上点击安装`rootCA.crt`文件。\n\n## Mac如何安装根证书\n\n打开终端工具，输入以下命令：\n\n```Shell\nCERT=\"/path/to/my/cert/my-root.crt\"\nsudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain $CERT\n```\n\n","source":"_posts/Home_Assistant/Home_Assistant_HTTPS.md","raw":"---\ntitle: Home Assistant配置HTTPS\ndate: 2021-10-19 15:02:00\ntags:\n  - home_assistant\ncategories:\n  - Home_Assistant\n---\n\n默认情况下，Home Assistant安装完成后，使用HTTP访问。如果在内网使用，HTTP相对还比较安全。但是，为了能让手机在外网访问HA网关，需要将其发布到外网（Internet）。因此，首先必须要配置HTTPS，确保数据传输的安全性。\n\n为了节约成本，可以使用自签的SSL证书。或者，也可以选用官方推荐的免费TLS/SSL证书服务：[Let’s Encrypt](https://www.home-assistant.io/docs/ecosystem/certificates/lets_encrypt/)和[Duck DNS integrating Let’s Encrypt](https://www.home-assistant.io/integrations/duckdns/)。\n\n## 制作自签的证书\n\n证书的制作过程都是在树莓派上使用`openssl`完成。\n\n首先创建目录`certs`，并进入该目录：\n\n```Shell\nmkdir certs\ncd certs\n```\n\n### 制作根证书\n\n首先，需要创建根证书密钥，该密钥用于为证书签名。安全起见，该密钥不能泄露给其他人：\n\n```bash\nopenssl genrsa -des3 -out rootCA.key 4096\n```\n\n**该命令生成的Key默认使用密码保护，如果要取消密码保护，只需要移除选项-des3。**\n\n然后用根证书密钥制作根证书：\n\n```bash\nopenssl req -x509 -new -nodes -key rootCA.key -sha256 -days 3650 -out rootCA.pem\n```\n\n如果需要使用苹果设备**macOS vs 10.15 / iOS 13 (or above)**，请使用以下命令制作根证书，区别是根证书的有效期只有 825 天：\n\n```bash\nopenssl req -x509 -new -nodes -key rootCA.key -sha256 -days 825 -out rootCA.pem\n```\n\n### 制作服务器证书\n\n请根据以下步骤，制作Home Assistant服务器的证书。\n\n创建`rootCA.csr.cnf`文件\n\n```\ntouch rootCA.csr.cnf\nvi rootCA.csr.cnf\n```\n\n将以下内容复制-粘贴到文件`rootCA.csr.cnf`：\n\n```\n# rootCA.csr.cnf\n[req]\ndefault_bits = 2048\nprompt = no\ndefault_md = sha256\ndistinguished_name = dn\n             \n[dn]\nC=CN\nST=Shanghai\nL=Shanghai\nO=HA\nOU=HAU\nemailAddress=admin@ha.com\nCN = ivpn.asuscomm.com   \n```\n\n创建`v3.ext`文件\n\n```\ntouch v3.ext\nvi v3.ext\n```\n\n将以下内容复制-粘贴到文件`v3.ext`：\n\n```\n# v3.ext\nauthorityKeyIdentifier=keyid,issuer\nbasicConstraints=CA:FALSE\nkeyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment\nsubjectAltName = @alt_names\nextendedKeyUsage=serverAuth\n                \n[alt_names]\nDNS.1 = ivpn.asuscomm.com\nIP.1 = 192.168.1.65\n```\n\n创建证书密钥`hassio.csr`:\n\n```bash\nopenssl req -new -sha256 -nodes -out hassio.csr -newkey rsa:2048 -keyout hassio.key -config <( cat rootCA.csr.cnf )\n```\n\n如果在Windows平台上运行该命令，需要注意-config参数后面rootCA.csr.cnf文件的路径地址。请参考以下例子：\n\n```bash\nopenssl req -new -sha256 -nodes -out hassio.csr -newkey rsa:2048 -keyout hassio.key -config \"C:\\Program Files\\Git\\usr\\bin\\rootCA.csr.cnf\"\n```\n\n创建证书`hassio.csr`:\n\n```bash\nopenssl x509 -req -in hassio.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out hassio.crt -days 3650 -sha256 -extfile v3.ext\n```\n\n如果需要使用苹果设备**macOS vs 10.15 / iOS 13 (or above)**，请使用以下命令：\n\n```bash\nopenssl x509 -req -in hassio.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out hassio.crt -days 825 -sha256 -extfile v3.ext\n```\n\n## 配置Home Assistant\n\n将服务器证书和私钥重新命名为.pem格式：\n\n```\nrename hassio.crt fullchain.pem\nrename hassio.key privkey.pem\n```\n\n将证书复制到`/PATH_TO_YOUR_CONFIG/ssl`目录：\n\n**这里需要注意的是，由于采用了Docker方式安装HA，没有权限访问/etc目录，所以，只能将证书复制到/PATH_TO_YOUR_CONFIG/ssl。**\n\n```bash\nmkdir /PATH_TO_YOUR_CONFIG/ssl\ncp fullchain.pem /PATH_TO_YOUR_CONFIG/ssl/\ncp privkey.pem /PATH_TO_YOUR_CONFIG/ssl/\n```\n\n修改配置文件`configuration.yaml`：\n\n```YAML\nhttp:                                                                       \n\tssl_certificate: ./ssl/fullchain.pem                                     \n\tssl_key: ./ssl/privkey.pem  \n```\n\n## 将Home Assistant发布到公网\n\n由于本地网络没有公网IP地址，因此通过SSH Tunnel的方式，将Home Assistant网关映射到远端网络，并发布到公网上。\n\n在HA网关上运行以下命令，该命令会将本地的8123端口映射到远端树莓派的10000端口。\n\n```Shell\nautossh -f -M 0 -NR 0.0.0.0:10000:localhost:8123 pi@ivpn.asuscomm.com -p 30100\n```\n\n然后，创建计划任务，每次HA网关重启后，会自动执行以上命令。\n\n```Text\ncrontab -e\n@reboot autossh -f -M 0 -NR 0.0.0.0:10000:localhost:8123 pi@ivpn.asuscomm.com -p 30100 &\n```\n\n在远端路由器上，选择**外部网络(WAN) - 端口转发 - 自定义设置** ，添加端口转发的条目。\n\n```Text\n服务名称：Home-Assistant\n通信协议：TCP\n外部端口：10000\n内部端口：10000\n本地IP地址：192.168.100.100\n```\n\n## iOS如何安装根证书\n\n点击`rootCA.pem`文件，安装根证书。\n\n![](20211019_001515000_iOS.png)\n\n打开**设置**应用，找到**已下载描述文件**，点击**安装**，安装过程中需要输入手机密码。\n\n![](20211019_001547000_iOS.png)\n\n安装完成后，需要在**设置 - 通用 - 关于本机 - 证书信任设置**中，启用安装的根证书。\n\n![](20211019_001714000_iOS.png)\n\n## Android如何安装根证书\n\n重新命名`rootCA.pem`文件为`rootCA.crt`。\n\n```\nrename rootCA.pem rootCA.crt\n```\n\n在Android设备上点击安装`rootCA.crt`文件。\n\n## Mac如何安装根证书\n\n打开终端工具，输入以下命令：\n\n```Shell\nCERT=\"/path/to/my/cert/my-root.crt\"\nsudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain $CERT\n```\n\n","slug":"Home_Assistant/Home_Assistant_HTTPS","published":1,"updated":"2024-02-01T06:12:23.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls2tw2ad0000arecesey6xe6","content":"<p>默认情况下，Home Assistant安装完成后，使用HTTP访问。如果在内网使用，HTTP相对还比较安全。但是，为了能让手机在外网访问HA网关，需要将其发布到外网（Internet）。因此，首先必须要配置HTTPS，确保数据传输的安全性。</p>\n<p>为了节约成本，可以使用自签的SSL证书。或者，也可以选用官方推荐的免费TLS&#x2F;SSL证书服务：<a href=\"https://www.home-assistant.io/docs/ecosystem/certificates/lets_encrypt/\">Let’s Encrypt</a>和<a href=\"https://www.home-assistant.io/integrations/duckdns/\">Duck DNS integrating Let’s Encrypt</a>。</p>\n<h2 id=\"制作自签的证书\"><a href=\"#制作自签的证书\" class=\"headerlink\" title=\"制作自签的证书\"></a>制作自签的证书</h2><p>证书的制作过程都是在树莓派上使用<code>openssl</code>完成。</p>\n<p>首先创建目录<code>certs</code>，并进入该目录：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir certs</span><br><span class=\"line\">cd certs</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"制作根证书\"><a href=\"#制作根证书\" class=\"headerlink\" title=\"制作根证书\"></a>制作根证书</h3><p>首先，需要创建根证书密钥，该密钥用于为证书签名。安全起见，该密钥不能泄露给其他人：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl genrsa -des3 -out rootCA.key 4096</span><br></pre></td></tr></table></figure>\n\n<p><strong>该命令生成的Key默认使用密码保护，如果要取消密码保护，只需要移除选项-des3。</strong></p>\n<p>然后用根证书密钥制作根证书：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 3650 -out rootCA.pem</span><br></pre></td></tr></table></figure>\n\n<p>如果需要使用苹果设备**macOS vs 10.15 &#x2F; iOS 13 (or above)**，请使用以下命令制作根证书，区别是根证书的有效期只有 825 天：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 825 -out rootCA.pem</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"制作服务器证书\"><a href=\"#制作服务器证书\" class=\"headerlink\" title=\"制作服务器证书\"></a>制作服务器证书</h3><p>请根据以下步骤，制作Home Assistant服务器的证书。</p>\n<p>创建<code>rootCA.csr.cnf</code>文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">touch rootCA.csr.cnf</span><br><span class=\"line\">vi rootCA.csr.cnf</span><br></pre></td></tr></table></figure>\n\n<p>将以下内容复制-粘贴到文件<code>rootCA.csr.cnf</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># rootCA.csr.cnf</span><br><span class=\"line\">[req]</span><br><span class=\"line\">default_bits = 2048</span><br><span class=\"line\">prompt = no</span><br><span class=\"line\">default_md = sha256</span><br><span class=\"line\">distinguished_name = dn</span><br><span class=\"line\">             </span><br><span class=\"line\">[dn]</span><br><span class=\"line\">C=CN</span><br><span class=\"line\">ST=Shanghai</span><br><span class=\"line\">L=Shanghai</span><br><span class=\"line\">O=HA</span><br><span class=\"line\">OU=HAU</span><br><span class=\"line\">emailAddress=admin@ha.com</span><br><span class=\"line\">CN = ivpn.asuscomm.com   </span><br></pre></td></tr></table></figure>\n\n<p>创建<code>v3.ext</code>文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">touch v3.ext</span><br><span class=\"line\">vi v3.ext</span><br></pre></td></tr></table></figure>\n\n<p>将以下内容复制-粘贴到文件<code>v3.ext</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># v3.ext</span><br><span class=\"line\">authorityKeyIdentifier=keyid,issuer</span><br><span class=\"line\">basicConstraints=CA:FALSE</span><br><span class=\"line\">keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span><br><span class=\"line\">subjectAltName = @alt_names</span><br><span class=\"line\">extendedKeyUsage=serverAuth</span><br><span class=\"line\">                </span><br><span class=\"line\">[alt_names]</span><br><span class=\"line\">DNS.1 = ivpn.asuscomm.com</span><br><span class=\"line\">IP.1 = 192.168.1.65</span><br></pre></td></tr></table></figure>\n\n<p>创建证书密钥<code>hassio.csr</code>:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl req -new -sha256 -nodes -out hassio.csr -newkey rsa:2048 -keyout hassio.key -config &lt;( <span class=\"built_in\">cat</span> rootCA.csr.cnf )</span><br></pre></td></tr></table></figure>\n\n<p>如果在Windows平台上运行该命令，需要注意-config参数后面rootCA.csr.cnf文件的路径地址。请参考以下例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl req -new -sha256 -nodes -out hassio.csr -newkey rsa:2048 -keyout hassio.key -config <span class=\"string\">&quot;C:\\Program Files\\Git\\usr\\bin\\rootCA.csr.cnf&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>创建证书<code>hassio.csr</code>:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl x509 -req -<span class=\"keyword\">in</span> hassio.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out hassio.crt -days 3650 -sha256 -extfile v3.ext</span><br></pre></td></tr></table></figure>\n\n<p>如果需要使用苹果设备**macOS vs 10.15 &#x2F; iOS 13 (or above)**，请使用以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl x509 -req -<span class=\"keyword\">in</span> hassio.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out hassio.crt -days 825 -sha256 -extfile v3.ext</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置Home-Assistant\"><a href=\"#配置Home-Assistant\" class=\"headerlink\" title=\"配置Home Assistant\"></a>配置Home Assistant</h2><p>将服务器证书和私钥重新命名为.pem格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">rename hassio.crt fullchain.pem</span><br><span class=\"line\">rename hassio.key privkey.pem</span><br></pre></td></tr></table></figure>\n\n<p>将证书复制到<code>/PATH_TO_YOUR_CONFIG/ssl</code>目录：</p>\n<p><strong>这里需要注意的是，由于采用了Docker方式安装HA，没有权限访问&#x2F;etc目录，所以，只能将证书复制到&#x2F;PATH_TO_YOUR_CONFIG&#x2F;ssl。</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> /PATH_TO_YOUR_CONFIG/ssl</span><br><span class=\"line\"><span class=\"built_in\">cp</span> fullchain.pem /PATH_TO_YOUR_CONFIG/ssl/</span><br><span class=\"line\"><span class=\"built_in\">cp</span> privkey.pem /PATH_TO_YOUR_CONFIG/ssl/</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件<code>configuration.yaml</code>：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">http:</span>                                                                       </span><br><span class=\"line\">\t<span class=\"attr\">ssl_certificate:</span> <span class=\"string\">./ssl/fullchain.pem</span>                                     </span><br><span class=\"line\">\t<span class=\"attr\">ssl_key:</span> <span class=\"string\">./ssl/privkey.pem</span>  </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"将Home-Assistant发布到公网\"><a href=\"#将Home-Assistant发布到公网\" class=\"headerlink\" title=\"将Home Assistant发布到公网\"></a>将Home Assistant发布到公网</h2><p>由于本地网络没有公网IP地址，因此通过SSH Tunnel的方式，将Home Assistant网关映射到远端网络，并发布到公网上。</p>\n<p>在HA网关上运行以下命令，该命令会将本地的8123端口映射到远端树莓派的10000端口。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">autossh -f -M 0 -NR 0.0.0.0:10000:localhost:8123 pi@ivpn.asuscomm.com -p 30100</span><br></pre></td></tr></table></figure>\n\n<p>然后，创建计划任务，每次HA网关重启后，会自动执行以上命令。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">crontab -e</span><br><span class=\"line\">@reboot autossh -f -M 0 -NR 0.0.0.0:10000:localhost:8123 pi@ivpn.asuscomm.com -p 30100 &amp;</span><br></pre></td></tr></table></figure>\n\n<p>在远端路由器上，选择<strong>外部网络(WAN) - 端口转发 - 自定义设置</strong> ，添加端口转发的条目。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">服务名称：Home-Assistant</span><br><span class=\"line\">通信协议：TCP</span><br><span class=\"line\">外部端口：10000</span><br><span class=\"line\">内部端口：10000</span><br><span class=\"line\">本地IP地址：192.168.100.100</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"iOS如何安装根证书\"><a href=\"#iOS如何安装根证书\" class=\"headerlink\" title=\"iOS如何安装根证书\"></a>iOS如何安装根证书</h2><p>点击<code>rootCA.pem</code>文件，安装根证书。</p>\n<p><img src=\"/2021/10/19/home-assistant/home-assistant-https/20211019_001515000_iOS.png\"></p>\n<p>打开<strong>设置</strong>应用，找到<strong>已下载描述文件</strong>，点击<strong>安装</strong>，安装过程中需要输入手机密码。</p>\n<p><img src=\"/2021/10/19/home-assistant/home-assistant-https/20211019_001547000_iOS.png\"></p>\n<p>安装完成后，需要在<strong>设置 - 通用 - 关于本机 - 证书信任设置</strong>中，启用安装的根证书。</p>\n<p><img src=\"/2021/10/19/home-assistant/home-assistant-https/20211019_001714000_iOS.png\"></p>\n<h2 id=\"Android如何安装根证书\"><a href=\"#Android如何安装根证书\" class=\"headerlink\" title=\"Android如何安装根证书\"></a>Android如何安装根证书</h2><p>重新命名<code>rootCA.pem</code>文件为<code>rootCA.crt</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">rename rootCA.pem rootCA.crt</span><br></pre></td></tr></table></figure>\n\n<p>在Android设备上点击安装<code>rootCA.crt</code>文件。</p>\n<h2 id=\"Mac如何安装根证书\"><a href=\"#Mac如何安装根证书\" class=\"headerlink\" title=\"Mac如何安装根证书\"></a>Mac如何安装根证书</h2><p>打开终端工具，输入以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">CERT=&quot;/path/to/my/cert/my-root.crt&quot;</span><br><span class=\"line\">sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain $CERT</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>默认情况下，Home Assistant安装完成后，使用HTTP访问。如果在内网使用，HTTP相对还比较安全。但是，为了能让手机在外网访问HA网关，需要将其发布到外网（Internet）。因此，首先必须要配置HTTPS，确保数据传输的安全性。</p>\n<p>为了节约成本，可以使用自签的SSL证书。或者，也可以选用官方推荐的免费TLS&#x2F;SSL证书服务：<a href=\"https://www.home-assistant.io/docs/ecosystem/certificates/lets_encrypt/\">Let’s Encrypt</a>和<a href=\"https://www.home-assistant.io/integrations/duckdns/\">Duck DNS integrating Let’s Encrypt</a>。</p>\n<h2 id=\"制作自签的证书\"><a href=\"#制作自签的证书\" class=\"headerlink\" title=\"制作自签的证书\"></a>制作自签的证书</h2><p>证书的制作过程都是在树莓派上使用<code>openssl</code>完成。</p>\n<p>首先创建目录<code>certs</code>，并进入该目录：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir certs</span><br><span class=\"line\">cd certs</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"制作根证书\"><a href=\"#制作根证书\" class=\"headerlink\" title=\"制作根证书\"></a>制作根证书</h3><p>首先，需要创建根证书密钥，该密钥用于为证书签名。安全起见，该密钥不能泄露给其他人：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl genrsa -des3 -out rootCA.key 4096</span><br></pre></td></tr></table></figure>\n\n<p><strong>该命令生成的Key默认使用密码保护，如果要取消密码保护，只需要移除选项-des3。</strong></p>\n<p>然后用根证书密钥制作根证书：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 3650 -out rootCA.pem</span><br></pre></td></tr></table></figure>\n\n<p>如果需要使用苹果设备**macOS vs 10.15 &#x2F; iOS 13 (or above)**，请使用以下命令制作根证书，区别是根证书的有效期只有 825 天：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 825 -out rootCA.pem</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"制作服务器证书\"><a href=\"#制作服务器证书\" class=\"headerlink\" title=\"制作服务器证书\"></a>制作服务器证书</h3><p>请根据以下步骤，制作Home Assistant服务器的证书。</p>\n<p>创建<code>rootCA.csr.cnf</code>文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">touch rootCA.csr.cnf</span><br><span class=\"line\">vi rootCA.csr.cnf</span><br></pre></td></tr></table></figure>\n\n<p>将以下内容复制-粘贴到文件<code>rootCA.csr.cnf</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># rootCA.csr.cnf</span><br><span class=\"line\">[req]</span><br><span class=\"line\">default_bits = 2048</span><br><span class=\"line\">prompt = no</span><br><span class=\"line\">default_md = sha256</span><br><span class=\"line\">distinguished_name = dn</span><br><span class=\"line\">             </span><br><span class=\"line\">[dn]</span><br><span class=\"line\">C=CN</span><br><span class=\"line\">ST=Shanghai</span><br><span class=\"line\">L=Shanghai</span><br><span class=\"line\">O=HA</span><br><span class=\"line\">OU=HAU</span><br><span class=\"line\">emailAddress=admin@ha.com</span><br><span class=\"line\">CN = ivpn.asuscomm.com   </span><br></pre></td></tr></table></figure>\n\n<p>创建<code>v3.ext</code>文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">touch v3.ext</span><br><span class=\"line\">vi v3.ext</span><br></pre></td></tr></table></figure>\n\n<p>将以下内容复制-粘贴到文件<code>v3.ext</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># v3.ext</span><br><span class=\"line\">authorityKeyIdentifier=keyid,issuer</span><br><span class=\"line\">basicConstraints=CA:FALSE</span><br><span class=\"line\">keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span><br><span class=\"line\">subjectAltName = @alt_names</span><br><span class=\"line\">extendedKeyUsage=serverAuth</span><br><span class=\"line\">                </span><br><span class=\"line\">[alt_names]</span><br><span class=\"line\">DNS.1 = ivpn.asuscomm.com</span><br><span class=\"line\">IP.1 = 192.168.1.65</span><br></pre></td></tr></table></figure>\n\n<p>创建证书密钥<code>hassio.csr</code>:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl req -new -sha256 -nodes -out hassio.csr -newkey rsa:2048 -keyout hassio.key -config &lt;( <span class=\"built_in\">cat</span> rootCA.csr.cnf )</span><br></pre></td></tr></table></figure>\n\n<p>如果在Windows平台上运行该命令，需要注意-config参数后面rootCA.csr.cnf文件的路径地址。请参考以下例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl req -new -sha256 -nodes -out hassio.csr -newkey rsa:2048 -keyout hassio.key -config <span class=\"string\">&quot;C:\\Program Files\\Git\\usr\\bin\\rootCA.csr.cnf&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>创建证书<code>hassio.csr</code>:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl x509 -req -<span class=\"keyword\">in</span> hassio.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out hassio.crt -days 3650 -sha256 -extfile v3.ext</span><br></pre></td></tr></table></figure>\n\n<p>如果需要使用苹果设备**macOS vs 10.15 &#x2F; iOS 13 (or above)**，请使用以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl x509 -req -<span class=\"keyword\">in</span> hassio.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out hassio.crt -days 825 -sha256 -extfile v3.ext</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置Home-Assistant\"><a href=\"#配置Home-Assistant\" class=\"headerlink\" title=\"配置Home Assistant\"></a>配置Home Assistant</h2><p>将服务器证书和私钥重新命名为.pem格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">rename hassio.crt fullchain.pem</span><br><span class=\"line\">rename hassio.key privkey.pem</span><br></pre></td></tr></table></figure>\n\n<p>将证书复制到<code>/PATH_TO_YOUR_CONFIG/ssl</code>目录：</p>\n<p><strong>这里需要注意的是，由于采用了Docker方式安装HA，没有权限访问&#x2F;etc目录，所以，只能将证书复制到&#x2F;PATH_TO_YOUR_CONFIG&#x2F;ssl。</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> /PATH_TO_YOUR_CONFIG/ssl</span><br><span class=\"line\"><span class=\"built_in\">cp</span> fullchain.pem /PATH_TO_YOUR_CONFIG/ssl/</span><br><span class=\"line\"><span class=\"built_in\">cp</span> privkey.pem /PATH_TO_YOUR_CONFIG/ssl/</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件<code>configuration.yaml</code>：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">http:</span>                                                                       </span><br><span class=\"line\">\t<span class=\"attr\">ssl_certificate:</span> <span class=\"string\">./ssl/fullchain.pem</span>                                     </span><br><span class=\"line\">\t<span class=\"attr\">ssl_key:</span> <span class=\"string\">./ssl/privkey.pem</span>  </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"将Home-Assistant发布到公网\"><a href=\"#将Home-Assistant发布到公网\" class=\"headerlink\" title=\"将Home Assistant发布到公网\"></a>将Home Assistant发布到公网</h2><p>由于本地网络没有公网IP地址，因此通过SSH Tunnel的方式，将Home Assistant网关映射到远端网络，并发布到公网上。</p>\n<p>在HA网关上运行以下命令，该命令会将本地的8123端口映射到远端树莓派的10000端口。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">autossh -f -M 0 -NR 0.0.0.0:10000:localhost:8123 pi@ivpn.asuscomm.com -p 30100</span><br></pre></td></tr></table></figure>\n\n<p>然后，创建计划任务，每次HA网关重启后，会自动执行以上命令。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">crontab -e</span><br><span class=\"line\">@reboot autossh -f -M 0 -NR 0.0.0.0:10000:localhost:8123 pi@ivpn.asuscomm.com -p 30100 &amp;</span><br></pre></td></tr></table></figure>\n\n<p>在远端路由器上，选择<strong>外部网络(WAN) - 端口转发 - 自定义设置</strong> ，添加端口转发的条目。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">服务名称：Home-Assistant</span><br><span class=\"line\">通信协议：TCP</span><br><span class=\"line\">外部端口：10000</span><br><span class=\"line\">内部端口：10000</span><br><span class=\"line\">本地IP地址：192.168.100.100</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"iOS如何安装根证书\"><a href=\"#iOS如何安装根证书\" class=\"headerlink\" title=\"iOS如何安装根证书\"></a>iOS如何安装根证书</h2><p>点击<code>rootCA.pem</code>文件，安装根证书。</p>\n<p><img src=\"/2021/10/19/home-assistant/home-assistant-https/20211019_001515000_iOS.png\"></p>\n<p>打开<strong>设置</strong>应用，找到<strong>已下载描述文件</strong>，点击<strong>安装</strong>，安装过程中需要输入手机密码。</p>\n<p><img src=\"/2021/10/19/home-assistant/home-assistant-https/20211019_001547000_iOS.png\"></p>\n<p>安装完成后，需要在<strong>设置 - 通用 - 关于本机 - 证书信任设置</strong>中，启用安装的根证书。</p>\n<p><img src=\"/2021/10/19/home-assistant/home-assistant-https/20211019_001714000_iOS.png\"></p>\n<h2 id=\"Android如何安装根证书\"><a href=\"#Android如何安装根证书\" class=\"headerlink\" title=\"Android如何安装根证书\"></a>Android如何安装根证书</h2><p>重新命名<code>rootCA.pem</code>文件为<code>rootCA.crt</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">rename rootCA.pem rootCA.crt</span><br></pre></td></tr></table></figure>\n\n<p>在Android设备上点击安装<code>rootCA.crt</code>文件。</p>\n<h2 id=\"Mac如何安装根证书\"><a href=\"#Mac如何安装根证书\" class=\"headerlink\" title=\"Mac如何安装根证书\"></a>Mac如何安装根证书</h2><p>打开终端工具，输入以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">CERT=&quot;/path/to/my/cert/my-root.crt&quot;</span><br><span class=\"line\">sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain $CERT</span><br></pre></td></tr></table></figure>\n\n"},{"title":"安装Home Assistant容器","date":"2021-10-17T07:02:00.000Z","updated":"2024-09-02T01:35:00.000Z","_content":"\n## 安装Docker\n\n1 更新树莓派的系统。\n\n```bash\nsudo apt-get update\nsudo apt-get upgrade\n```\n\n2 下载Docker安装脚本，然后执行脚本安装Docker。\n\n```bash\ncurl -fsSL https://get.docker.com -o get-docker.sh\nsudo sh get-docker.sh --mirror Aliyun\n```\n\n**需要注意的是，由于国内访问Docker官方的安装源很慢，因此可以添加参数`--mirror Aliyun`，将安装源更改为阿里云镜像，从而提高安装速度。**\n\n<!-- more -->\n\n3 默认情况下，只有拥有管理员权限的账号才可以运行docker，如果登录的账号是普通用户，需要通过sudo来运行docker。或者，也可以将普通用户账号添加到docker用户组，这样该用户就可以直接运行docker的命令。\n\n以下命令可以将用户`pi`添加到docker用户组中。\n\n```bash\nsudo usermod -aG docker pi\n```\n\n\n4 使用命令`docker version`和`docker info`查看Docker的版本信息和运行状态。\n\n```bash\n$ docker version\n\nClient:\n Version:           20.10.5+dfsg1\n API version:       1.41\n Go version:        go1.15.15\n Git commit:        55c4c88\n Built:             Mon May 30 18:34:49 2022\n OS/Arch:           linux/arm64\n Context:           default\n Experimental:      true\n\nServer:\n Engine:\n  Version:          20.10.5+dfsg1\n  API version:      1.41 (minimum version 1.12)\n  Go version:       go1.15.15\n  Git commit:       363e9a8\n  Built:            Mon May 30 18:34:49 2022\n  OS/Arch:          linux/arm64\n  Experimental:     false\n containerd:\n  Version:          1.4.13~ds1\n  GitCommit:        1.4.13~ds1-1~deb11u4\n runc:\n  Version:          1.0.0~rc93+ds1\n  GitCommit:        1.0.0~rc93+ds1-5+deb11u2\n docker-init:\n  Version:          0.19.0\n  GitCommit:\n\ndocker info\n```\n\n```bash\n$ docker info\n\nClient:\n Context:    default\n Debug Mode: false\n Plugins:\n  buildx: Docker Buildx (Docker Inc., v0.10.4)\n  compose: Docker Compose (Docker Inc., v2.17.3)\n\nServer:\n Containers: 1\n  Running: 1\n  Paused: 0\n  Stopped: 0\n Images: 1\n Server Version: 20.10.5+dfsg1\n Storage Driver: overlay2\n  Backing Filesystem: extfs\n  Supports d_type: true\n  Native Overlay Diff: true\n Logging Driver: json-file\n Cgroup Driver: systemd\n Cgroup Version: 2\n Plugins:\n  Volume: local\n  Network: bridge host ipvlan macvlan null overlay\n  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog\n Swarm: inactive\n Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc\n Default Runtime: runc\n Init Binary: docker-init\n containerd version: 1.4.13~ds1-1~deb11u4\n runc version: 1.0.0~rc93+ds1-5+deb11u2\n init version:\n Security Options:\n  seccomp\n   Profile: default\n  cgroupns\n Kernel Version: 6.1.21-v8+\n Operating System: Debian GNU/Linux 11 (bullseye)\n OSType: linux\n Architecture: aarch64\n CPUs: 4\n Total Memory: 7.629GiB\n Name: pi4-8g\n ID: AT4S:WDKG:SCHA:D56T:SRNU:TJJB:ZEMH:YR67:6GRF:KLVC:B6MI:SVIE\n Docker Root Dir: /var/lib/docker\n Debug Mode: false\n Registry: https://index.docker.io/v1/\n Labels:\n Experimental: false\n Insecure Registries:\n  127.0.0.0/8\n Registry Mirrors:\n  https://docker.mirrors.ustc.edu.cn/\n Live Restore Enabled: false\n\nWARNING: No memory limit support\nWARNING: No swap limit support\nWARNING: Support for cgroup v2 is experimental\n```\n\n## 安装Home Assistant\n\n通过Docker方式安装Home Assistant，不支持[add-ons](https://www.home-assistant.io/addons)（add-ons是指通过安装第三方的应用程序来扩展Home Assistant的功能），并且无法从管理界面中更新Home Assistant的版本。\n\n### 先决条件\n\n- Docker至少是19.03.9或者以上版本\n- `libseccomp`的版本至少是 2.4.2或者以上\n\n### Raspberry pi 3\n\n```bash\ndocker run -d \\\n  --name homeassistant \\\n  --privileged \\\n  --restart=unless-stopped \\\n  -e TZ=MY_TIME_ZONE \\\n  -v /PATH_TO_YOUR_CONFIG:/config \\\n  --network=host \\\n  ghcr.io/home-assistant/raspberrypi3-homeassistant:stable\n```\n\n### Raspberry pi 4\n\n```bash\ndocker run -d \\\n  --name homeassistant \\\n  --privileged \\\n  --restart=unless-stopped \\\n  -e TZ=MY_TIME_ZONE \\\n  -v /PATH_TO_YOUR_CONFIG:/config \\\n  -v /run/dbus:/run/dbus:ro \\\n  --network=host \\\n  ghcr.io/home-assistant/raspberrypi4-homeassistant:stable\n```\n\n以上安装命令中，一定要将`/PATH_TO_YOUR_CONFIG`修改成指定的安装路径，例如`/home/pi/homeassistant`，如果忘记修改，配置文件就会保存到`/PATH_TO_YOUR_CONFIG`目录。\n\n更改`MY_TIME_ZONE`为本地时区，例如`Asia/Shanghai`。\n\n如果要使用[Bluetooth integration](https://www.home-assistant.io/integrations/bluetooth), 需要设置`D-Bus`，即`-v /run/dbus:/run/dbus:ro`\n\n安装成功后，打开浏览器访问`http://<host>:8123`，登录Home Assistant的Web界面。\n\n## 更新Home Assistant\n\n下载最新版本的Home Assistant，如果命令结果返回\"Image is up to date\"，则说明目前已经是最新版本。\n\n```bash\ndocker pull ghcr.io/home-assistant/home-assistant:stable\n```\n\n停止运行Home Assistant容器。\n\n```bash\ndocker stop homeassistant\n```\n\n删除Home Assistant容器，**该操作不会删除原有的配置文件**。\n\n```bash\ndocker rm homeassistant\n```\n\n运行最新版本的Home Assistant，将`PATH_TO_YOUR_CONFIG`设置为原配置文件所在的路径，例如`/home/pi/homeassistant`。\n\n```bash\ndocker run -d \\\n\t--name homeassistant \\\n\t--restart=unless-stopped \\ \n\t--privileged \\ \n\t-e TZ=MY_TIME_ZONE \\ \n\t-v /PATH_TO_YOUR_CONFIG:/config \\ \n\t-v /run/dbus:/run/dbus:ro \\ \n\t--network=host \\ \n\tghcr.io/home-assistant/home-assistant:stable\n```","source":"_posts/Home_Assistant/安装Home_Assistant容器.md","raw":"---\ntitle: 安装Home Assistant容器\ndate: 2021-10-17 15:02:00\ntags:\n  - home_assistant\ncategories:\n  - Home_Assistant\nupdated: 2024-9-02 09:35:00\n---\n\n## 安装Docker\n\n1 更新树莓派的系统。\n\n```bash\nsudo apt-get update\nsudo apt-get upgrade\n```\n\n2 下载Docker安装脚本，然后执行脚本安装Docker。\n\n```bash\ncurl -fsSL https://get.docker.com -o get-docker.sh\nsudo sh get-docker.sh --mirror Aliyun\n```\n\n**需要注意的是，由于国内访问Docker官方的安装源很慢，因此可以添加参数`--mirror Aliyun`，将安装源更改为阿里云镜像，从而提高安装速度。**\n\n<!-- more -->\n\n3 默认情况下，只有拥有管理员权限的账号才可以运行docker，如果登录的账号是普通用户，需要通过sudo来运行docker。或者，也可以将普通用户账号添加到docker用户组，这样该用户就可以直接运行docker的命令。\n\n以下命令可以将用户`pi`添加到docker用户组中。\n\n```bash\nsudo usermod -aG docker pi\n```\n\n\n4 使用命令`docker version`和`docker info`查看Docker的版本信息和运行状态。\n\n```bash\n$ docker version\n\nClient:\n Version:           20.10.5+dfsg1\n API version:       1.41\n Go version:        go1.15.15\n Git commit:        55c4c88\n Built:             Mon May 30 18:34:49 2022\n OS/Arch:           linux/arm64\n Context:           default\n Experimental:      true\n\nServer:\n Engine:\n  Version:          20.10.5+dfsg1\n  API version:      1.41 (minimum version 1.12)\n  Go version:       go1.15.15\n  Git commit:       363e9a8\n  Built:            Mon May 30 18:34:49 2022\n  OS/Arch:          linux/arm64\n  Experimental:     false\n containerd:\n  Version:          1.4.13~ds1\n  GitCommit:        1.4.13~ds1-1~deb11u4\n runc:\n  Version:          1.0.0~rc93+ds1\n  GitCommit:        1.0.0~rc93+ds1-5+deb11u2\n docker-init:\n  Version:          0.19.0\n  GitCommit:\n\ndocker info\n```\n\n```bash\n$ docker info\n\nClient:\n Context:    default\n Debug Mode: false\n Plugins:\n  buildx: Docker Buildx (Docker Inc., v0.10.4)\n  compose: Docker Compose (Docker Inc., v2.17.3)\n\nServer:\n Containers: 1\n  Running: 1\n  Paused: 0\n  Stopped: 0\n Images: 1\n Server Version: 20.10.5+dfsg1\n Storage Driver: overlay2\n  Backing Filesystem: extfs\n  Supports d_type: true\n  Native Overlay Diff: true\n Logging Driver: json-file\n Cgroup Driver: systemd\n Cgroup Version: 2\n Plugins:\n  Volume: local\n  Network: bridge host ipvlan macvlan null overlay\n  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog\n Swarm: inactive\n Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc\n Default Runtime: runc\n Init Binary: docker-init\n containerd version: 1.4.13~ds1-1~deb11u4\n runc version: 1.0.0~rc93+ds1-5+deb11u2\n init version:\n Security Options:\n  seccomp\n   Profile: default\n  cgroupns\n Kernel Version: 6.1.21-v8+\n Operating System: Debian GNU/Linux 11 (bullseye)\n OSType: linux\n Architecture: aarch64\n CPUs: 4\n Total Memory: 7.629GiB\n Name: pi4-8g\n ID: AT4S:WDKG:SCHA:D56T:SRNU:TJJB:ZEMH:YR67:6GRF:KLVC:B6MI:SVIE\n Docker Root Dir: /var/lib/docker\n Debug Mode: false\n Registry: https://index.docker.io/v1/\n Labels:\n Experimental: false\n Insecure Registries:\n  127.0.0.0/8\n Registry Mirrors:\n  https://docker.mirrors.ustc.edu.cn/\n Live Restore Enabled: false\n\nWARNING: No memory limit support\nWARNING: No swap limit support\nWARNING: Support for cgroup v2 is experimental\n```\n\n## 安装Home Assistant\n\n通过Docker方式安装Home Assistant，不支持[add-ons](https://www.home-assistant.io/addons)（add-ons是指通过安装第三方的应用程序来扩展Home Assistant的功能），并且无法从管理界面中更新Home Assistant的版本。\n\n### 先决条件\n\n- Docker至少是19.03.9或者以上版本\n- `libseccomp`的版本至少是 2.4.2或者以上\n\n### Raspberry pi 3\n\n```bash\ndocker run -d \\\n  --name homeassistant \\\n  --privileged \\\n  --restart=unless-stopped \\\n  -e TZ=MY_TIME_ZONE \\\n  -v /PATH_TO_YOUR_CONFIG:/config \\\n  --network=host \\\n  ghcr.io/home-assistant/raspberrypi3-homeassistant:stable\n```\n\n### Raspberry pi 4\n\n```bash\ndocker run -d \\\n  --name homeassistant \\\n  --privileged \\\n  --restart=unless-stopped \\\n  -e TZ=MY_TIME_ZONE \\\n  -v /PATH_TO_YOUR_CONFIG:/config \\\n  -v /run/dbus:/run/dbus:ro \\\n  --network=host \\\n  ghcr.io/home-assistant/raspberrypi4-homeassistant:stable\n```\n\n以上安装命令中，一定要将`/PATH_TO_YOUR_CONFIG`修改成指定的安装路径，例如`/home/pi/homeassistant`，如果忘记修改，配置文件就会保存到`/PATH_TO_YOUR_CONFIG`目录。\n\n更改`MY_TIME_ZONE`为本地时区，例如`Asia/Shanghai`。\n\n如果要使用[Bluetooth integration](https://www.home-assistant.io/integrations/bluetooth), 需要设置`D-Bus`，即`-v /run/dbus:/run/dbus:ro`\n\n安装成功后，打开浏览器访问`http://<host>:8123`，登录Home Assistant的Web界面。\n\n## 更新Home Assistant\n\n下载最新版本的Home Assistant，如果命令结果返回\"Image is up to date\"，则说明目前已经是最新版本。\n\n```bash\ndocker pull ghcr.io/home-assistant/home-assistant:stable\n```\n\n停止运行Home Assistant容器。\n\n```bash\ndocker stop homeassistant\n```\n\n删除Home Assistant容器，**该操作不会删除原有的配置文件**。\n\n```bash\ndocker rm homeassistant\n```\n\n运行最新版本的Home Assistant，将`PATH_TO_YOUR_CONFIG`设置为原配置文件所在的路径，例如`/home/pi/homeassistant`。\n\n```bash\ndocker run -d \\\n\t--name homeassistant \\\n\t--restart=unless-stopped \\ \n\t--privileged \\ \n\t-e TZ=MY_TIME_ZONE \\ \n\t-v /PATH_TO_YOUR_CONFIG:/config \\ \n\t-v /run/dbus:/run/dbus:ro \\ \n\t--network=host \\ \n\tghcr.io/home-assistant/home-assistant:stable\n```","slug":"Home_Assistant/安装Home_Assistant容器","published":1,"_id":"cm0ko1vvt0000m2ec2sxh79pu","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"安装Docker\"><a href=\"#安装Docker\" class=\"headerlink\" title=\"安装Docker\"></a>安装Docker</h2><p>1 更新树莓派的系统。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>\n\n<p>2 下载Docker安装脚本，然后执行脚本安装Docker。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class=\"line\">sudo sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure>\n\n<p><strong>需要注意的是，由于国内访问Docker官方的安装源很慢，因此可以添加参数<code>--mirror Aliyun</code>，将安装源更改为阿里云镜像，从而提高安装速度。</strong></p>\n<span id=\"more\"></span>\n\n<p>3 默认情况下，只有拥有管理员权限的账号才可以运行docker，如果登录的账号是普通用户，需要通过sudo来运行docker。或者，也可以将普通用户账号添加到docker用户组，这样该用户就可以直接运行docker的命令。</p>\n<p>以下命令可以将用户<code>pi</code>添加到docker用户组中。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo usermod -aG docker pi</span><br></pre></td></tr></table></figure>\n\n\n<p>4 使用命令<code>docker version</code>和<code>docker info</code>查看Docker的版本信息和运行状态。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker version</span><br><span class=\"line\"></span><br><span class=\"line\">Client:</span><br><span class=\"line\"> Version:           20.10.5+dfsg1</span><br><span class=\"line\"> API version:       1.41</span><br><span class=\"line\"> Go version:        go1.15.15</span><br><span class=\"line\"> Git commit:        55c4c88</span><br><span class=\"line\"> Built:             Mon May 30 18:34:49 2022</span><br><span class=\"line\"> OS/Arch:           linux/arm64</span><br><span class=\"line\"> Context:           default</span><br><span class=\"line\"> Experimental:      <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">Server:</span><br><span class=\"line\"> Engine:</span><br><span class=\"line\">  Version:          20.10.5+dfsg1</span><br><span class=\"line\">  API version:      1.41 (minimum version 1.12)</span><br><span class=\"line\">  Go version:       go1.15.15</span><br><span class=\"line\">  Git commit:       363e9a8</span><br><span class=\"line\">  Built:            Mon May 30 18:34:49 2022</span><br><span class=\"line\">  OS/Arch:          linux/arm64</span><br><span class=\"line\">  Experimental:     <span class=\"literal\">false</span></span><br><span class=\"line\"> containerd:</span><br><span class=\"line\">  Version:          1.4.13~ds1</span><br><span class=\"line\">  GitCommit:        1.4.13~ds1-1~deb11u4</span><br><span class=\"line\"> runc:</span><br><span class=\"line\">  Version:          1.0.0~rc93+ds1</span><br><span class=\"line\">  GitCommit:        1.0.0~rc93+ds1-5+deb11u2</span><br><span class=\"line\"> docker-init:</span><br><span class=\"line\">  Version:          0.19.0</span><br><span class=\"line\">  GitCommit:</span><br><span class=\"line\"></span><br><span class=\"line\">docker info</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker info</span><br><span class=\"line\"></span><br><span class=\"line\">Client:</span><br><span class=\"line\"> Context:    default</span><br><span class=\"line\"> Debug Mode: <span class=\"literal\">false</span></span><br><span class=\"line\"> Plugins:</span><br><span class=\"line\">  buildx: Docker Buildx (Docker Inc., v0.10.4)</span><br><span class=\"line\">  compose: Docker Compose (Docker Inc., v2.17.3)</span><br><span class=\"line\"></span><br><span class=\"line\">Server:</span><br><span class=\"line\"> Containers: 1</span><br><span class=\"line\">  Running: 1</span><br><span class=\"line\">  Paused: 0</span><br><span class=\"line\">  Stopped: 0</span><br><span class=\"line\"> Images: 1</span><br><span class=\"line\"> Server Version: 20.10.5+dfsg1</span><br><span class=\"line\"> Storage Driver: overlay2</span><br><span class=\"line\">  Backing Filesystem: extfs</span><br><span class=\"line\">  Supports d_type: <span class=\"literal\">true</span></span><br><span class=\"line\">  Native Overlay Diff: <span class=\"literal\">true</span></span><br><span class=\"line\"> Logging Driver: json-file</span><br><span class=\"line\"> Cgroup Driver: systemd</span><br><span class=\"line\"> Cgroup Version: 2</span><br><span class=\"line\"> Plugins:</span><br><span class=\"line\">  Volume: <span class=\"built_in\">local</span></span><br><span class=\"line\">  Network: bridge host ipvlan macvlan null overlay</span><br><span class=\"line\">  Log: awslogs fluentd gcplogs gelf journald json-file <span class=\"built_in\">local</span> logentries splunk syslog</span><br><span class=\"line\"> Swarm: inactive</span><br><span class=\"line\"> Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc</span><br><span class=\"line\"> Default Runtime: runc</span><br><span class=\"line\"> Init Binary: docker-init</span><br><span class=\"line\"> containerd version: 1.4.13~ds1-1~deb11u4</span><br><span class=\"line\"> runc version: 1.0.0~rc93+ds1-5+deb11u2</span><br><span class=\"line\"> init version:</span><br><span class=\"line\"> Security Options:</span><br><span class=\"line\">  seccomp</span><br><span class=\"line\">   Profile: default</span><br><span class=\"line\">  cgroupns</span><br><span class=\"line\"> Kernel Version: 6.1.21-v8+</span><br><span class=\"line\"> Operating System: Debian GNU/Linux 11 (bullseye)</span><br><span class=\"line\"> OSType: linux</span><br><span class=\"line\"> Architecture: aarch64</span><br><span class=\"line\"> CPUs: 4</span><br><span class=\"line\"> Total Memory: 7.629GiB</span><br><span class=\"line\"> Name: pi4-8g</span><br><span class=\"line\"> ID: AT4S:WDKG:SCHA:D56T:SRNU:TJJB:ZEMH:YR67:6GRF:KLVC:B6MI:SVIE</span><br><span class=\"line\"> Docker Root Dir: /var/lib/docker</span><br><span class=\"line\"> Debug Mode: <span class=\"literal\">false</span></span><br><span class=\"line\"> Registry: https://index.docker.io/v1/</span><br><span class=\"line\"> Labels:</span><br><span class=\"line\"> Experimental: <span class=\"literal\">false</span></span><br><span class=\"line\"> Insecure Registries:</span><br><span class=\"line\">  127.0.0.0/8</span><br><span class=\"line\"> Registry Mirrors:</span><br><span class=\"line\">  https://docker.mirrors.ustc.edu.cn/</span><br><span class=\"line\"> Live Restore Enabled: <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">WARNING: No memory <span class=\"built_in\">limit</span> support</span><br><span class=\"line\">WARNING: No swap <span class=\"built_in\">limit</span> support</span><br><span class=\"line\">WARNING: Support <span class=\"keyword\">for</span> cgroup v2 is experimental</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"安装Home-Assistant\"><a href=\"#安装Home-Assistant\" class=\"headerlink\" title=\"安装Home Assistant\"></a>安装Home Assistant</h2><p>通过Docker方式安装Home Assistant，不支持<a href=\"https://www.home-assistant.io/addons\">add-ons</a>（add-ons是指通过安装第三方的应用程序来扩展Home Assistant的功能），并且无法从管理界面中更新Home Assistant的版本。</p>\n<h3 id=\"先决条件\"><a href=\"#先决条件\" class=\"headerlink\" title=\"先决条件\"></a>先决条件</h3><ul>\n<li>Docker至少是19.03.9或者以上版本</li>\n<li><code>libseccomp</code>的版本至少是 2.4.2或者以上</li>\n</ul>\n<h3 id=\"Raspberry-pi-3\"><a href=\"#Raspberry-pi-3\" class=\"headerlink\" title=\"Raspberry pi 3\"></a>Raspberry pi 3</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">  --name homeassistant \\</span><br><span class=\"line\">  --privileged \\</span><br><span class=\"line\">  --restart=unless-stopped \\</span><br><span class=\"line\">  -e TZ=MY_TIME_ZONE \\</span><br><span class=\"line\">  -v /PATH_TO_YOUR_CONFIG:/config \\</span><br><span class=\"line\">  --network=host \\</span><br><span class=\"line\">  ghcr.io/home-assistant/raspberrypi3-homeassistant:stable</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Raspberry-pi-4\"><a href=\"#Raspberry-pi-4\" class=\"headerlink\" title=\"Raspberry pi 4\"></a>Raspberry pi 4</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">  --name homeassistant \\</span><br><span class=\"line\">  --privileged \\</span><br><span class=\"line\">  --restart=unless-stopped \\</span><br><span class=\"line\">  -e TZ=MY_TIME_ZONE \\</span><br><span class=\"line\">  -v /PATH_TO_YOUR_CONFIG:/config \\</span><br><span class=\"line\">  -v /run/dbus:/run/dbus:ro \\</span><br><span class=\"line\">  --network=host \\</span><br><span class=\"line\">  ghcr.io/home-assistant/raspberrypi4-homeassistant:stable</span><br></pre></td></tr></table></figure>\n\n<p>以上安装命令中，一定要将<code>/PATH_TO_YOUR_CONFIG</code>修改成指定的安装路径，例如<code>/home/pi/homeassistant</code>，如果忘记修改，配置文件就会保存到<code>/PATH_TO_YOUR_CONFIG</code>目录。</p>\n<p>更改<code>MY_TIME_ZONE</code>为本地时区，例如<code>Asia/Shanghai</code>。</p>\n<p>如果要使用<a href=\"https://www.home-assistant.io/integrations/bluetooth\">Bluetooth integration</a>, 需要设置<code>D-Bus</code>，即<code>-v /run/dbus:/run/dbus:ro</code></p>\n<p>安装成功后，打开浏览器访问<code>http://&lt;host&gt;:8123</code>，登录Home Assistant的Web界面。</p>\n<h2 id=\"更新Home-Assistant\"><a href=\"#更新Home-Assistant\" class=\"headerlink\" title=\"更新Home Assistant\"></a>更新Home Assistant</h2><p>下载最新版本的Home Assistant，如果命令结果返回”Image is up to date”，则说明目前已经是最新版本。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker pull ghcr.io/home-assistant/home-assistant:stable</span><br></pre></td></tr></table></figure>\n\n<p>停止运行Home Assistant容器。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker stop homeassistant</span><br></pre></td></tr></table></figure>\n\n<p>删除Home Assistant容器，<strong>该操作不会删除原有的配置文件</strong>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">rm</span> homeassistant</span><br></pre></td></tr></table></figure>\n\n<p>运行最新版本的Home Assistant，将<code>PATH_TO_YOUR_CONFIG</code>设置为原配置文件所在的路径，例如<code>/home/pi/homeassistant</code>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">\t--name homeassistant \\</span><br><span class=\"line\">\t--restart=unless-stopped \\ </span><br><span class=\"line\">\t--privileged \\ </span><br><span class=\"line\">\t-e TZ=MY_TIME_ZONE \\ </span><br><span class=\"line\">\t-v /PATH_TO_YOUR_CONFIG:/config \\ </span><br><span class=\"line\">\t-v /run/dbus:/run/dbus:ro \\ </span><br><span class=\"line\">\t--network=host \\ </span><br><span class=\"line\">\tghcr.io/home-assistant/home-assistant:stable</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"安装Docker\"><a href=\"#安装Docker\" class=\"headerlink\" title=\"安装Docker\"></a>安装Docker</h2><p>1 更新树莓派的系统。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>\n\n<p>2 下载Docker安装脚本，然后执行脚本安装Docker。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class=\"line\">sudo sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure>\n\n<p><strong>需要注意的是，由于国内访问Docker官方的安装源很慢，因此可以添加参数<code>--mirror Aliyun</code>，将安装源更改为阿里云镜像，从而提高安装速度。</strong></p>","more":"<p>3 默认情况下，只有拥有管理员权限的账号才可以运行docker，如果登录的账号是普通用户，需要通过sudo来运行docker。或者，也可以将普通用户账号添加到docker用户组，这样该用户就可以直接运行docker的命令。</p>\n<p>以下命令可以将用户<code>pi</code>添加到docker用户组中。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo usermod -aG docker pi</span><br></pre></td></tr></table></figure>\n\n\n<p>4 使用命令<code>docker version</code>和<code>docker info</code>查看Docker的版本信息和运行状态。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker version</span><br><span class=\"line\"></span><br><span class=\"line\">Client:</span><br><span class=\"line\"> Version:           20.10.5+dfsg1</span><br><span class=\"line\"> API version:       1.41</span><br><span class=\"line\"> Go version:        go1.15.15</span><br><span class=\"line\"> Git commit:        55c4c88</span><br><span class=\"line\"> Built:             Mon May 30 18:34:49 2022</span><br><span class=\"line\"> OS/Arch:           linux/arm64</span><br><span class=\"line\"> Context:           default</span><br><span class=\"line\"> Experimental:      <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">Server:</span><br><span class=\"line\"> Engine:</span><br><span class=\"line\">  Version:          20.10.5+dfsg1</span><br><span class=\"line\">  API version:      1.41 (minimum version 1.12)</span><br><span class=\"line\">  Go version:       go1.15.15</span><br><span class=\"line\">  Git commit:       363e9a8</span><br><span class=\"line\">  Built:            Mon May 30 18:34:49 2022</span><br><span class=\"line\">  OS/Arch:          linux/arm64</span><br><span class=\"line\">  Experimental:     <span class=\"literal\">false</span></span><br><span class=\"line\"> containerd:</span><br><span class=\"line\">  Version:          1.4.13~ds1</span><br><span class=\"line\">  GitCommit:        1.4.13~ds1-1~deb11u4</span><br><span class=\"line\"> runc:</span><br><span class=\"line\">  Version:          1.0.0~rc93+ds1</span><br><span class=\"line\">  GitCommit:        1.0.0~rc93+ds1-5+deb11u2</span><br><span class=\"line\"> docker-init:</span><br><span class=\"line\">  Version:          0.19.0</span><br><span class=\"line\">  GitCommit:</span><br><span class=\"line\"></span><br><span class=\"line\">docker info</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker info</span><br><span class=\"line\"></span><br><span class=\"line\">Client:</span><br><span class=\"line\"> Context:    default</span><br><span class=\"line\"> Debug Mode: <span class=\"literal\">false</span></span><br><span class=\"line\"> Plugins:</span><br><span class=\"line\">  buildx: Docker Buildx (Docker Inc., v0.10.4)</span><br><span class=\"line\">  compose: Docker Compose (Docker Inc., v2.17.3)</span><br><span class=\"line\"></span><br><span class=\"line\">Server:</span><br><span class=\"line\"> Containers: 1</span><br><span class=\"line\">  Running: 1</span><br><span class=\"line\">  Paused: 0</span><br><span class=\"line\">  Stopped: 0</span><br><span class=\"line\"> Images: 1</span><br><span class=\"line\"> Server Version: 20.10.5+dfsg1</span><br><span class=\"line\"> Storage Driver: overlay2</span><br><span class=\"line\">  Backing Filesystem: extfs</span><br><span class=\"line\">  Supports d_type: <span class=\"literal\">true</span></span><br><span class=\"line\">  Native Overlay Diff: <span class=\"literal\">true</span></span><br><span class=\"line\"> Logging Driver: json-file</span><br><span class=\"line\"> Cgroup Driver: systemd</span><br><span class=\"line\"> Cgroup Version: 2</span><br><span class=\"line\"> Plugins:</span><br><span class=\"line\">  Volume: <span class=\"built_in\">local</span></span><br><span class=\"line\">  Network: bridge host ipvlan macvlan null overlay</span><br><span class=\"line\">  Log: awslogs fluentd gcplogs gelf journald json-file <span class=\"built_in\">local</span> logentries splunk syslog</span><br><span class=\"line\"> Swarm: inactive</span><br><span class=\"line\"> Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc</span><br><span class=\"line\"> Default Runtime: runc</span><br><span class=\"line\"> Init Binary: docker-init</span><br><span class=\"line\"> containerd version: 1.4.13~ds1-1~deb11u4</span><br><span class=\"line\"> runc version: 1.0.0~rc93+ds1-5+deb11u2</span><br><span class=\"line\"> init version:</span><br><span class=\"line\"> Security Options:</span><br><span class=\"line\">  seccomp</span><br><span class=\"line\">   Profile: default</span><br><span class=\"line\">  cgroupns</span><br><span class=\"line\"> Kernel Version: 6.1.21-v8+</span><br><span class=\"line\"> Operating System: Debian GNU/Linux 11 (bullseye)</span><br><span class=\"line\"> OSType: linux</span><br><span class=\"line\"> Architecture: aarch64</span><br><span class=\"line\"> CPUs: 4</span><br><span class=\"line\"> Total Memory: 7.629GiB</span><br><span class=\"line\"> Name: pi4-8g</span><br><span class=\"line\"> ID: AT4S:WDKG:SCHA:D56T:SRNU:TJJB:ZEMH:YR67:6GRF:KLVC:B6MI:SVIE</span><br><span class=\"line\"> Docker Root Dir: /var/lib/docker</span><br><span class=\"line\"> Debug Mode: <span class=\"literal\">false</span></span><br><span class=\"line\"> Registry: https://index.docker.io/v1/</span><br><span class=\"line\"> Labels:</span><br><span class=\"line\"> Experimental: <span class=\"literal\">false</span></span><br><span class=\"line\"> Insecure Registries:</span><br><span class=\"line\">  127.0.0.0/8</span><br><span class=\"line\"> Registry Mirrors:</span><br><span class=\"line\">  https://docker.mirrors.ustc.edu.cn/</span><br><span class=\"line\"> Live Restore Enabled: <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">WARNING: No memory <span class=\"built_in\">limit</span> support</span><br><span class=\"line\">WARNING: No swap <span class=\"built_in\">limit</span> support</span><br><span class=\"line\">WARNING: Support <span class=\"keyword\">for</span> cgroup v2 is experimental</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"安装Home-Assistant\"><a href=\"#安装Home-Assistant\" class=\"headerlink\" title=\"安装Home Assistant\"></a>安装Home Assistant</h2><p>通过Docker方式安装Home Assistant，不支持<a href=\"https://www.home-assistant.io/addons\">add-ons</a>（add-ons是指通过安装第三方的应用程序来扩展Home Assistant的功能），并且无法从管理界面中更新Home Assistant的版本。</p>\n<h3 id=\"先决条件\"><a href=\"#先决条件\" class=\"headerlink\" title=\"先决条件\"></a>先决条件</h3><ul>\n<li>Docker至少是19.03.9或者以上版本</li>\n<li><code>libseccomp</code>的版本至少是 2.4.2或者以上</li>\n</ul>\n<h3 id=\"Raspberry-pi-3\"><a href=\"#Raspberry-pi-3\" class=\"headerlink\" title=\"Raspberry pi 3\"></a>Raspberry pi 3</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">  --name homeassistant \\</span><br><span class=\"line\">  --privileged \\</span><br><span class=\"line\">  --restart=unless-stopped \\</span><br><span class=\"line\">  -e TZ=MY_TIME_ZONE \\</span><br><span class=\"line\">  -v /PATH_TO_YOUR_CONFIG:/config \\</span><br><span class=\"line\">  --network=host \\</span><br><span class=\"line\">  ghcr.io/home-assistant/raspberrypi3-homeassistant:stable</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Raspberry-pi-4\"><a href=\"#Raspberry-pi-4\" class=\"headerlink\" title=\"Raspberry pi 4\"></a>Raspberry pi 4</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">  --name homeassistant \\</span><br><span class=\"line\">  --privileged \\</span><br><span class=\"line\">  --restart=unless-stopped \\</span><br><span class=\"line\">  -e TZ=MY_TIME_ZONE \\</span><br><span class=\"line\">  -v /PATH_TO_YOUR_CONFIG:/config \\</span><br><span class=\"line\">  -v /run/dbus:/run/dbus:ro \\</span><br><span class=\"line\">  --network=host \\</span><br><span class=\"line\">  ghcr.io/home-assistant/raspberrypi4-homeassistant:stable</span><br></pre></td></tr></table></figure>\n\n<p>以上安装命令中，一定要将<code>/PATH_TO_YOUR_CONFIG</code>修改成指定的安装路径，例如<code>/home/pi/homeassistant</code>，如果忘记修改，配置文件就会保存到<code>/PATH_TO_YOUR_CONFIG</code>目录。</p>\n<p>更改<code>MY_TIME_ZONE</code>为本地时区，例如<code>Asia/Shanghai</code>。</p>\n<p>如果要使用<a href=\"https://www.home-assistant.io/integrations/bluetooth\">Bluetooth integration</a>, 需要设置<code>D-Bus</code>，即<code>-v /run/dbus:/run/dbus:ro</code></p>\n<p>安装成功后，打开浏览器访问<code>http://&lt;host&gt;:8123</code>，登录Home Assistant的Web界面。</p>\n<h2 id=\"更新Home-Assistant\"><a href=\"#更新Home-Assistant\" class=\"headerlink\" title=\"更新Home Assistant\"></a>更新Home Assistant</h2><p>下载最新版本的Home Assistant，如果命令结果返回”Image is up to date”，则说明目前已经是最新版本。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker pull ghcr.io/home-assistant/home-assistant:stable</span><br></pre></td></tr></table></figure>\n\n<p>停止运行Home Assistant容器。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker stop homeassistant</span><br></pre></td></tr></table></figure>\n\n<p>删除Home Assistant容器，<strong>该操作不会删除原有的配置文件</strong>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">rm</span> homeassistant</span><br></pre></td></tr></table></figure>\n\n<p>运行最新版本的Home Assistant，将<code>PATH_TO_YOUR_CONFIG</code>设置为原配置文件所在的路径，例如<code>/home/pi/homeassistant</code>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">\t--name homeassistant \\</span><br><span class=\"line\">\t--restart=unless-stopped \\ </span><br><span class=\"line\">\t--privileged \\ </span><br><span class=\"line\">\t-e TZ=MY_TIME_ZONE \\ </span><br><span class=\"line\">\t-v /PATH_TO_YOUR_CONFIG:/config \\ </span><br><span class=\"line\">\t-v /run/dbus:/run/dbus:ro \\ </span><br><span class=\"line\">\t--network=host \\ </span><br><span class=\"line\">\tghcr.io/home-assistant/home-assistant:stable</span><br></pre></td></tr></table></figure>"},{"title":"Requests库使用指南","date":"2022-02-08T07:40:20.000Z","_content":"\n> 注：本文翻译自[Python’s Requests Library (Guide)](https://realpython.com/python-requests/)。\n\n在Python中，`requests`库是处理HTTP请求的标准。它使得复杂的HTTP请求变得简单、易用，用户只需要专注于处理与Web服务之间的交互过程，并获取所需的数据。\n\n通过本文，你可以学到许多`requests`库中的有用功能，并且可以根据实际的使用场景，定制和优化这些功能。你还会学到如何有效地使用`requests`库，避免由于网络的原因影响应用的响应速度。\n\n在本指南中，你将学到以下内容：\n\n- 最常见的HTTP方式\n- 定制HTTP请求中的报头和数据，使用查询字符和消息内容\n- 检查请求和响应中的数据\n- 发送认证请求\n- 配置请求，防止应用的响应速度变慢\n\n<!-- more -->\n\n## 开始使用requests\n\n首先，需要安装`requests`库：\n\n```shell\n$ pip install requests\n```\n\n安装完成后，需要先导入`requests`库：\n\n```python\nimport requests\n```\n\n## GET请求\n\nHTTP有很多种请求方式，例如GET和POST，不同的请求方式，所执行的操作是不同的。其中，GET是最常用的HTTP请求。GET主要是用来获取Web数据。如果发起一个GET请求，就会调用`requests.get()`。\n\n以下例子中，你可以看到通过调用`get()`发送GET请求给Github的[Root REST API](https://developer.github.com/v3/#root-endpoint)。\n\n```python\n>>> requests.get('https://api.github.com')\n<Response [200]>\n```\n \n## 响应\n\n通过发送GET请求以后，我们可以得到一个Response的对象。将该对象存储到一个变量中后，我们可以查看该对象的属性和方法：\n\n```python\n>>> response = requests.get('https://api.github.com')\n```\n\n在以上例子中，我们将响应对象存储到`response`变量中。\n\n### 状态码（Status Codes）\n\n从响应`Response`中首先可以获取状态码，通过状态码来判断请求是否成功。\n\n例如，如果状态码是`200 OK`，那么说明请求是成功的，但是如果状态码是`404 NOT FOUND`，则说明未找到需要获取的资源。关于状态码的详细说明，请参考文档：[many other possible status codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)\n\n通过访问响应`response`的属性`.status_code`，可以看到服务器返回的状态码：\n\n```python\n>>> response.status_code\n200\n```\n\n`.status_code`返回的是`200`，说明请求时成功的，并且服务器返回了你需要获取的数据。\n\n有些情况下，你可能想要通过状态码来作为判断条件：\n\n```python\nif response.status_code == 200:\n    print('Success!')\nelif response.status_code == 404:\n    print('Not Found.')\n```\n\n以上例子中，如果服务器返回`200`的状态码，那么程序就会打印`Success!`。如果服务器返回`404`的状态码，程序就会打印`Not Found.`。\n\n`requests`提供了一种更为简便的方法。如果直接使用`Response`实例作为判断的条件，假设状态码在`200`和`400`之间，那么表达式就会被评估为`True`，否则就会被评估为`False`。\n\n因此，你可以将之前的例子改写如下：\n\n```python\nif response:\n    print('Success!')\nelse:\n    print('An error has occurred.')\n```\n\n> 技术细节：This [Truth Value Test](https://docs.python.org/3/library/stdtypes.html#truth-value-testing) is made possible because [`__bool__()` is an overloaded method](https://realpython.com/operator-function-overloading/#making-your-objects-truthy-or-falsey-using-bool) on `Response`.\n>\n> This means that the default behavior of `Response` has been redefined to take the status code into account when determining the truth value of the object.\n\n记住这种方式并不是检验状态码是否等于`200`，而是检验状态码是否在`200`到`400`之间，例如`204 NO CONTENT`和`304 NOT MODIFIED`，也被认为是请求成功的。\n\n例如，`204`是说明请求是成功的，但是返回的消息正文并没有任何内容。\n\n因此，如果只是为了知道请求是否成功，可以使用这种简便的方法，否则，建议还是根据具体的状态码来判断。\n\n有时候，可能你不希望用`if`语句来检查状态码，而是希望在请求失败的情况下，引发异常。那么你就可以使用`.raise_for_status()`：\n\n```python\nimport requests\nfrom requests.exceptions import HTTPError\n\nfor url in ['https://api.github.com', 'https://api.github.com/invalid']:\n    try:\n        response = requests.get(url)\n\n        # If the response was successful, no Exception will be raised\n        response.raise_for_status()\n    except HTTPError as http_err:\n        print(f'HTTP error occurred: {http_err}')  # Python 3.6\n    except Exception as err:\n        print(f'Other error occurred: {err}')  # Python 3.6\n    else:\n        print('Success!')\n```\n\n如果你调用`.raise_for_status()`，就会对某些失败的状态码引发`HTTPError`的异常错误。如果状态码显示请求是成功的，那么程序就不会引发异常。\n\n通过以上内容，你了解了很多关于如何处理状态码的知识。下面，你将看到如何查看服务器返回的具体数据内容。\n\n### 内容（Content）\n\nGET请求得到的响应经常包含很多有价值的信息，如消息正文中的payload。通过使用`Response`的属性和方法，你可以用不同的格式来查看payload。\n\n用bytes的格式查看响应的内容，你可以使用`.content`：\n\n```python\n>>> response = requests.get('https://api.github.com')\n>>> response.content\nb'{\"current_user_url\":\"https://api.github.com/user\",\"current_user_authorizations_html_url\":\"https://github.com/settings/connections/applications{/client_id}\",\"authorizations_url\":\"https://api.github.com/authorizations\",\"code_search_url\":\"https://api.github.com/search/code?q={query}{&page,per_page,sort,order}\",\"commit_search_url\":\"https://api.github.com/search/commits?q={query}{&page,per_page,sort,order}\",\"emails_url\":\"https://api.github.com/user/emails\",\"emojis_url\":\"https://api.github.com/emojis\",\"events_url\":\"https://api.github.com/events\",\"feeds_url\":\"https://api.github.com/feeds\",\"followers_url\":\"https://api.github.com/user/followers\",\"following_url\":\"https://api.github.com/user/following{/target}\",\"gists_url\":\"https://api.github.com/gists{/gist_id}\",\"hub_url\":\"https://api.github.com/hub\",\"issue_search_url\":\"https://api.github.com/search/issues?q={query}{&page,per_page,sort,order}\",\"issues_url\":\"https://api.github.com/issues\",\"keys_url\":\"https://api.github.com/user/keys\",\"notifications_url\":\"https://api.github.com/notifications\",\"organization_repositories_url\":\"https://api.github.com/orgs/{org}/repos{?type,page,per_page,sort}\",\"organization_url\":\"https://api.github.com/orgs/{org}\",\"public_gists_url\":\"https://api.github.com/gists/public\",\"rate_limit_url\":\"https://api.github.com/rate_limit\",\"repository_url\":\"https://api.github.com/repos/{owner}/{repo}\",\"repository_search_url\":\"https://api.github.com/search/repositories?q={query}{&page,per_page,sort,order}\",\"current_user_repositories_url\":\"https://api.github.com/user/repos{?type,page,per_page,sort}\",\"starred_url\":\"https://api.github.com/user/starred{/owner}{/repo}\",\"starred_gists_url\":\"https://api.github.com/gists/starred\",\"team_url\":\"https://api.github.com/teams\",\"user_url\":\"https://api.github.com/users/{user}\",\"user_organizations_url\":\"https://api.github.com/user/orgs\",\"user_repositories_url\":\"https://api.github.com/users/{user}/repos{?type,page,per_page,sort}\",\"user_search_url\":\"https://api.github.com/search/users?q={query}{&page,per_page,sort,order}\"}'\n```\n\n通过`.content`读取到的是字节格式的payload，如果你想要将其转换成UTF-8编码的字符串，你可以使用`.text`：\n\n```python\n>>> response.text\n'{\"current_user_url\":\"https://api.github.com/user\",\"current_user_authorizations_html_url\":\"https://github.com/settings/connections/applications{/client_id}\",\"authorizations_url\":\"https://api.github.com/authorizations\",\"code_search_url\":\"https://api.github.com/search/code?q={query}{&page,per_page,sort,order}\",\"commit_search_url\":\"https://api.github.com/search/commits?q={query}{&page,per_page,sort,order}\",\"emails_url\":\"https://api.github.com/user/emails\",\"emojis_url\":\"https://api.github.com/emojis\",\"events_url\":\"https://api.github.com/events\",\"feeds_url\":\"https://api.github.com/feeds\",\"followers_url\":\"https://api.github.com/user/followers\",\"following_url\":\"https://api.github.com/user/following{/target}\",\"gists_url\":\"https://api.github.com/gists{/gist_id}\",\"hub_url\":\"https://api.github.com/hub\",\"issue_search_url\":\"https://api.github.com/search/issues?q={query}{&page,per_page,sort,order}\",\"issues_url\":\"https://api.github.com/issues\",\"keys_url\":\"https://api.github.com/user/keys\",\"notifications_url\":\"https://api.github.com/notifications\",\"organization_repositories_url\":\"https://api.github.com/orgs/{org}/repos{?type,page,per_page,sort}\",\"organization_url\":\"https://api.github.com/orgs/{org}\",\"public_gists_url\":\"https://api.github.com/gists/public\",\"rate_limit_url\":\"https://api.github.com/rate_limit\",\"repository_url\":\"https://api.github.com/repos/{owner}/{repo}\",\"repository_search_url\":\"https://api.github.com/search/repositories?q={query}{&page,per_page,sort,order}\",\"current_user_repositories_url\":\"https://api.github.com/user/repos{?type,page,per_page,sort}\",\"starred_url\":\"https://api.github.com/user/starred{/owner}{/repo}\",\"starred_gists_url\":\"https://api.github.com/gists/starred\",\"team_url\":\"https://api.github.com/teams\",\"user_url\":\"https://api.github.com/users/{user}\",\"user_organizations_url\":\"https://api.github.com/user/orgs\",\"user_repositories_url\":\"https://api.github.com/users/{user}/repos{?type,page,per_page,sort}\",\"user_search_url\":\"https://api.github.com/search/users?q={query}{&page,per_page,sort,order}\"}'\n```\n\n因为将`bytes`转换成`str`需要指定编码的方式，`requests`会根据响应中的`hearders`内容来猜测编码的方式，或者，你也可以通过设置`.encoding`指定编码的方式：\n\n```python\n>>> response.encoding = 'utf-8' # Optional: requests infers this internally\n>>> response.text\n'{\"current_user_url\":\"https://api.github.com/user\",\"current_user_authorizations_html_url\":\"https://github.com/settings/connections/applications{/client_id}\",\"authorizations_url\":\"https://api.github.com/authorizations\",\"code_search_url\":\"https://api.github.com/search/code?q={query}{&page,per_page,sort,order}\",\"commit_search_url\":\"https://api.github.com/search/commits?q={query}{&page,per_page,sort,order}\",\"emails_url\":\"https://api.github.com/user/emails\",\"emojis_url\":\"https://api.github.com/emojis\",\"events_url\":\"https://api.github.com/events\",\"feeds_url\":\"https://api.github.com/feeds\",\"followers_url\":\"https://api.github.com/user/followers\",\"following_url\":\"https://api.github.com/user/following{/target}\",\"gists_url\":\"https://api.github.com/gists{/gist_id}\",\"hub_url\":\"https://api.github.com/hub\",\"issue_search_url\":\"https://api.github.com/search/issues?q={query}{&page,per_page,sort,order}\",\"issues_url\":\"https://api.github.com/issues\",\"keys_url\":\"https://api.github.com/user/keys\",\"notifications_url\":\"https://api.github.com/notifications\",\"organization_repositories_url\":\"https://api.github.com/orgs/{org}/repos{?type,page,per_page,sort}\",\"organization_url\":\"https://api.github.com/orgs/{org}\",\"public_gists_url\":\"https://api.github.com/gists/public\",\"rate_limit_url\":\"https://api.github.com/rate_limit\",\"repository_url\":\"https://api.github.com/repos/{owner}/{repo}\",\"repository_search_url\":\"https://api.github.com/search/repositories?q={query}{&page,per_page,sort,order}\",\"current_user_repositories_url\":\"https://api.github.com/user/repos{?type,page,per_page,sort}\",\"starred_url\":\"https://api.github.com/user/starred{/owner}{/repo}\",\"starred_gists_url\":\"https://api.github.com/gists/starred\",\"team_url\":\"https://api.github.com/teams\",\"user_url\":\"https://api.github.com/users/{user}\",\"user_organizations_url\":\"https://api.github.com/user/orgs\",\"user_repositories_url\":\"https://api.github.com/users/{user}/repos{?type,page,per_page,sort}\",\"user_search_url\":\"https://api.github.com/search/users?q={query}{&page,per_page,sort,order}\"}'\n```\n\n如果你仔细看一下响应的内容，你会发现实际上是序列化的`JSON`内容。因此，你可以通过`.text`的方式先获取字符串，然后再通过[`json.loads()`](https://realpython.com/python-json/#deserializing-json)的方式获取字典。其实，还有一种更为简单的方法，可以使用`.json()`：\n\n```python\n>>> response.json()\n{'current_user_url': 'https://api.github.com/user', 'current_user_authorizations_html_url': 'https://github.com/settings/connections/applications{/client_id}', 'authorizations_url': 'https://api.github.com/authorizations', 'code_search_url': 'https://api.github.com/search/code?q={query}{&page,per_page,sort,order}', 'commit_search_url': 'https://api.github.com/search/commits?q={query}{&page,per_page,sort,order}', 'emails_url': 'https://api.github.com/user/emails', 'emojis_url': 'https://api.github.com/emojis', 'events_url': 'https://api.github.com/events', 'feeds_url': 'https://api.github.com/feeds', 'followers_url': 'https://api.github.com/user/followers', 'following_url': 'https://api.github.com/user/following{/target}', 'gists_url': 'https://api.github.com/gists{/gist_id}', 'hub_url': 'https://api.github.com/hub', 'issue_search_url': 'https://api.github.com/search/issues?q={query}{&page,per_page,sort,order}', 'issues_url': 'https://api.github.com/issues', 'keys_url': 'https://api.github.com/user/keys', 'notifications_url': 'https://api.github.com/notifications', 'organization_repositories_url': 'https://api.github.com/orgs/{org}/repos{?type,page,per_page,sort}', 'organization_url': 'https://api.github.com/orgs/{org}', 'public_gists_url': 'https://api.github.com/gists/public', 'rate_limit_url': 'https://api.github.com/rate_limit', 'repository_url': 'https://api.github.com/repos/{owner}/{repo}', 'repository_search_url': 'https://api.github.com/search/repositories?q={query}{&page,per_page,sort,order}', 'current_user_repositories_url': 'https://api.github.com/user/repos{?type,page,per_page,sort}', 'starred_url': 'https://api.github.com/user/starred{/owner}{/repo}', 'starred_gists_url': 'https://api.github.com/gists/starred', 'team_url': 'https://api.github.com/teams', 'user_url': 'https://api.github.com/users/{user}', 'user_organizations_url': 'https://api.github.com/user/orgs', 'user_repositories_url': 'https://api.github.com/users/{user}/repos{?type,page,per_page,sort}', 'user_search_url': 'https://api.github.com/search/users?q={query}{&page,per_page,sort,order}'}\n```\n\n`.json()`返回的结果是一个字典，因此你可以通过键来访问字典中的值。\n\n除了状态码和消息正文，你还可以查看响应中的Headers。\n\n## 报头（Headers）\n\n响应中的报头通常包含很多有用的信息，例如内容类型，缓存内容的时间限制。\n\n可以通过`.headers`来查看报头的内容：\n\n```python\n>>> response.headers\n{'Server': 'GitHub.com', 'Date': 'Mon, 10 Dec 2018 17:49:54 GMT', 'Content-Type': 'application/json; charset=utf-8', 'Transfer-Encoding': 'chunked', 'Status': '200 OK', 'X-RateLimit-Limit': '60', 'X-RateLimit-Remaining': '59', 'X-RateLimit-Reset': '1544467794', 'Cache-Control': 'public, max-age=60, s-maxage=60', 'Vary': 'Accept', 'ETag': 'W/\"7dc470913f1fe9bb6c7355b50a0737bc\"', 'X-GitHub-Media-Type': 'github.v3; format=json', 'Access-Control-Expose-Headers': 'ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type', 'Access-Control-Allow-Origin': '*', 'Strict-Transport-Security': 'max-age=31536000; includeSubdomains; preload', 'X-Frame-Options': 'deny', 'X-Content-Type-Options': 'nosniff', 'X-XSS-Protection': '1; mode=block', 'Referrer-Policy': 'origin-when-cross-origin, strict-origin-when-cross-origin', 'Content-Security-Policy': \"default-src 'none'\", 'Content-Encoding': 'gzip', 'X-GitHub-Request-Id': 'E439:4581:CF2351:1CA3E06:5C0EA741'}\n```\n\n`.headers`返回的是字典类型的**对象**，因此，你可以像访问字典一样来获取值：\n\n```python\n>>> response.headers['Content-Type']\n'application/json; charset=utf-8'\n```\n\nheaders对象有一个特殊的地方。由于HTTP标准定义headers不区分大小写，所以，我们访问headers的时候，不需要担心大小写：\n\n```python\n>>> response.headers['content-type']\n'application/json; charset=utf-8'\n```\n\n以上例子中，无论使用`content-type`还是`Content-Type`，你都能得到相同的结果。\n\n## 查询字符串参数（Query String Parameters）\n\n通过在URL中传递查询字符串参数，可以定制GET请求。在方法`get()`中，可以传递参数`params`。例如，你可以使用GitHub的查询API来查找`requests`库。\n\n```python\nimport requests\n\n# Search GitHub's repositories for requests\nresponse = requests.get(\n    'https://api.github.com/search/repositories',\n    params={'q': 'requests+language:python'},\n)\n\n# Inspect some attributes of the `requests` repository\njson_response = response.json()\nrepository = json_response['items'][0]\nprint(f'Repository name: {repository[\"name\"]}')  # Python 3.6+\nprint(f'Repository description: {repository[\"description\"]}')  # Python 3.6+\n```\n\n在方法`.get()`中，通过将字典`{'q': 'requests+language:python'}`传递给参数`params`，你可以改变从查询API返回的结果。\n\n你也可以用字典作为参数`params`的值，也可以使用以元组为成员的数组作为参数`params`的值：\n\n```python\n>>> requests.get(\n...     'https://api.github.com/search/repositories',\n...     params=[('q', 'requests+language:python')],\n... )\n<Response [200]>\n```\n\n甚至，你还可以传递bytes作为值传递给参数：\n\n```python\n>>> requests.get(\n...     'https://api.github.com/search/repositories',\n...     params=b'q=requests+language:python',\n... )\n<Response [200]>\n```\n\n查询字符串对于自定义GET请求非常有用。同时，你还可以通过添加或者修改报头来自定义GET请求。\n\n## 请求报头（Request Headers）\n\n在方法`.get()`中，你可以通过将字典作为值传递给参数`headers`的方式，来自定义报头。例如，在之前的查询例子中，你可以通过在`Accept`报头中指定`text-match`类型：\n\n```python\nimport requests\n\nresponse = requests.get(\n    'https://api.github.com/search/repositories',\n    params={'q': 'requests+language:python'},\n    headers={'Accept': 'application/vnd.github.v3.text-match+json'},\n)\n\n# View the new `text-matches` array which provides information\n# about your search term within the results\njson_response = response.json()\nrepository = json_response['items'][0]\nprint(f'Text matches: {repository[\"text_matches\"]}')\n```\n\n`Accept`报头可以告诉服务器，你的应用可以处理的消息正文类型。在本例中，你使用的报头值是`application/vnd.github.v3.text-match+json`，这是GitHub网站`Accept`报头的专有属性，正文内容是一种特殊的JSON格式。\n\n在学习其它自定义请求的方式之前，我们先简单了解一下其它的HTTP方法。\n\n## 其它的HTTP方法\n\n除了GET以前，HTTP还支持`POST`, `PUT`, `DELETE`, `HEAD`, `PATCH`和`OPTIONS`。在`requests`库中给，这些方法的使用方法和`get()`相似：\n\n```python\n>>> requests.post('https://httpbin.org/post', data={'key':'value'})\n>>> requests.put('https://httpbin.org/put', data={'key':'value'})\n>>> requests.delete('https://httpbin.org/delete')\n>>> requests.head('https://httpbin.org/get')\n>>> requests.patch('https://httpbin.org/patch', data={'key':'value'})\n>>> requests.options('https://httpbin.org/get')\n```\n\n以下例子中，每一个函数调用都会对httpbin服务发起相应的HTTP方法。每一种方法，你都可以使用和之前相同的方式，查看服务器响应的内容：\n\n```python\n>>> response = requests.head('https://httpbin.org/get')\n>>> response.headers['Content-Type']\n'application/json'\n\n>>> response = requests.delete('https://httpbin.org/delete')\n>>> json_response = response.json()\n>>> json_response['args']\n{}\n```\n\n报头、响应正文、状态码和其它信息都会包含在每一种HTTP方法的`Response`中。接下来，你将更为详细地了解`POST`，`PUT`和`PATCH`方法，以及它们之间的区别。\n\n## 消息正文\n\n根据HTTP的规格说明，`POST`，`PUT`和`PATCH`都是通过将数据传递给消息正文，而不是通过将查询字符串传递给参数的方式。通过使用`requests`，你可以将`payload`传递给`data`参数。\n\n你可以将字典，元组为成员的列表或者文件对象传递给参数`data`。在请求的正文中，根据具体的类型需要，你可以采用不同的数据类型：\n\n例如，如果你请求的内容类型为`application/x-www-form-urlencoded`，那么你就可以将字典作为表格数据，传递给参数`data`。\n\n```python\n>>> requests.post('https://httpbin.org/post', data={'key':'value'})\n<Response [200]>\n```\n\n你也可以使用以元组为成员的列表：\n\n```python\n>>> requests.post('https://httpbin.org/post', data=[('key', 'value')])\n<Response [200]>\n```\n\n但是，如果你需要发送JSON格式的数据，你可以使用参数`json`。当你将值传递给参数`json`后，`requests`库会序列化你的数据和正确的`Content-Type`报头。\n\n[httpbin.org](https://httpbin.org/)是由`requests`库的开发者 [Kenneth Reitz](https://realpython.com/interview-kenneth-reitz/)创建的一个用于测试的网站。该网站可以用来测试`requests`发起的各种请求。例如，你可以用它来测试POST请求：\n\n```python\n>>> response = requests.post('https://httpbin.org/post', json={'key':'value'})\n>>> json_response = response.json()\n>>> json_response['data']\n'{\"key\": \"value\"}'\n>>> json_response['headers']['Content-Type']\n'application/json'\n```\n\n## 检查请求\n\n在发送请求到服务器之前，`requests`库会先将请求准备好。请求的准备包括验证报头以及序列化JSON内容。\n\n你可以通过`.request`来访问准备请求（`PrepareRequest`）：\n\n```python\n>>> response = requests.post('https://httpbin.org/post', json={'key':'value'})\n>>> response.request.headers['Content-Type']\n'application/json'\n>>> response.request.url\n'https://httpbin.org/post'\n>>> response.request.body\nb'{\"key\": \"value\"}'\n```\n\n检查准备请求可以让你访问各种信息，包括payload, URL, headers, authentication等等。\n\n## 认证\n\n认证可以让服务器知道你是谁。通常情况下，你可以通过`Authorization`报头提供你的身份信息，或者也可以通过自定义的报头来提供身份信息。在`requests`中，你可以使用参数`auth`来传递你的身份信息。\n\n下面以GitHub的[Authenticated User](https://developer.github.com/v3/users/#get-the-authenticated-user) API为例。为了访问该API，你需要通过一个元组来传递用户名和密码：\n\n```python\n>>> from getpass import getpass\n>>> requests.get('https://api.github.com/user', auth=('username', getpass()))\n<Response [200]>\n```\n\n如果身份信息正确，request请求就会返回成功过。如果request请求中没有包含身份信息，服务器就会返回`401 Unauthorized`：\n\n```python\n>>> requests.get('https://api.github.com/user')\n<Response [401]>\n```\n\n当你通过以上这种方式传递身份信息的时候，实际上`requests`使用的是HTTP的 [Basic access authentication scheme](https://en.wikipedia.org/wiki/Basic_access_authentication)。\n\n因此，你还可以使用`HTTPBasicAuth`来传递身份信息：\n\n```python\n>>> from requests.auth import HTTPBasicAuth\n>>> from getpass import getpass\n>>> requests.get(\n...     'https://api.github.com/user',\n...     auth=HTTPBasicAuth('username', getpass())\n... )\n<Response [200]>\n```\n\n除了Basic认证方式以外，`requests`还支持其它认证方式，例如`HTTPDigestAuth`和`HTTPProxyAuth`。\n\n你甚至还可以提供自定义的认证方式。但是，你必须首先创建一个继承`AuthBase`的子类。然后，你需要定义`__call__()`函数：\n\n```python\nimport requests\nfrom requests.auth import AuthBase\n\nclass TokenAuth(AuthBase):\n    \"\"\"Implements a custom authentication scheme.\"\"\"\n\n    def __init__(self, token):\n        self.token = token\n\n    def __call__(self, r):\n        \"\"\"Attach an API token to a custom auth header.\"\"\"\n        r.headers['X-TokenAuth'] = f'{self.token}'  # Python 3.6+\n        return r\n\n\nrequests.get('https://httpbin.org/get', auth=TokenAuth('12345abcde-token'))\n```\n\n以上例子中，自定义的类`TokenAuth`会收到一个Token，然后将收到的token放到`x-TokenAuth`报头中。\n\n不健全的认证机制会导致安全隐患，所以除非有特殊需求，否则应该使用成熟的认证机制，比如Basic或者OAuth。\n\n## SSL证书验证\n\n任何时候，当发送和接收的信息比较机密，安全往往是最重要的。因此，当你访问安全站点的时候，都会通过SSL建立安全连接，这时候对服务器的SSL证书进行验证显得尤为重要。\n\n默认情况下，`requests`已经为你执行了SSL证书的验证。但是，在某些情况下，你可能希望改变这种默认的行为。\n\n如果你想要关闭SSL证书的验证，你可以将参数`verify`设置为`False`：\n\n```python\n>>> requests.get('https://api.github.com', verify=False)\nInsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings\n  InsecureRequestWarning)\n<Response [200]>\n```\n\n当你正在访问一个不安全的站点时，`requests`会发出警告信息提醒你。\n\n> 注意：`requests`使用[`certifi`](http://docs.python-requests.org/en/master/user/advanced/#ca-certificates)来提供SSL证书的颁发机构（ Certificate Authorities）。这可以让`requests`知道有哪些可以信任的证书颁发机构。因此，你需要定期更新`certifi`来保证安全性。\n\n## 性能\n\n当在生产环境中使用`requests`的时候，特别需要考虑性能的影响。`requests`库的一些特性，例如超时控制（timeout control），会话（sessions）和重试限制（retry limits）可以使得应用运行得更流畅。\n\n### Timeouts\n\n当你向服务发送请求以后，你得应用将会等待服务端的响应，得到响应以后，才会执行下一步操作。如果应用等待的时间太长，请求就会一直处于等待状态，导致用户体验变差，或者后台任务挂起。\n\n默认情况下，`requests`将会无限制地等待响应，所以你应该指定一个超时的时间值。你可以通过参数`timeout`来设置超时的时间值。`timeout`的值可以是整型或者浮点型，时间的单位是秒。\n\n```python\n>>> requests.get('https://api.github.com', timeout=1)\n<Response [200]>\n>>> requests.get('https://api.github.com', timeout=3.05)\n<Response [200]>\n```\n\n以上例子中，第一个请求的超时时间是1秒，第二个请求的超时时间是3.05秒。\n\n你还可以传递一个[元组](http://docs.python-requests.org/en/master/user/advanced/#timeouts)给参数`timeout`，元组中的第一个值是TCP连接的超时时间（客户端和服务器之间建立连接的时长，通常建议设置为比3的倍数大一点），第二个值是数据传输的超时时间（建立连接后，等待响应的超时时间）：\n\n```python\n>>> requests.get('https://api.github.com', timeout=(2, 5))\n<Response [200]>\n```\n\n如果请求建立连接的时间在2秒以内，建立连接后，接收数据的时间在5秒以内，那么就可以正常获取到响应。但是，如果请求超时，那么函数就会抛出一个`Timeout`的异常。\n\n```python\nimport requests\nfrom requests.exceptions import Timeout\n\ntry:\n    response = requests.get('https://api.github.com', timeout=1)\nexcept Timeout:\n    print('The request timed out')\nelse:\n    print('The request did not time out')\n```\n\n你的程序可以捕获这个`Timeout`的异常，并做相应的处理。\n\n### The Session Object\n\n到目前为止，你都是使用`requests`的`get()`和`post()`来发送请求。这些函数隐藏了一些细节，例如连接是如何建立以及管理的。\n\n实际上，这些细节都是由类`Session`来负责处理。如果你需要微调你的请求，或者改进性能，你需要直接使用`Session`的实例。\n\n会话主要是在一些列的请求中，保持持久的参数。例如，如果你想要在多个请求中使用相同的认证信息，你就可以使用会话：\n\n```python\nimport requests\nfrom getpass import getpass\n\n# By using a context manager, you can ensure the resources used by\n# the session will be released after use\nwith requests.Session() as session:\n    session.auth = ('username', getpass())\n\n    # Instead of requests.get(), you'll use session.get()\n    response = session.get('https://api.github.com/user')\n\n# You can inspect the response just like you did before\nprint(response.headers)\nprint(response.json())\n```\n\n每次你用session发起请求，一旦该会话在初始化时，设定了认证的身份信息，那么该身份信息就可以在多个requests中重复使用。\n\n通过session改进性能，主要是通过保持长连接的方式。当你的应用通过Session来发起请求，它就会在连接池中长时间保持该连接。当应用想要再次连接到同一个服务器的时候，就可以重复使用连接池中的连接，而不需要再新建连接。\n\n### Max Retries\n\n当请求失败的时候，你可能希望应用重新发起同样的请求。但是，`requests`默认并不会帮你重新发送请求。为了实现这个功能，你需要使用[Transport Adapter](http://docs.python-requests.org/en/master/user/advanced/#transport-adapters)。\n\nTransport Adapters可以让你为每一个需要访问的服务定义一组配置信息。例如，你想要所有访问`https://api.github.com`的请求失败后重复三次，你可以创建一个Transport Adapter，设置参数`max_retries`的值为3，并将其挂载到当前的会话上：\n\n```python\nimport requests\nfrom requests.adapters import HTTPAdapter\nfrom requests.exceptions import ConnectionError\n\ngithub_adapter = HTTPAdapter(max_retries=3)\n\nsession = requests.Session()\n\n# Use `github_adapter` for all requests to endpoints that start with this URL\nsession.mount('https://api.github.com', github_adapter)\n\ntry:\n    session.get('https://api.github.com')\nexcept ConnectionError as ce:\n    print(ce)\n```\n\n当你挂载github_adapter到会话的时候，会话会遵循该配置的设置。\n\n## 总结\n\n通过以上内容，你现在可以：\n\n- 发送不同的HTTP请求，例如：GET, POST, PUT\n- 通过修改报头，认证，查询字符串和消息这个问，自定义请求\n- 检查发送给服务器的数据，以及从服务器接收的数据\n- SSL证书验证\n- 通过max_retries, timeout, Sessions和Transport Adapters，更有效的使用`requests`\n","source":"_posts/Python/Requests库使用指南.md","raw":"---\ntitle: Requests库使用指南\ndate: 2022-02-08 15:40:20\ntags:\n  - requests\ncategories:\n  - Python\n---\n\n> 注：本文翻译自[Python’s Requests Library (Guide)](https://realpython.com/python-requests/)。\n\n在Python中，`requests`库是处理HTTP请求的标准。它使得复杂的HTTP请求变得简单、易用，用户只需要专注于处理与Web服务之间的交互过程，并获取所需的数据。\n\n通过本文，你可以学到许多`requests`库中的有用功能，并且可以根据实际的使用场景，定制和优化这些功能。你还会学到如何有效地使用`requests`库，避免由于网络的原因影响应用的响应速度。\n\n在本指南中，你将学到以下内容：\n\n- 最常见的HTTP方式\n- 定制HTTP请求中的报头和数据，使用查询字符和消息内容\n- 检查请求和响应中的数据\n- 发送认证请求\n- 配置请求，防止应用的响应速度变慢\n\n<!-- more -->\n\n## 开始使用requests\n\n首先，需要安装`requests`库：\n\n```shell\n$ pip install requests\n```\n\n安装完成后，需要先导入`requests`库：\n\n```python\nimport requests\n```\n\n## GET请求\n\nHTTP有很多种请求方式，例如GET和POST，不同的请求方式，所执行的操作是不同的。其中，GET是最常用的HTTP请求。GET主要是用来获取Web数据。如果发起一个GET请求，就会调用`requests.get()`。\n\n以下例子中，你可以看到通过调用`get()`发送GET请求给Github的[Root REST API](https://developer.github.com/v3/#root-endpoint)。\n\n```python\n>>> requests.get('https://api.github.com')\n<Response [200]>\n```\n \n## 响应\n\n通过发送GET请求以后，我们可以得到一个Response的对象。将该对象存储到一个变量中后，我们可以查看该对象的属性和方法：\n\n```python\n>>> response = requests.get('https://api.github.com')\n```\n\n在以上例子中，我们将响应对象存储到`response`变量中。\n\n### 状态码（Status Codes）\n\n从响应`Response`中首先可以获取状态码，通过状态码来判断请求是否成功。\n\n例如，如果状态码是`200 OK`，那么说明请求是成功的，但是如果状态码是`404 NOT FOUND`，则说明未找到需要获取的资源。关于状态码的详细说明，请参考文档：[many other possible status codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)\n\n通过访问响应`response`的属性`.status_code`，可以看到服务器返回的状态码：\n\n```python\n>>> response.status_code\n200\n```\n\n`.status_code`返回的是`200`，说明请求时成功的，并且服务器返回了你需要获取的数据。\n\n有些情况下，你可能想要通过状态码来作为判断条件：\n\n```python\nif response.status_code == 200:\n    print('Success!')\nelif response.status_code == 404:\n    print('Not Found.')\n```\n\n以上例子中，如果服务器返回`200`的状态码，那么程序就会打印`Success!`。如果服务器返回`404`的状态码，程序就会打印`Not Found.`。\n\n`requests`提供了一种更为简便的方法。如果直接使用`Response`实例作为判断的条件，假设状态码在`200`和`400`之间，那么表达式就会被评估为`True`，否则就会被评估为`False`。\n\n因此，你可以将之前的例子改写如下：\n\n```python\nif response:\n    print('Success!')\nelse:\n    print('An error has occurred.')\n```\n\n> 技术细节：This [Truth Value Test](https://docs.python.org/3/library/stdtypes.html#truth-value-testing) is made possible because [`__bool__()` is an overloaded method](https://realpython.com/operator-function-overloading/#making-your-objects-truthy-or-falsey-using-bool) on `Response`.\n>\n> This means that the default behavior of `Response` has been redefined to take the status code into account when determining the truth value of the object.\n\n记住这种方式并不是检验状态码是否等于`200`，而是检验状态码是否在`200`到`400`之间，例如`204 NO CONTENT`和`304 NOT MODIFIED`，也被认为是请求成功的。\n\n例如，`204`是说明请求是成功的，但是返回的消息正文并没有任何内容。\n\n因此，如果只是为了知道请求是否成功，可以使用这种简便的方法，否则，建议还是根据具体的状态码来判断。\n\n有时候，可能你不希望用`if`语句来检查状态码，而是希望在请求失败的情况下，引发异常。那么你就可以使用`.raise_for_status()`：\n\n```python\nimport requests\nfrom requests.exceptions import HTTPError\n\nfor url in ['https://api.github.com', 'https://api.github.com/invalid']:\n    try:\n        response = requests.get(url)\n\n        # If the response was successful, no Exception will be raised\n        response.raise_for_status()\n    except HTTPError as http_err:\n        print(f'HTTP error occurred: {http_err}')  # Python 3.6\n    except Exception as err:\n        print(f'Other error occurred: {err}')  # Python 3.6\n    else:\n        print('Success!')\n```\n\n如果你调用`.raise_for_status()`，就会对某些失败的状态码引发`HTTPError`的异常错误。如果状态码显示请求是成功的，那么程序就不会引发异常。\n\n通过以上内容，你了解了很多关于如何处理状态码的知识。下面，你将看到如何查看服务器返回的具体数据内容。\n\n### 内容（Content）\n\nGET请求得到的响应经常包含很多有价值的信息，如消息正文中的payload。通过使用`Response`的属性和方法，你可以用不同的格式来查看payload。\n\n用bytes的格式查看响应的内容，你可以使用`.content`：\n\n```python\n>>> response = requests.get('https://api.github.com')\n>>> response.content\nb'{\"current_user_url\":\"https://api.github.com/user\",\"current_user_authorizations_html_url\":\"https://github.com/settings/connections/applications{/client_id}\",\"authorizations_url\":\"https://api.github.com/authorizations\",\"code_search_url\":\"https://api.github.com/search/code?q={query}{&page,per_page,sort,order}\",\"commit_search_url\":\"https://api.github.com/search/commits?q={query}{&page,per_page,sort,order}\",\"emails_url\":\"https://api.github.com/user/emails\",\"emojis_url\":\"https://api.github.com/emojis\",\"events_url\":\"https://api.github.com/events\",\"feeds_url\":\"https://api.github.com/feeds\",\"followers_url\":\"https://api.github.com/user/followers\",\"following_url\":\"https://api.github.com/user/following{/target}\",\"gists_url\":\"https://api.github.com/gists{/gist_id}\",\"hub_url\":\"https://api.github.com/hub\",\"issue_search_url\":\"https://api.github.com/search/issues?q={query}{&page,per_page,sort,order}\",\"issues_url\":\"https://api.github.com/issues\",\"keys_url\":\"https://api.github.com/user/keys\",\"notifications_url\":\"https://api.github.com/notifications\",\"organization_repositories_url\":\"https://api.github.com/orgs/{org}/repos{?type,page,per_page,sort}\",\"organization_url\":\"https://api.github.com/orgs/{org}\",\"public_gists_url\":\"https://api.github.com/gists/public\",\"rate_limit_url\":\"https://api.github.com/rate_limit\",\"repository_url\":\"https://api.github.com/repos/{owner}/{repo}\",\"repository_search_url\":\"https://api.github.com/search/repositories?q={query}{&page,per_page,sort,order}\",\"current_user_repositories_url\":\"https://api.github.com/user/repos{?type,page,per_page,sort}\",\"starred_url\":\"https://api.github.com/user/starred{/owner}{/repo}\",\"starred_gists_url\":\"https://api.github.com/gists/starred\",\"team_url\":\"https://api.github.com/teams\",\"user_url\":\"https://api.github.com/users/{user}\",\"user_organizations_url\":\"https://api.github.com/user/orgs\",\"user_repositories_url\":\"https://api.github.com/users/{user}/repos{?type,page,per_page,sort}\",\"user_search_url\":\"https://api.github.com/search/users?q={query}{&page,per_page,sort,order}\"}'\n```\n\n通过`.content`读取到的是字节格式的payload，如果你想要将其转换成UTF-8编码的字符串，你可以使用`.text`：\n\n```python\n>>> response.text\n'{\"current_user_url\":\"https://api.github.com/user\",\"current_user_authorizations_html_url\":\"https://github.com/settings/connections/applications{/client_id}\",\"authorizations_url\":\"https://api.github.com/authorizations\",\"code_search_url\":\"https://api.github.com/search/code?q={query}{&page,per_page,sort,order}\",\"commit_search_url\":\"https://api.github.com/search/commits?q={query}{&page,per_page,sort,order}\",\"emails_url\":\"https://api.github.com/user/emails\",\"emojis_url\":\"https://api.github.com/emojis\",\"events_url\":\"https://api.github.com/events\",\"feeds_url\":\"https://api.github.com/feeds\",\"followers_url\":\"https://api.github.com/user/followers\",\"following_url\":\"https://api.github.com/user/following{/target}\",\"gists_url\":\"https://api.github.com/gists{/gist_id}\",\"hub_url\":\"https://api.github.com/hub\",\"issue_search_url\":\"https://api.github.com/search/issues?q={query}{&page,per_page,sort,order}\",\"issues_url\":\"https://api.github.com/issues\",\"keys_url\":\"https://api.github.com/user/keys\",\"notifications_url\":\"https://api.github.com/notifications\",\"organization_repositories_url\":\"https://api.github.com/orgs/{org}/repos{?type,page,per_page,sort}\",\"organization_url\":\"https://api.github.com/orgs/{org}\",\"public_gists_url\":\"https://api.github.com/gists/public\",\"rate_limit_url\":\"https://api.github.com/rate_limit\",\"repository_url\":\"https://api.github.com/repos/{owner}/{repo}\",\"repository_search_url\":\"https://api.github.com/search/repositories?q={query}{&page,per_page,sort,order}\",\"current_user_repositories_url\":\"https://api.github.com/user/repos{?type,page,per_page,sort}\",\"starred_url\":\"https://api.github.com/user/starred{/owner}{/repo}\",\"starred_gists_url\":\"https://api.github.com/gists/starred\",\"team_url\":\"https://api.github.com/teams\",\"user_url\":\"https://api.github.com/users/{user}\",\"user_organizations_url\":\"https://api.github.com/user/orgs\",\"user_repositories_url\":\"https://api.github.com/users/{user}/repos{?type,page,per_page,sort}\",\"user_search_url\":\"https://api.github.com/search/users?q={query}{&page,per_page,sort,order}\"}'\n```\n\n因为将`bytes`转换成`str`需要指定编码的方式，`requests`会根据响应中的`hearders`内容来猜测编码的方式，或者，你也可以通过设置`.encoding`指定编码的方式：\n\n```python\n>>> response.encoding = 'utf-8' # Optional: requests infers this internally\n>>> response.text\n'{\"current_user_url\":\"https://api.github.com/user\",\"current_user_authorizations_html_url\":\"https://github.com/settings/connections/applications{/client_id}\",\"authorizations_url\":\"https://api.github.com/authorizations\",\"code_search_url\":\"https://api.github.com/search/code?q={query}{&page,per_page,sort,order}\",\"commit_search_url\":\"https://api.github.com/search/commits?q={query}{&page,per_page,sort,order}\",\"emails_url\":\"https://api.github.com/user/emails\",\"emojis_url\":\"https://api.github.com/emojis\",\"events_url\":\"https://api.github.com/events\",\"feeds_url\":\"https://api.github.com/feeds\",\"followers_url\":\"https://api.github.com/user/followers\",\"following_url\":\"https://api.github.com/user/following{/target}\",\"gists_url\":\"https://api.github.com/gists{/gist_id}\",\"hub_url\":\"https://api.github.com/hub\",\"issue_search_url\":\"https://api.github.com/search/issues?q={query}{&page,per_page,sort,order}\",\"issues_url\":\"https://api.github.com/issues\",\"keys_url\":\"https://api.github.com/user/keys\",\"notifications_url\":\"https://api.github.com/notifications\",\"organization_repositories_url\":\"https://api.github.com/orgs/{org}/repos{?type,page,per_page,sort}\",\"organization_url\":\"https://api.github.com/orgs/{org}\",\"public_gists_url\":\"https://api.github.com/gists/public\",\"rate_limit_url\":\"https://api.github.com/rate_limit\",\"repository_url\":\"https://api.github.com/repos/{owner}/{repo}\",\"repository_search_url\":\"https://api.github.com/search/repositories?q={query}{&page,per_page,sort,order}\",\"current_user_repositories_url\":\"https://api.github.com/user/repos{?type,page,per_page,sort}\",\"starred_url\":\"https://api.github.com/user/starred{/owner}{/repo}\",\"starred_gists_url\":\"https://api.github.com/gists/starred\",\"team_url\":\"https://api.github.com/teams\",\"user_url\":\"https://api.github.com/users/{user}\",\"user_organizations_url\":\"https://api.github.com/user/orgs\",\"user_repositories_url\":\"https://api.github.com/users/{user}/repos{?type,page,per_page,sort}\",\"user_search_url\":\"https://api.github.com/search/users?q={query}{&page,per_page,sort,order}\"}'\n```\n\n如果你仔细看一下响应的内容，你会发现实际上是序列化的`JSON`内容。因此，你可以通过`.text`的方式先获取字符串，然后再通过[`json.loads()`](https://realpython.com/python-json/#deserializing-json)的方式获取字典。其实，还有一种更为简单的方法，可以使用`.json()`：\n\n```python\n>>> response.json()\n{'current_user_url': 'https://api.github.com/user', 'current_user_authorizations_html_url': 'https://github.com/settings/connections/applications{/client_id}', 'authorizations_url': 'https://api.github.com/authorizations', 'code_search_url': 'https://api.github.com/search/code?q={query}{&page,per_page,sort,order}', 'commit_search_url': 'https://api.github.com/search/commits?q={query}{&page,per_page,sort,order}', 'emails_url': 'https://api.github.com/user/emails', 'emojis_url': 'https://api.github.com/emojis', 'events_url': 'https://api.github.com/events', 'feeds_url': 'https://api.github.com/feeds', 'followers_url': 'https://api.github.com/user/followers', 'following_url': 'https://api.github.com/user/following{/target}', 'gists_url': 'https://api.github.com/gists{/gist_id}', 'hub_url': 'https://api.github.com/hub', 'issue_search_url': 'https://api.github.com/search/issues?q={query}{&page,per_page,sort,order}', 'issues_url': 'https://api.github.com/issues', 'keys_url': 'https://api.github.com/user/keys', 'notifications_url': 'https://api.github.com/notifications', 'organization_repositories_url': 'https://api.github.com/orgs/{org}/repos{?type,page,per_page,sort}', 'organization_url': 'https://api.github.com/orgs/{org}', 'public_gists_url': 'https://api.github.com/gists/public', 'rate_limit_url': 'https://api.github.com/rate_limit', 'repository_url': 'https://api.github.com/repos/{owner}/{repo}', 'repository_search_url': 'https://api.github.com/search/repositories?q={query}{&page,per_page,sort,order}', 'current_user_repositories_url': 'https://api.github.com/user/repos{?type,page,per_page,sort}', 'starred_url': 'https://api.github.com/user/starred{/owner}{/repo}', 'starred_gists_url': 'https://api.github.com/gists/starred', 'team_url': 'https://api.github.com/teams', 'user_url': 'https://api.github.com/users/{user}', 'user_organizations_url': 'https://api.github.com/user/orgs', 'user_repositories_url': 'https://api.github.com/users/{user}/repos{?type,page,per_page,sort}', 'user_search_url': 'https://api.github.com/search/users?q={query}{&page,per_page,sort,order}'}\n```\n\n`.json()`返回的结果是一个字典，因此你可以通过键来访问字典中的值。\n\n除了状态码和消息正文，你还可以查看响应中的Headers。\n\n## 报头（Headers）\n\n响应中的报头通常包含很多有用的信息，例如内容类型，缓存内容的时间限制。\n\n可以通过`.headers`来查看报头的内容：\n\n```python\n>>> response.headers\n{'Server': 'GitHub.com', 'Date': 'Mon, 10 Dec 2018 17:49:54 GMT', 'Content-Type': 'application/json; charset=utf-8', 'Transfer-Encoding': 'chunked', 'Status': '200 OK', 'X-RateLimit-Limit': '60', 'X-RateLimit-Remaining': '59', 'X-RateLimit-Reset': '1544467794', 'Cache-Control': 'public, max-age=60, s-maxage=60', 'Vary': 'Accept', 'ETag': 'W/\"7dc470913f1fe9bb6c7355b50a0737bc\"', 'X-GitHub-Media-Type': 'github.v3; format=json', 'Access-Control-Expose-Headers': 'ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type', 'Access-Control-Allow-Origin': '*', 'Strict-Transport-Security': 'max-age=31536000; includeSubdomains; preload', 'X-Frame-Options': 'deny', 'X-Content-Type-Options': 'nosniff', 'X-XSS-Protection': '1; mode=block', 'Referrer-Policy': 'origin-when-cross-origin, strict-origin-when-cross-origin', 'Content-Security-Policy': \"default-src 'none'\", 'Content-Encoding': 'gzip', 'X-GitHub-Request-Id': 'E439:4581:CF2351:1CA3E06:5C0EA741'}\n```\n\n`.headers`返回的是字典类型的**对象**，因此，你可以像访问字典一样来获取值：\n\n```python\n>>> response.headers['Content-Type']\n'application/json; charset=utf-8'\n```\n\nheaders对象有一个特殊的地方。由于HTTP标准定义headers不区分大小写，所以，我们访问headers的时候，不需要担心大小写：\n\n```python\n>>> response.headers['content-type']\n'application/json; charset=utf-8'\n```\n\n以上例子中，无论使用`content-type`还是`Content-Type`，你都能得到相同的结果。\n\n## 查询字符串参数（Query String Parameters）\n\n通过在URL中传递查询字符串参数，可以定制GET请求。在方法`get()`中，可以传递参数`params`。例如，你可以使用GitHub的查询API来查找`requests`库。\n\n```python\nimport requests\n\n# Search GitHub's repositories for requests\nresponse = requests.get(\n    'https://api.github.com/search/repositories',\n    params={'q': 'requests+language:python'},\n)\n\n# Inspect some attributes of the `requests` repository\njson_response = response.json()\nrepository = json_response['items'][0]\nprint(f'Repository name: {repository[\"name\"]}')  # Python 3.6+\nprint(f'Repository description: {repository[\"description\"]}')  # Python 3.6+\n```\n\n在方法`.get()`中，通过将字典`{'q': 'requests+language:python'}`传递给参数`params`，你可以改变从查询API返回的结果。\n\n你也可以用字典作为参数`params`的值，也可以使用以元组为成员的数组作为参数`params`的值：\n\n```python\n>>> requests.get(\n...     'https://api.github.com/search/repositories',\n...     params=[('q', 'requests+language:python')],\n... )\n<Response [200]>\n```\n\n甚至，你还可以传递bytes作为值传递给参数：\n\n```python\n>>> requests.get(\n...     'https://api.github.com/search/repositories',\n...     params=b'q=requests+language:python',\n... )\n<Response [200]>\n```\n\n查询字符串对于自定义GET请求非常有用。同时，你还可以通过添加或者修改报头来自定义GET请求。\n\n## 请求报头（Request Headers）\n\n在方法`.get()`中，你可以通过将字典作为值传递给参数`headers`的方式，来自定义报头。例如，在之前的查询例子中，你可以通过在`Accept`报头中指定`text-match`类型：\n\n```python\nimport requests\n\nresponse = requests.get(\n    'https://api.github.com/search/repositories',\n    params={'q': 'requests+language:python'},\n    headers={'Accept': 'application/vnd.github.v3.text-match+json'},\n)\n\n# View the new `text-matches` array which provides information\n# about your search term within the results\njson_response = response.json()\nrepository = json_response['items'][0]\nprint(f'Text matches: {repository[\"text_matches\"]}')\n```\n\n`Accept`报头可以告诉服务器，你的应用可以处理的消息正文类型。在本例中，你使用的报头值是`application/vnd.github.v3.text-match+json`，这是GitHub网站`Accept`报头的专有属性，正文内容是一种特殊的JSON格式。\n\n在学习其它自定义请求的方式之前，我们先简单了解一下其它的HTTP方法。\n\n## 其它的HTTP方法\n\n除了GET以前，HTTP还支持`POST`, `PUT`, `DELETE`, `HEAD`, `PATCH`和`OPTIONS`。在`requests`库中给，这些方法的使用方法和`get()`相似：\n\n```python\n>>> requests.post('https://httpbin.org/post', data={'key':'value'})\n>>> requests.put('https://httpbin.org/put', data={'key':'value'})\n>>> requests.delete('https://httpbin.org/delete')\n>>> requests.head('https://httpbin.org/get')\n>>> requests.patch('https://httpbin.org/patch', data={'key':'value'})\n>>> requests.options('https://httpbin.org/get')\n```\n\n以下例子中，每一个函数调用都会对httpbin服务发起相应的HTTP方法。每一种方法，你都可以使用和之前相同的方式，查看服务器响应的内容：\n\n```python\n>>> response = requests.head('https://httpbin.org/get')\n>>> response.headers['Content-Type']\n'application/json'\n\n>>> response = requests.delete('https://httpbin.org/delete')\n>>> json_response = response.json()\n>>> json_response['args']\n{}\n```\n\n报头、响应正文、状态码和其它信息都会包含在每一种HTTP方法的`Response`中。接下来，你将更为详细地了解`POST`，`PUT`和`PATCH`方法，以及它们之间的区别。\n\n## 消息正文\n\n根据HTTP的规格说明，`POST`，`PUT`和`PATCH`都是通过将数据传递给消息正文，而不是通过将查询字符串传递给参数的方式。通过使用`requests`，你可以将`payload`传递给`data`参数。\n\n你可以将字典，元组为成员的列表或者文件对象传递给参数`data`。在请求的正文中，根据具体的类型需要，你可以采用不同的数据类型：\n\n例如，如果你请求的内容类型为`application/x-www-form-urlencoded`，那么你就可以将字典作为表格数据，传递给参数`data`。\n\n```python\n>>> requests.post('https://httpbin.org/post', data={'key':'value'})\n<Response [200]>\n```\n\n你也可以使用以元组为成员的列表：\n\n```python\n>>> requests.post('https://httpbin.org/post', data=[('key', 'value')])\n<Response [200]>\n```\n\n但是，如果你需要发送JSON格式的数据，你可以使用参数`json`。当你将值传递给参数`json`后，`requests`库会序列化你的数据和正确的`Content-Type`报头。\n\n[httpbin.org](https://httpbin.org/)是由`requests`库的开发者 [Kenneth Reitz](https://realpython.com/interview-kenneth-reitz/)创建的一个用于测试的网站。该网站可以用来测试`requests`发起的各种请求。例如，你可以用它来测试POST请求：\n\n```python\n>>> response = requests.post('https://httpbin.org/post', json={'key':'value'})\n>>> json_response = response.json()\n>>> json_response['data']\n'{\"key\": \"value\"}'\n>>> json_response['headers']['Content-Type']\n'application/json'\n```\n\n## 检查请求\n\n在发送请求到服务器之前，`requests`库会先将请求准备好。请求的准备包括验证报头以及序列化JSON内容。\n\n你可以通过`.request`来访问准备请求（`PrepareRequest`）：\n\n```python\n>>> response = requests.post('https://httpbin.org/post', json={'key':'value'})\n>>> response.request.headers['Content-Type']\n'application/json'\n>>> response.request.url\n'https://httpbin.org/post'\n>>> response.request.body\nb'{\"key\": \"value\"}'\n```\n\n检查准备请求可以让你访问各种信息，包括payload, URL, headers, authentication等等。\n\n## 认证\n\n认证可以让服务器知道你是谁。通常情况下，你可以通过`Authorization`报头提供你的身份信息，或者也可以通过自定义的报头来提供身份信息。在`requests`中，你可以使用参数`auth`来传递你的身份信息。\n\n下面以GitHub的[Authenticated User](https://developer.github.com/v3/users/#get-the-authenticated-user) API为例。为了访问该API，你需要通过一个元组来传递用户名和密码：\n\n```python\n>>> from getpass import getpass\n>>> requests.get('https://api.github.com/user', auth=('username', getpass()))\n<Response [200]>\n```\n\n如果身份信息正确，request请求就会返回成功过。如果request请求中没有包含身份信息，服务器就会返回`401 Unauthorized`：\n\n```python\n>>> requests.get('https://api.github.com/user')\n<Response [401]>\n```\n\n当你通过以上这种方式传递身份信息的时候，实际上`requests`使用的是HTTP的 [Basic access authentication scheme](https://en.wikipedia.org/wiki/Basic_access_authentication)。\n\n因此，你还可以使用`HTTPBasicAuth`来传递身份信息：\n\n```python\n>>> from requests.auth import HTTPBasicAuth\n>>> from getpass import getpass\n>>> requests.get(\n...     'https://api.github.com/user',\n...     auth=HTTPBasicAuth('username', getpass())\n... )\n<Response [200]>\n```\n\n除了Basic认证方式以外，`requests`还支持其它认证方式，例如`HTTPDigestAuth`和`HTTPProxyAuth`。\n\n你甚至还可以提供自定义的认证方式。但是，你必须首先创建一个继承`AuthBase`的子类。然后，你需要定义`__call__()`函数：\n\n```python\nimport requests\nfrom requests.auth import AuthBase\n\nclass TokenAuth(AuthBase):\n    \"\"\"Implements a custom authentication scheme.\"\"\"\n\n    def __init__(self, token):\n        self.token = token\n\n    def __call__(self, r):\n        \"\"\"Attach an API token to a custom auth header.\"\"\"\n        r.headers['X-TokenAuth'] = f'{self.token}'  # Python 3.6+\n        return r\n\n\nrequests.get('https://httpbin.org/get', auth=TokenAuth('12345abcde-token'))\n```\n\n以上例子中，自定义的类`TokenAuth`会收到一个Token，然后将收到的token放到`x-TokenAuth`报头中。\n\n不健全的认证机制会导致安全隐患，所以除非有特殊需求，否则应该使用成熟的认证机制，比如Basic或者OAuth。\n\n## SSL证书验证\n\n任何时候，当发送和接收的信息比较机密，安全往往是最重要的。因此，当你访问安全站点的时候，都会通过SSL建立安全连接，这时候对服务器的SSL证书进行验证显得尤为重要。\n\n默认情况下，`requests`已经为你执行了SSL证书的验证。但是，在某些情况下，你可能希望改变这种默认的行为。\n\n如果你想要关闭SSL证书的验证，你可以将参数`verify`设置为`False`：\n\n```python\n>>> requests.get('https://api.github.com', verify=False)\nInsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings\n  InsecureRequestWarning)\n<Response [200]>\n```\n\n当你正在访问一个不安全的站点时，`requests`会发出警告信息提醒你。\n\n> 注意：`requests`使用[`certifi`](http://docs.python-requests.org/en/master/user/advanced/#ca-certificates)来提供SSL证书的颁发机构（ Certificate Authorities）。这可以让`requests`知道有哪些可以信任的证书颁发机构。因此，你需要定期更新`certifi`来保证安全性。\n\n## 性能\n\n当在生产环境中使用`requests`的时候，特别需要考虑性能的影响。`requests`库的一些特性，例如超时控制（timeout control），会话（sessions）和重试限制（retry limits）可以使得应用运行得更流畅。\n\n### Timeouts\n\n当你向服务发送请求以后，你得应用将会等待服务端的响应，得到响应以后，才会执行下一步操作。如果应用等待的时间太长，请求就会一直处于等待状态，导致用户体验变差，或者后台任务挂起。\n\n默认情况下，`requests`将会无限制地等待响应，所以你应该指定一个超时的时间值。你可以通过参数`timeout`来设置超时的时间值。`timeout`的值可以是整型或者浮点型，时间的单位是秒。\n\n```python\n>>> requests.get('https://api.github.com', timeout=1)\n<Response [200]>\n>>> requests.get('https://api.github.com', timeout=3.05)\n<Response [200]>\n```\n\n以上例子中，第一个请求的超时时间是1秒，第二个请求的超时时间是3.05秒。\n\n你还可以传递一个[元组](http://docs.python-requests.org/en/master/user/advanced/#timeouts)给参数`timeout`，元组中的第一个值是TCP连接的超时时间（客户端和服务器之间建立连接的时长，通常建议设置为比3的倍数大一点），第二个值是数据传输的超时时间（建立连接后，等待响应的超时时间）：\n\n```python\n>>> requests.get('https://api.github.com', timeout=(2, 5))\n<Response [200]>\n```\n\n如果请求建立连接的时间在2秒以内，建立连接后，接收数据的时间在5秒以内，那么就可以正常获取到响应。但是，如果请求超时，那么函数就会抛出一个`Timeout`的异常。\n\n```python\nimport requests\nfrom requests.exceptions import Timeout\n\ntry:\n    response = requests.get('https://api.github.com', timeout=1)\nexcept Timeout:\n    print('The request timed out')\nelse:\n    print('The request did not time out')\n```\n\n你的程序可以捕获这个`Timeout`的异常，并做相应的处理。\n\n### The Session Object\n\n到目前为止，你都是使用`requests`的`get()`和`post()`来发送请求。这些函数隐藏了一些细节，例如连接是如何建立以及管理的。\n\n实际上，这些细节都是由类`Session`来负责处理。如果你需要微调你的请求，或者改进性能，你需要直接使用`Session`的实例。\n\n会话主要是在一些列的请求中，保持持久的参数。例如，如果你想要在多个请求中使用相同的认证信息，你就可以使用会话：\n\n```python\nimport requests\nfrom getpass import getpass\n\n# By using a context manager, you can ensure the resources used by\n# the session will be released after use\nwith requests.Session() as session:\n    session.auth = ('username', getpass())\n\n    # Instead of requests.get(), you'll use session.get()\n    response = session.get('https://api.github.com/user')\n\n# You can inspect the response just like you did before\nprint(response.headers)\nprint(response.json())\n```\n\n每次你用session发起请求，一旦该会话在初始化时，设定了认证的身份信息，那么该身份信息就可以在多个requests中重复使用。\n\n通过session改进性能，主要是通过保持长连接的方式。当你的应用通过Session来发起请求，它就会在连接池中长时间保持该连接。当应用想要再次连接到同一个服务器的时候，就可以重复使用连接池中的连接，而不需要再新建连接。\n\n### Max Retries\n\n当请求失败的时候，你可能希望应用重新发起同样的请求。但是，`requests`默认并不会帮你重新发送请求。为了实现这个功能，你需要使用[Transport Adapter](http://docs.python-requests.org/en/master/user/advanced/#transport-adapters)。\n\nTransport Adapters可以让你为每一个需要访问的服务定义一组配置信息。例如，你想要所有访问`https://api.github.com`的请求失败后重复三次，你可以创建一个Transport Adapter，设置参数`max_retries`的值为3，并将其挂载到当前的会话上：\n\n```python\nimport requests\nfrom requests.adapters import HTTPAdapter\nfrom requests.exceptions import ConnectionError\n\ngithub_adapter = HTTPAdapter(max_retries=3)\n\nsession = requests.Session()\n\n# Use `github_adapter` for all requests to endpoints that start with this URL\nsession.mount('https://api.github.com', github_adapter)\n\ntry:\n    session.get('https://api.github.com')\nexcept ConnectionError as ce:\n    print(ce)\n```\n\n当你挂载github_adapter到会话的时候，会话会遵循该配置的设置。\n\n## 总结\n\n通过以上内容，你现在可以：\n\n- 发送不同的HTTP请求，例如：GET, POST, PUT\n- 通过修改报头，认证，查询字符串和消息这个问，自定义请求\n- 检查发送给服务器的数据，以及从服务器接收的数据\n- SSL证书验证\n- 通过max_retries, timeout, Sessions和Transport Adapters，更有效的使用`requests`\n","slug":"Python/Requests库使用指南","published":1,"updated":"2024-09-18T06:21:50.506Z","_id":"cm17gu7x000003tec3tsnfb1u","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>注：本文翻译自<a href=\"https://realpython.com/python-requests/\">Python’s Requests Library (Guide)</a>。</p>\n</blockquote>\n<p>在Python中，<code>requests</code>库是处理HTTP请求的标准。它使得复杂的HTTP请求变得简单、易用，用户只需要专注于处理与Web服务之间的交互过程，并获取所需的数据。</p>\n<p>通过本文，你可以学到许多<code>requests</code>库中的有用功能，并且可以根据实际的使用场景，定制和优化这些功能。你还会学到如何有效地使用<code>requests</code>库，避免由于网络的原因影响应用的响应速度。</p>\n<p>在本指南中，你将学到以下内容：</p>\n<ul>\n<li>最常见的HTTP方式</li>\n<li>定制HTTP请求中的报头和数据，使用查询字符和消息内容</li>\n<li>检查请求和响应中的数据</li>\n<li>发送认证请求</li>\n<li>配置请求，防止应用的响应速度变慢</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"开始使用requests\"><a href=\"#开始使用requests\" class=\"headerlink\" title=\"开始使用requests\"></a>开始使用requests</h2><p>首先，需要安装<code>requests</code>库：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$ </span><span class=\"language-bash\">pip install requests</span></span><br></pre></td></tr></table></figure>\n\n<p>安装完成后，需要先导入<code>requests</code>库：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"GET请求\"><a href=\"#GET请求\" class=\"headerlink\" title=\"GET请求\"></a>GET请求</h2><p>HTTP有很多种请求方式，例如GET和POST，不同的请求方式，所执行的操作是不同的。其中，GET是最常用的HTTP请求。GET主要是用来获取Web数据。如果发起一个GET请求，就会调用<code>requests.get()</code>。</p>\n<p>以下例子中，你可以看到通过调用<code>get()</code>发送GET请求给Github的<a href=\"https://developer.github.com/v3/#root-endpoint\">Root REST API</a>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.get(<span class=\"string\">&#x27;https://api.github.com&#x27;</span>)</span><br><span class=\"line\">&lt;Response [<span class=\"number\">200</span>]&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h2><p>通过发送GET请求以后，我们可以得到一个Response的对象。将该对象存储到一个变量中后，我们可以查看该对象的属性和方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response = requests.get(<span class=\"string\">&#x27;https://api.github.com&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>在以上例子中，我们将响应对象存储到<code>response</code>变量中。</p>\n<h3 id=\"状态码（Status-Codes）\"><a href=\"#状态码（Status-Codes）\" class=\"headerlink\" title=\"状态码（Status Codes）\"></a>状态码（Status Codes）</h3><p>从响应<code>Response</code>中首先可以获取状态码，通过状态码来判断请求是否成功。</p>\n<p>例如，如果状态码是<code>200 OK</code>，那么说明请求是成功的，但是如果状态码是<code>404 NOT FOUND</code>，则说明未找到需要获取的资源。关于状态码的详细说明，请参考文档：<a href=\"https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\">many other possible status codes</a></p>\n<p>通过访问响应<code>response</code>的属性<code>.status_code</code>，可以看到服务器返回的状态码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.status_code</span><br><span class=\"line\"><span class=\"number\">200</span></span><br></pre></td></tr></table></figure>\n\n<p><code>.status_code</code>返回的是<code>200</code>，说明请求时成功的，并且服务器返回了你需要获取的数据。</p>\n<p>有些情况下，你可能想要通过状态码来作为判断条件：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> response.status_code == <span class=\"number\">200</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Success!&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">elif</span> response.status_code == <span class=\"number\">404</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Not Found.&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>以上例子中，如果服务器返回<code>200</code>的状态码，那么程序就会打印<code>Success!</code>。如果服务器返回<code>404</code>的状态码，程序就会打印<code>Not Found.</code>。</p>\n<p><code>requests</code>提供了一种更为简便的方法。如果直接使用<code>Response</code>实例作为判断的条件，假设状态码在<code>200</code>和<code>400</code>之间，那么表达式就会被评估为<code>True</code>，否则就会被评估为<code>False</code>。</p>\n<p>因此，你可以将之前的例子改写如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> response:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Success!&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;An error has occurred.&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>技术细节：This <a href=\"https://docs.python.org/3/library/stdtypes.html#truth-value-testing\">Truth Value Test</a> is made possible because <a href=\"https://realpython.com/operator-function-overloading/#making-your-objects-truthy-or-falsey-using-bool\"><code>__bool__()</code> is an overloaded method</a> on <code>Response</code>.</p>\n<p>This means that the default behavior of <code>Response</code> has been redefined to take the status code into account when determining the truth value of the object.</p>\n</blockquote>\n<p>记住这种方式并不是检验状态码是否等于<code>200</code>，而是检验状态码是否在<code>200</code>到<code>400</code>之间，例如<code>204 NO CONTENT</code>和<code>304 NOT MODIFIED</code>，也被认为是请求成功的。</p>\n<p>例如，<code>204</code>是说明请求是成功的，但是返回的消息正文并没有任何内容。</p>\n<p>因此，如果只是为了知道请求是否成功，可以使用这种简便的方法，否则，建议还是根据具体的状态码来判断。</p>\n<p>有时候，可能你不希望用<code>if</code>语句来检查状态码，而是希望在请求失败的情况下，引发异常。那么你就可以使用<code>.raise_for_status()</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">from</span> requests.exceptions <span class=\"keyword\">import</span> HTTPError</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> url <span class=\"keyword\">in</span> [<span class=\"string\">&#x27;https://api.github.com&#x27;</span>, <span class=\"string\">&#x27;https://api.github.com/invalid&#x27;</span>]:</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        response = requests.get(url)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># If the response was successful, no Exception will be raised</span></span><br><span class=\"line\">        response.raise_for_status()</span><br><span class=\"line\">    <span class=\"keyword\">except</span> HTTPError <span class=\"keyword\">as</span> http_err:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;HTTP error occurred: <span class=\"subst\">&#123;http_err&#125;</span>&#x27;</span>)  <span class=\"comment\"># Python 3.6</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> err:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Other error occurred: <span class=\"subst\">&#123;err&#125;</span>&#x27;</span>)  <span class=\"comment\"># Python 3.6</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Success!&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>如果你调用<code>.raise_for_status()</code>，就会对某些失败的状态码引发<code>HTTPError</code>的异常错误。如果状态码显示请求是成功的，那么程序就不会引发异常。</p>\n<p>通过以上内容，你了解了很多关于如何处理状态码的知识。下面，你将看到如何查看服务器返回的具体数据内容。</p>\n<h3 id=\"内容（Content）\"><a href=\"#内容（Content）\" class=\"headerlink\" title=\"内容（Content）\"></a>内容（Content）</h3><p>GET请求得到的响应经常包含很多有价值的信息，如消息正文中的payload。通过使用<code>Response</code>的属性和方法，你可以用不同的格式来查看payload。</p>\n<p>用bytes的格式查看响应的内容，你可以使用<code>.content</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response = requests.get(<span class=\"string\">&#x27;https://api.github.com&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.content</span><br><span class=\"line\"><span class=\"string\">b&#x27;&#123;&quot;current_user_url&quot;:&quot;https://api.github.com/user&quot;,&quot;current_user_authorizations_html_url&quot;:&quot;https://github.com/settings/connections/applications&#123;/client_id&#125;&quot;,&quot;authorizations_url&quot;:&quot;https://api.github.com/authorizations&quot;,&quot;code_search_url&quot;:&quot;https://api.github.com/search/code?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;commit_search_url&quot;:&quot;https://api.github.com/search/commits?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;emails_url&quot;:&quot;https://api.github.com/user/emails&quot;,&quot;emojis_url&quot;:&quot;https://api.github.com/emojis&quot;,&quot;events_url&quot;:&quot;https://api.github.com/events&quot;,&quot;feeds_url&quot;:&quot;https://api.github.com/feeds&quot;,&quot;followers_url&quot;:&quot;https://api.github.com/user/followers&quot;,&quot;following_url&quot;:&quot;https://api.github.com/user/following&#123;/target&#125;&quot;,&quot;gists_url&quot;:&quot;https://api.github.com/gists&#123;/gist_id&#125;&quot;,&quot;hub_url&quot;:&quot;https://api.github.com/hub&quot;,&quot;issue_search_url&quot;:&quot;https://api.github.com/search/issues?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;issues_url&quot;:&quot;https://api.github.com/issues&quot;,&quot;keys_url&quot;:&quot;https://api.github.com/user/keys&quot;,&quot;notifications_url&quot;:&quot;https://api.github.com/notifications&quot;,&quot;organization_repositories_url&quot;:&quot;https://api.github.com/orgs/&#123;org&#125;/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;organization_url&quot;:&quot;https://api.github.com/orgs/&#123;org&#125;&quot;,&quot;public_gists_url&quot;:&quot;https://api.github.com/gists/public&quot;,&quot;rate_limit_url&quot;:&quot;https://api.github.com/rate_limit&quot;,&quot;repository_url&quot;:&quot;https://api.github.com/repos/&#123;owner&#125;/&#123;repo&#125;&quot;,&quot;repository_search_url&quot;:&quot;https://api.github.com/search/repositories?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;current_user_repositories_url&quot;:&quot;https://api.github.com/user/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;starred_url&quot;:&quot;https://api.github.com/user/starred&#123;/owner&#125;&#123;/repo&#125;&quot;,&quot;starred_gists_url&quot;:&quot;https://api.github.com/gists/starred&quot;,&quot;team_url&quot;:&quot;https://api.github.com/teams&quot;,&quot;user_url&quot;:&quot;https://api.github.com/users/&#123;user&#125;&quot;,&quot;user_organizations_url&quot;:&quot;https://api.github.com/user/orgs&quot;,&quot;user_repositories_url&quot;:&quot;https://api.github.com/users/&#123;user&#125;/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;user_search_url&quot;:&quot;https://api.github.com/search/users?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>通过<code>.content</code>读取到的是字节格式的payload，如果你想要将其转换成UTF-8编码的字符串，你可以使用<code>.text</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.text</span><br><span class=\"line\"><span class=\"string\">&#x27;&#123;&quot;current_user_url&quot;:&quot;https://api.github.com/user&quot;,&quot;current_user_authorizations_html_url&quot;:&quot;https://github.com/settings/connections/applications&#123;/client_id&#125;&quot;,&quot;authorizations_url&quot;:&quot;https://api.github.com/authorizations&quot;,&quot;code_search_url&quot;:&quot;https://api.github.com/search/code?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;commit_search_url&quot;:&quot;https://api.github.com/search/commits?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;emails_url&quot;:&quot;https://api.github.com/user/emails&quot;,&quot;emojis_url&quot;:&quot;https://api.github.com/emojis&quot;,&quot;events_url&quot;:&quot;https://api.github.com/events&quot;,&quot;feeds_url&quot;:&quot;https://api.github.com/feeds&quot;,&quot;followers_url&quot;:&quot;https://api.github.com/user/followers&quot;,&quot;following_url&quot;:&quot;https://api.github.com/user/following&#123;/target&#125;&quot;,&quot;gists_url&quot;:&quot;https://api.github.com/gists&#123;/gist_id&#125;&quot;,&quot;hub_url&quot;:&quot;https://api.github.com/hub&quot;,&quot;issue_search_url&quot;:&quot;https://api.github.com/search/issues?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;issues_url&quot;:&quot;https://api.github.com/issues&quot;,&quot;keys_url&quot;:&quot;https://api.github.com/user/keys&quot;,&quot;notifications_url&quot;:&quot;https://api.github.com/notifications&quot;,&quot;organization_repositories_url&quot;:&quot;https://api.github.com/orgs/&#123;org&#125;/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;organization_url&quot;:&quot;https://api.github.com/orgs/&#123;org&#125;&quot;,&quot;public_gists_url&quot;:&quot;https://api.github.com/gists/public&quot;,&quot;rate_limit_url&quot;:&quot;https://api.github.com/rate_limit&quot;,&quot;repository_url&quot;:&quot;https://api.github.com/repos/&#123;owner&#125;/&#123;repo&#125;&quot;,&quot;repository_search_url&quot;:&quot;https://api.github.com/search/repositories?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;current_user_repositories_url&quot;:&quot;https://api.github.com/user/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;starred_url&quot;:&quot;https://api.github.com/user/starred&#123;/owner&#125;&#123;/repo&#125;&quot;,&quot;starred_gists_url&quot;:&quot;https://api.github.com/gists/starred&quot;,&quot;team_url&quot;:&quot;https://api.github.com/teams&quot;,&quot;user_url&quot;:&quot;https://api.github.com/users/&#123;user&#125;&quot;,&quot;user_organizations_url&quot;:&quot;https://api.github.com/user/orgs&quot;,&quot;user_repositories_url&quot;:&quot;https://api.github.com/users/&#123;user&#125;/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;user_search_url&quot;:&quot;https://api.github.com/search/users?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>因为将<code>bytes</code>转换成<code>str</code>需要指定编码的方式，<code>requests</code>会根据响应中的<code>hearders</code>内容来猜测编码的方式，或者，你也可以通过设置<code>.encoding</code>指定编码的方式：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.encoding = <span class=\"string\">&#x27;utf-8&#x27;</span> <span class=\"comment\"># Optional: requests infers this internally</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.text</span><br><span class=\"line\"><span class=\"string\">&#x27;&#123;&quot;current_user_url&quot;:&quot;https://api.github.com/user&quot;,&quot;current_user_authorizations_html_url&quot;:&quot;https://github.com/settings/connections/applications&#123;/client_id&#125;&quot;,&quot;authorizations_url&quot;:&quot;https://api.github.com/authorizations&quot;,&quot;code_search_url&quot;:&quot;https://api.github.com/search/code?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;commit_search_url&quot;:&quot;https://api.github.com/search/commits?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;emails_url&quot;:&quot;https://api.github.com/user/emails&quot;,&quot;emojis_url&quot;:&quot;https://api.github.com/emojis&quot;,&quot;events_url&quot;:&quot;https://api.github.com/events&quot;,&quot;feeds_url&quot;:&quot;https://api.github.com/feeds&quot;,&quot;followers_url&quot;:&quot;https://api.github.com/user/followers&quot;,&quot;following_url&quot;:&quot;https://api.github.com/user/following&#123;/target&#125;&quot;,&quot;gists_url&quot;:&quot;https://api.github.com/gists&#123;/gist_id&#125;&quot;,&quot;hub_url&quot;:&quot;https://api.github.com/hub&quot;,&quot;issue_search_url&quot;:&quot;https://api.github.com/search/issues?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;issues_url&quot;:&quot;https://api.github.com/issues&quot;,&quot;keys_url&quot;:&quot;https://api.github.com/user/keys&quot;,&quot;notifications_url&quot;:&quot;https://api.github.com/notifications&quot;,&quot;organization_repositories_url&quot;:&quot;https://api.github.com/orgs/&#123;org&#125;/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;organization_url&quot;:&quot;https://api.github.com/orgs/&#123;org&#125;&quot;,&quot;public_gists_url&quot;:&quot;https://api.github.com/gists/public&quot;,&quot;rate_limit_url&quot;:&quot;https://api.github.com/rate_limit&quot;,&quot;repository_url&quot;:&quot;https://api.github.com/repos/&#123;owner&#125;/&#123;repo&#125;&quot;,&quot;repository_search_url&quot;:&quot;https://api.github.com/search/repositories?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;current_user_repositories_url&quot;:&quot;https://api.github.com/user/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;starred_url&quot;:&quot;https://api.github.com/user/starred&#123;/owner&#125;&#123;/repo&#125;&quot;,&quot;starred_gists_url&quot;:&quot;https://api.github.com/gists/starred&quot;,&quot;team_url&quot;:&quot;https://api.github.com/teams&quot;,&quot;user_url&quot;:&quot;https://api.github.com/users/&#123;user&#125;&quot;,&quot;user_organizations_url&quot;:&quot;https://api.github.com/user/orgs&quot;,&quot;user_repositories_url&quot;:&quot;https://api.github.com/users/&#123;user&#125;/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;user_search_url&quot;:&quot;https://api.github.com/search/users?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果你仔细看一下响应的内容，你会发现实际上是序列化的<code>JSON</code>内容。因此，你可以通过<code>.text</code>的方式先获取字符串，然后再通过<a href=\"https://realpython.com/python-json/#deserializing-json\"><code>json.loads()</code></a>的方式获取字典。其实，还有一种更为简单的方法，可以使用<code>.json()</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.json()</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;current_user_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/user&#x27;</span>, <span class=\"string\">&#x27;current_user_authorizations_html_url&#x27;</span>: <span class=\"string\">&#x27;https://github.com/settings/connections/applications&#123;/client_id&#125;&#x27;</span>, <span class=\"string\">&#x27;authorizations_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/authorizations&#x27;</span>, <span class=\"string\">&#x27;code_search_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/search/code?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&#x27;</span>, <span class=\"string\">&#x27;commit_search_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/search/commits?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&#x27;</span>, <span class=\"string\">&#x27;emails_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/user/emails&#x27;</span>, <span class=\"string\">&#x27;emojis_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/emojis&#x27;</span>, <span class=\"string\">&#x27;events_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/events&#x27;</span>, <span class=\"string\">&#x27;feeds_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/feeds&#x27;</span>, <span class=\"string\">&#x27;followers_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/user/followers&#x27;</span>, <span class=\"string\">&#x27;following_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/user/following&#123;/target&#125;&#x27;</span>, <span class=\"string\">&#x27;gists_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/gists&#123;/gist_id&#125;&#x27;</span>, <span class=\"string\">&#x27;hub_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/hub&#x27;</span>, <span class=\"string\">&#x27;issue_search_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/search/issues?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&#x27;</span>, <span class=\"string\">&#x27;issues_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/issues&#x27;</span>, <span class=\"string\">&#x27;keys_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/user/keys&#x27;</span>, <span class=\"string\">&#x27;notifications_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/notifications&#x27;</span>, <span class=\"string\">&#x27;organization_repositories_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/orgs/&#123;org&#125;/repos&#123;?type,page,per_page,sort&#125;&#x27;</span>, <span class=\"string\">&#x27;organization_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/orgs/&#123;org&#125;&#x27;</span>, <span class=\"string\">&#x27;public_gists_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/gists/public&#x27;</span>, <span class=\"string\">&#x27;rate_limit_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/rate_limit&#x27;</span>, <span class=\"string\">&#x27;repository_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/repos/&#123;owner&#125;/&#123;repo&#125;&#x27;</span>, <span class=\"string\">&#x27;repository_search_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/search/repositories?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&#x27;</span>, <span class=\"string\">&#x27;current_user_repositories_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/user/repos&#123;?type,page,per_page,sort&#125;&#x27;</span>, <span class=\"string\">&#x27;starred_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/user/starred&#123;/owner&#125;&#123;/repo&#125;&#x27;</span>, <span class=\"string\">&#x27;starred_gists_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/gists/starred&#x27;</span>, <span class=\"string\">&#x27;team_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/teams&#x27;</span>, <span class=\"string\">&#x27;user_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/users/&#123;user&#125;&#x27;</span>, <span class=\"string\">&#x27;user_organizations_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/user/orgs&#x27;</span>, <span class=\"string\">&#x27;user_repositories_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/users/&#123;user&#125;/repos&#123;?type,page,per_page,sort&#125;&#x27;</span>, <span class=\"string\">&#x27;user_search_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/search/users?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>.json()</code>返回的结果是一个字典，因此你可以通过键来访问字典中的值。</p>\n<p>除了状态码和消息正文，你还可以查看响应中的Headers。</p>\n<h2 id=\"报头（Headers）\"><a href=\"#报头（Headers）\" class=\"headerlink\" title=\"报头（Headers）\"></a>报头（Headers）</h2><p>响应中的报头通常包含很多有用的信息，例如内容类型，缓存内容的时间限制。</p>\n<p>可以通过<code>.headers</code>来查看报头的内容：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.headers</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;Server&#x27;</span>: <span class=\"string\">&#x27;GitHub.com&#x27;</span>, <span class=\"string\">&#x27;Date&#x27;</span>: <span class=\"string\">&#x27;Mon, 10 Dec 2018 17:49:54 GMT&#x27;</span>, <span class=\"string\">&#x27;Content-Type&#x27;</span>: <span class=\"string\">&#x27;application/json; charset=utf-8&#x27;</span>, <span class=\"string\">&#x27;Transfer-Encoding&#x27;</span>: <span class=\"string\">&#x27;chunked&#x27;</span>, <span class=\"string\">&#x27;Status&#x27;</span>: <span class=\"string\">&#x27;200 OK&#x27;</span>, <span class=\"string\">&#x27;X-RateLimit-Limit&#x27;</span>: <span class=\"string\">&#x27;60&#x27;</span>, <span class=\"string\">&#x27;X-RateLimit-Remaining&#x27;</span>: <span class=\"string\">&#x27;59&#x27;</span>, <span class=\"string\">&#x27;X-RateLimit-Reset&#x27;</span>: <span class=\"string\">&#x27;1544467794&#x27;</span>, <span class=\"string\">&#x27;Cache-Control&#x27;</span>: <span class=\"string\">&#x27;public, max-age=60, s-maxage=60&#x27;</span>, <span class=\"string\">&#x27;Vary&#x27;</span>: <span class=\"string\">&#x27;Accept&#x27;</span>, <span class=\"string\">&#x27;ETag&#x27;</span>: <span class=\"string\">&#x27;W/&quot;7dc470913f1fe9bb6c7355b50a0737bc&quot;&#x27;</span>, <span class=\"string\">&#x27;X-GitHub-Media-Type&#x27;</span>: <span class=\"string\">&#x27;github.v3; format=json&#x27;</span>, <span class=\"string\">&#x27;Access-Control-Expose-Headers&#x27;</span>: <span class=\"string\">&#x27;ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type&#x27;</span>, <span class=\"string\">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class=\"string\">&#x27;*&#x27;</span>, <span class=\"string\">&#x27;Strict-Transport-Security&#x27;</span>: <span class=\"string\">&#x27;max-age=31536000; includeSubdomains; preload&#x27;</span>, <span class=\"string\">&#x27;X-Frame-Options&#x27;</span>: <span class=\"string\">&#x27;deny&#x27;</span>, <span class=\"string\">&#x27;X-Content-Type-Options&#x27;</span>: <span class=\"string\">&#x27;nosniff&#x27;</span>, <span class=\"string\">&#x27;X-XSS-Protection&#x27;</span>: <span class=\"string\">&#x27;1; mode=block&#x27;</span>, <span class=\"string\">&#x27;Referrer-Policy&#x27;</span>: <span class=\"string\">&#x27;origin-when-cross-origin, strict-origin-when-cross-origin&#x27;</span>, <span class=\"string\">&#x27;Content-Security-Policy&#x27;</span>: <span class=\"string\">&quot;default-src &#x27;none&#x27;&quot;</span>, <span class=\"string\">&#x27;Content-Encoding&#x27;</span>: <span class=\"string\">&#x27;gzip&#x27;</span>, <span class=\"string\">&#x27;X-GitHub-Request-Id&#x27;</span>: <span class=\"string\">&#x27;E439:4581:CF2351:1CA3E06:5C0EA741&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>.headers</code>返回的是字典类型的<strong>对象</strong>，因此，你可以像访问字典一样来获取值：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.headers[<span class=\"string\">&#x27;Content-Type&#x27;</span>]</span><br><span class=\"line\"><span class=\"string\">&#x27;application/json; charset=utf-8&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>headers对象有一个特殊的地方。由于HTTP标准定义headers不区分大小写，所以，我们访问headers的时候，不需要担心大小写：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.headers[<span class=\"string\">&#x27;content-type&#x27;</span>]</span><br><span class=\"line\"><span class=\"string\">&#x27;application/json; charset=utf-8&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>以上例子中，无论使用<code>content-type</code>还是<code>Content-Type</code>，你都能得到相同的结果。</p>\n<h2 id=\"查询字符串参数（Query-String-Parameters）\"><a href=\"#查询字符串参数（Query-String-Parameters）\" class=\"headerlink\" title=\"查询字符串参数（Query String Parameters）\"></a>查询字符串参数（Query String Parameters）</h2><p>通过在URL中传递查询字符串参数，可以定制GET请求。在方法<code>get()</code>中，可以传递参数<code>params</code>。例如，你可以使用GitHub的查询API来查找<code>requests</code>库。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Search GitHub&#x27;s repositories for requests</span></span><br><span class=\"line\">response = requests.get(</span><br><span class=\"line\">    <span class=\"string\">&#x27;https://api.github.com/search/repositories&#x27;</span>,</span><br><span class=\"line\">    params=&#123;<span class=\"string\">&#x27;q&#x27;</span>: <span class=\"string\">&#x27;requests+language:python&#x27;</span>&#125;,</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Inspect some attributes of the `requests` repository</span></span><br><span class=\"line\">json_response = response.json()</span><br><span class=\"line\">repository = json_response[<span class=\"string\">&#x27;items&#x27;</span>][<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Repository name: <span class=\"subst\">&#123;repository[<span class=\"string\">&quot;name&quot;</span>]&#125;</span>&#x27;</span>)  <span class=\"comment\"># Python 3.6+</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Repository description: <span class=\"subst\">&#123;repository[<span class=\"string\">&quot;description&quot;</span>]&#125;</span>&#x27;</span>)  <span class=\"comment\"># Python 3.6+</span></span><br></pre></td></tr></table></figure>\n\n<p>在方法<code>.get()</code>中，通过将字典<code>&#123;&#39;q&#39;: &#39;requests+language:python&#39;&#125;</code>传递给参数<code>params</code>，你可以改变从查询API返回的结果。</p>\n<p>你也可以用字典作为参数<code>params</code>的值，也可以使用以元组为成员的数组作为参数<code>params</code>的值：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.get(</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"string\">&#x27;https://api.github.com/search/repositories&#x27;</span>,</span><br><span class=\"line\"><span class=\"meta\">... </span>    params=[(<span class=\"string\">&#x27;q&#x27;</span>, <span class=\"string\">&#x27;requests+language:python&#x27;</span>)],</span><br><span class=\"line\"><span class=\"meta\">... </span>)</span><br><span class=\"line\">&lt;Response [<span class=\"number\">200</span>]&gt;</span><br></pre></td></tr></table></figure>\n\n<p>甚至，你还可以传递bytes作为值传递给参数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.get(</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"string\">&#x27;https://api.github.com/search/repositories&#x27;</span>,</span><br><span class=\"line\"><span class=\"meta\">... </span>    params=<span class=\"string\">b&#x27;q=requests+language:python&#x27;</span>,</span><br><span class=\"line\"><span class=\"meta\">... </span>)</span><br><span class=\"line\">&lt;Response [<span class=\"number\">200</span>]&gt;</span><br></pre></td></tr></table></figure>\n\n<p>查询字符串对于自定义GET请求非常有用。同时，你还可以通过添加或者修改报头来自定义GET请求。</p>\n<h2 id=\"请求报头（Request-Headers）\"><a href=\"#请求报头（Request-Headers）\" class=\"headerlink\" title=\"请求报头（Request Headers）\"></a>请求报头（Request Headers）</h2><p>在方法<code>.get()</code>中，你可以通过将字典作为值传递给参数<code>headers</code>的方式，来自定义报头。例如，在之前的查询例子中，你可以通过在<code>Accept</code>报头中指定<code>text-match</code>类型：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">response = requests.get(</span><br><span class=\"line\">    <span class=\"string\">&#x27;https://api.github.com/search/repositories&#x27;</span>,</span><br><span class=\"line\">    params=&#123;<span class=\"string\">&#x27;q&#x27;</span>: <span class=\"string\">&#x27;requests+language:python&#x27;</span>&#125;,</span><br><span class=\"line\">    headers=&#123;<span class=\"string\">&#x27;Accept&#x27;</span>: <span class=\"string\">&#x27;application/vnd.github.v3.text-match+json&#x27;</span>&#125;,</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># View the new `text-matches` array which provides information</span></span><br><span class=\"line\"><span class=\"comment\"># about your search term within the results</span></span><br><span class=\"line\">json_response = response.json()</span><br><span class=\"line\">repository = json_response[<span class=\"string\">&#x27;items&#x27;</span>][<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Text matches: <span class=\"subst\">&#123;repository[<span class=\"string\">&quot;text_matches&quot;</span>]&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><code>Accept</code>报头可以告诉服务器，你的应用可以处理的消息正文类型。在本例中，你使用的报头值是<code>application/vnd.github.v3.text-match+json</code>，这是GitHub网站<code>Accept</code>报头的专有属性，正文内容是一种特殊的JSON格式。</p>\n<p>在学习其它自定义请求的方式之前，我们先简单了解一下其它的HTTP方法。</p>\n<h2 id=\"其它的HTTP方法\"><a href=\"#其它的HTTP方法\" class=\"headerlink\" title=\"其它的HTTP方法\"></a>其它的HTTP方法</h2><p>除了GET以前，HTTP还支持<code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>HEAD</code>, <code>PATCH</code>和<code>OPTIONS</code>。在<code>requests</code>库中给，这些方法的使用方法和<code>get()</code>相似：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.post(<span class=\"string\">&#x27;https://httpbin.org/post&#x27;</span>, data=&#123;<span class=\"string\">&#x27;key&#x27;</span>:<span class=\"string\">&#x27;value&#x27;</span>&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.put(<span class=\"string\">&#x27;https://httpbin.org/put&#x27;</span>, data=&#123;<span class=\"string\">&#x27;key&#x27;</span>:<span class=\"string\">&#x27;value&#x27;</span>&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.delete(<span class=\"string\">&#x27;https://httpbin.org/delete&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.head(<span class=\"string\">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.patch(<span class=\"string\">&#x27;https://httpbin.org/patch&#x27;</span>, data=&#123;<span class=\"string\">&#x27;key&#x27;</span>:<span class=\"string\">&#x27;value&#x27;</span>&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.options(<span class=\"string\">&#x27;https://httpbin.org/get&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>以下例子中，每一个函数调用都会对httpbin服务发起相应的HTTP方法。每一种方法，你都可以使用和之前相同的方式，查看服务器响应的内容：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response = requests.head(<span class=\"string\">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.headers[<span class=\"string\">&#x27;Content-Type&#x27;</span>]</span><br><span class=\"line\"><span class=\"string\">&#x27;application/json&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response = requests.delete(<span class=\"string\">&#x27;https://httpbin.org/delete&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json_response = response.json()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json_response[<span class=\"string\">&#x27;args&#x27;</span>]</span><br><span class=\"line\">&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>报头、响应正文、状态码和其它信息都会包含在每一种HTTP方法的<code>Response</code>中。接下来，你将更为详细地了解<code>POST</code>，<code>PUT</code>和<code>PATCH</code>方法，以及它们之间的区别。</p>\n<h2 id=\"消息正文\"><a href=\"#消息正文\" class=\"headerlink\" title=\"消息正文\"></a>消息正文</h2><p>根据HTTP的规格说明，<code>POST</code>，<code>PUT</code>和<code>PATCH</code>都是通过将数据传递给消息正文，而不是通过将查询字符串传递给参数的方式。通过使用<code>requests</code>，你可以将<code>payload</code>传递给<code>data</code>参数。</p>\n<p>你可以将字典，元组为成员的列表或者文件对象传递给参数<code>data</code>。在请求的正文中，根据具体的类型需要，你可以采用不同的数据类型：</p>\n<p>例如，如果你请求的内容类型为<code>application/x-www-form-urlencoded</code>，那么你就可以将字典作为表格数据，传递给参数<code>data</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.post(<span class=\"string\">&#x27;https://httpbin.org/post&#x27;</span>, data=&#123;<span class=\"string\">&#x27;key&#x27;</span>:<span class=\"string\">&#x27;value&#x27;</span>&#125;)</span><br><span class=\"line\">&lt;Response [<span class=\"number\">200</span>]&gt;</span><br></pre></td></tr></table></figure>\n\n<p>你也可以使用以元组为成员的列表：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.post(<span class=\"string\">&#x27;https://httpbin.org/post&#x27;</span>, data=[(<span class=\"string\">&#x27;key&#x27;</span>, <span class=\"string\">&#x27;value&#x27;</span>)])</span><br><span class=\"line\">&lt;Response [<span class=\"number\">200</span>]&gt;</span><br></pre></td></tr></table></figure>\n\n<p>但是，如果你需要发送JSON格式的数据，你可以使用参数<code>json</code>。当你将值传递给参数<code>json</code>后，<code>requests</code>库会序列化你的数据和正确的<code>Content-Type</code>报头。</p>\n<p><a href=\"https://httpbin.org/\">httpbin.org</a>是由<code>requests</code>库的开发者 <a href=\"https://realpython.com/interview-kenneth-reitz/\">Kenneth Reitz</a>创建的一个用于测试的网站。该网站可以用来测试<code>requests</code>发起的各种请求。例如，你可以用它来测试POST请求：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response = requests.post(<span class=\"string\">&#x27;https://httpbin.org/post&#x27;</span>, json=&#123;<span class=\"string\">&#x27;key&#x27;</span>:<span class=\"string\">&#x27;value&#x27;</span>&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json_response = response.json()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json_response[<span class=\"string\">&#x27;data&#x27;</span>]</span><br><span class=\"line\"><span class=\"string\">&#x27;&#123;&quot;key&quot;: &quot;value&quot;&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json_response[<span class=\"string\">&#x27;headers&#x27;</span>][<span class=\"string\">&#x27;Content-Type&#x27;</span>]</span><br><span class=\"line\"><span class=\"string\">&#x27;application/json&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"检查请求\"><a href=\"#检查请求\" class=\"headerlink\" title=\"检查请求\"></a>检查请求</h2><p>在发送请求到服务器之前，<code>requests</code>库会先将请求准备好。请求的准备包括验证报头以及序列化JSON内容。</p>\n<p>你可以通过<code>.request</code>来访问准备请求（<code>PrepareRequest</code>）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response = requests.post(<span class=\"string\">&#x27;https://httpbin.org/post&#x27;</span>, json=&#123;<span class=\"string\">&#x27;key&#x27;</span>:<span class=\"string\">&#x27;value&#x27;</span>&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.request.headers[<span class=\"string\">&#x27;Content-Type&#x27;</span>]</span><br><span class=\"line\"><span class=\"string\">&#x27;application/json&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.request.url</span><br><span class=\"line\"><span class=\"string\">&#x27;https://httpbin.org/post&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.request.body</span><br><span class=\"line\"><span class=\"string\">b&#x27;&#123;&quot;key&quot;: &quot;value&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>检查准备请求可以让你访问各种信息，包括payload, URL, headers, authentication等等。</p>\n<h2 id=\"认证\"><a href=\"#认证\" class=\"headerlink\" title=\"认证\"></a>认证</h2><p>认证可以让服务器知道你是谁。通常情况下，你可以通过<code>Authorization</code>报头提供你的身份信息，或者也可以通过自定义的报头来提供身份信息。在<code>requests</code>中，你可以使用参数<code>auth</code>来传递你的身份信息。</p>\n<p>下面以GitHub的<a href=\"https://developer.github.com/v3/users/#get-the-authenticated-user\">Authenticated User</a> API为例。为了访问该API，你需要通过一个元组来传递用户名和密码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> getpass <span class=\"keyword\">import</span> getpass</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.get(<span class=\"string\">&#x27;https://api.github.com/user&#x27;</span>, auth=(<span class=\"string\">&#x27;username&#x27;</span>, getpass()))</span><br><span class=\"line\">&lt;Response [<span class=\"number\">200</span>]&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果身份信息正确，request请求就会返回成功过。如果request请求中没有包含身份信息，服务器就会返回<code>401 Unauthorized</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.get(<span class=\"string\">&#x27;https://api.github.com/user&#x27;</span>)</span><br><span class=\"line\">&lt;Response [<span class=\"number\">401</span>]&gt;</span><br></pre></td></tr></table></figure>\n\n<p>当你通过以上这种方式传递身份信息的时候，实际上<code>requests</code>使用的是HTTP的 <a href=\"https://en.wikipedia.org/wiki/Basic_access_authentication\">Basic access authentication scheme</a>。</p>\n<p>因此，你还可以使用<code>HTTPBasicAuth</code>来传递身份信息：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> requests.auth <span class=\"keyword\">import</span> HTTPBasicAuth</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> getpass <span class=\"keyword\">import</span> getpass</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.get(</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"string\">&#x27;https://api.github.com/user&#x27;</span>,</span><br><span class=\"line\"><span class=\"meta\">... </span>    auth=HTTPBasicAuth(<span class=\"string\">&#x27;username&#x27;</span>, getpass())</span><br><span class=\"line\"><span class=\"meta\">... </span>)</span><br><span class=\"line\">&lt;Response [<span class=\"number\">200</span>]&gt;</span><br></pre></td></tr></table></figure>\n\n<p>除了Basic认证方式以外，<code>requests</code>还支持其它认证方式，例如<code>HTTPDigestAuth</code>和<code>HTTPProxyAuth</code>。</p>\n<p>你甚至还可以提供自定义的认证方式。但是，你必须首先创建一个继承<code>AuthBase</code>的子类。然后，你需要定义<code>__call__()</code>函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">from</span> requests.auth <span class=\"keyword\">import</span> AuthBase</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TokenAuth</span>(<span class=\"title class_ inherited__\">AuthBase</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Implements a custom authentication scheme.&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, token</span>):</span><br><span class=\"line\">        self.token = token</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__call__</span>(<span class=\"params\">self, r</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Attach an API token to a custom auth header.&quot;&quot;&quot;</span></span><br><span class=\"line\">        r.headers[<span class=\"string\">&#x27;X-TokenAuth&#x27;</span>] = <span class=\"string\">f&#x27;<span class=\"subst\">&#123;self.token&#125;</span>&#x27;</span>  <span class=\"comment\"># Python 3.6+</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> r</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">requests.get(<span class=\"string\">&#x27;https://httpbin.org/get&#x27;</span>, auth=TokenAuth(<span class=\"string\">&#x27;12345abcde-token&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>以上例子中，自定义的类<code>TokenAuth</code>会收到一个Token，然后将收到的token放到<code>x-TokenAuth</code>报头中。</p>\n<p>不健全的认证机制会导致安全隐患，所以除非有特殊需求，否则应该使用成熟的认证机制，比如Basic或者OAuth。</p>\n<h2 id=\"SSL证书验证\"><a href=\"#SSL证书验证\" class=\"headerlink\" title=\"SSL证书验证\"></a>SSL证书验证</h2><p>任何时候，当发送和接收的信息比较机密，安全往往是最重要的。因此，当你访问安全站点的时候，都会通过SSL建立安全连接，这时候对服务器的SSL证书进行验证显得尤为重要。</p>\n<p>默认情况下，<code>requests</code>已经为你执行了SSL证书的验证。但是，在某些情况下，你可能希望改变这种默认的行为。</p>\n<p>如果你想要关闭SSL证书的验证，你可以将参数<code>verify</code>设置为<code>False</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.get(<span class=\"string\">&#x27;https://api.github.com&#x27;</span>, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\">InsecureRequestWarning: Unverified HTTPS request <span class=\"keyword\">is</span> being made. Adding certificate verification <span class=\"keyword\">is</span> strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html<span class=\"comment\">#ssl-warnings</span></span><br><span class=\"line\">  InsecureRequestWarning)</span><br><span class=\"line\">&lt;Response [<span class=\"number\">200</span>]&gt;</span><br></pre></td></tr></table></figure>\n\n<p>当你正在访问一个不安全的站点时，<code>requests</code>会发出警告信息提醒你。</p>\n<blockquote>\n<p>注意：<code>requests</code>使用<a href=\"http://docs.python-requests.org/en/master/user/advanced/#ca-certificates\"><code>certifi</code></a>来提供SSL证书的颁发机构（ Certificate Authorities）。这可以让<code>requests</code>知道有哪些可以信任的证书颁发机构。因此，你需要定期更新<code>certifi</code>来保证安全性。</p>\n</blockquote>\n<h2 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h2><p>当在生产环境中使用<code>requests</code>的时候，特别需要考虑性能的影响。<code>requests</code>库的一些特性，例如超时控制（timeout control），会话（sessions）和重试限制（retry limits）可以使得应用运行得更流畅。</p>\n<h3 id=\"Timeouts\"><a href=\"#Timeouts\" class=\"headerlink\" title=\"Timeouts\"></a>Timeouts</h3><p>当你向服务发送请求以后，你得应用将会等待服务端的响应，得到响应以后，才会执行下一步操作。如果应用等待的时间太长，请求就会一直处于等待状态，导致用户体验变差，或者后台任务挂起。</p>\n<p>默认情况下，<code>requests</code>将会无限制地等待响应，所以你应该指定一个超时的时间值。你可以通过参数<code>timeout</code>来设置超时的时间值。<code>timeout</code>的值可以是整型或者浮点型，时间的单位是秒。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.get(<span class=\"string\">&#x27;https://api.github.com&#x27;</span>, timeout=<span class=\"number\">1</span>)</span><br><span class=\"line\">&lt;Response [<span class=\"number\">200</span>]&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.get(<span class=\"string\">&#x27;https://api.github.com&#x27;</span>, timeout=<span class=\"number\">3.05</span>)</span><br><span class=\"line\">&lt;Response [<span class=\"number\">200</span>]&gt;</span><br></pre></td></tr></table></figure>\n\n<p>以上例子中，第一个请求的超时时间是1秒，第二个请求的超时时间是3.05秒。</p>\n<p>你还可以传递一个<a href=\"http://docs.python-requests.org/en/master/user/advanced/#timeouts\">元组</a>给参数<code>timeout</code>，元组中的第一个值是TCP连接的超时时间（客户端和服务器之间建立连接的时长，通常建议设置为比3的倍数大一点），第二个值是数据传输的超时时间（建立连接后，等待响应的超时时间）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.get(<span class=\"string\">&#x27;https://api.github.com&#x27;</span>, timeout=(<span class=\"number\">2</span>, <span class=\"number\">5</span>))</span><br><span class=\"line\">&lt;Response [<span class=\"number\">200</span>]&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果请求建立连接的时间在2秒以内，建立连接后，接收数据的时间在5秒以内，那么就可以正常获取到响应。但是，如果请求超时，那么函数就会抛出一个<code>Timeout</code>的异常。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">from</span> requests.exceptions <span class=\"keyword\">import</span> Timeout</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    response = requests.get(<span class=\"string\">&#x27;https://api.github.com&#x27;</span>, timeout=<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">except</span> Timeout:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;The request timed out&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;The request did not time out&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>你的程序可以捕获这个<code>Timeout</code>的异常，并做相应的处理。</p>\n<h3 id=\"The-Session-Object\"><a href=\"#The-Session-Object\" class=\"headerlink\" title=\"The Session Object\"></a>The Session Object</h3><p>到目前为止，你都是使用<code>requests</code>的<code>get()</code>和<code>post()</code>来发送请求。这些函数隐藏了一些细节，例如连接是如何建立以及管理的。</p>\n<p>实际上，这些细节都是由类<code>Session</code>来负责处理。如果你需要微调你的请求，或者改进性能，你需要直接使用<code>Session</code>的实例。</p>\n<p>会话主要是在一些列的请求中，保持持久的参数。例如，如果你想要在多个请求中使用相同的认证信息，你就可以使用会话：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">from</span> getpass <span class=\"keyword\">import</span> getpass</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># By using a context manager, you can ensure the resources used by</span></span><br><span class=\"line\"><span class=\"comment\"># the session will be released after use</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> requests.Session() <span class=\"keyword\">as</span> session:</span><br><span class=\"line\">    session.auth = (<span class=\"string\">&#x27;username&#x27;</span>, getpass())</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Instead of requests.get(), you&#x27;ll use session.get()</span></span><br><span class=\"line\">    response = session.get(<span class=\"string\">&#x27;https://api.github.com/user&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># You can inspect the response just like you did before</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(response.headers)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(response.json())</span><br></pre></td></tr></table></figure>\n\n<p>每次你用session发起请求，一旦该会话在初始化时，设定了认证的身份信息，那么该身份信息就可以在多个requests中重复使用。</p>\n<p>通过session改进性能，主要是通过保持长连接的方式。当你的应用通过Session来发起请求，它就会在连接池中长时间保持该连接。当应用想要再次连接到同一个服务器的时候，就可以重复使用连接池中的连接，而不需要再新建连接。</p>\n<h3 id=\"Max-Retries\"><a href=\"#Max-Retries\" class=\"headerlink\" title=\"Max Retries\"></a>Max Retries</h3><p>当请求失败的时候，你可能希望应用重新发起同样的请求。但是，<code>requests</code>默认并不会帮你重新发送请求。为了实现这个功能，你需要使用<a href=\"http://docs.python-requests.org/en/master/user/advanced/#transport-adapters\">Transport Adapter</a>。</p>\n<p>Transport Adapters可以让你为每一个需要访问的服务定义一组配置信息。例如，你想要所有访问<code>https://api.github.com</code>的请求失败后重复三次，你可以创建一个Transport Adapter，设置参数<code>max_retries</code>的值为3，并将其挂载到当前的会话上：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">from</span> requests.adapters <span class=\"keyword\">import</span> HTTPAdapter</span><br><span class=\"line\"><span class=\"keyword\">from</span> requests.exceptions <span class=\"keyword\">import</span> ConnectionError</span><br><span class=\"line\"></span><br><span class=\"line\">github_adapter = HTTPAdapter(max_retries=<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">session = requests.Session()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Use `github_adapter` for all requests to endpoints that start with this URL</span></span><br><span class=\"line\">session.mount(<span class=\"string\">&#x27;https://api.github.com&#x27;</span>, github_adapter)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    session.get(<span class=\"string\">&#x27;https://api.github.com&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">except</span> ConnectionError <span class=\"keyword\">as</span> ce:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(ce)</span><br></pre></td></tr></table></figure>\n\n<p>当你挂载github_adapter到会话的时候，会话会遵循该配置的设置。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过以上内容，你现在可以：</p>\n<ul>\n<li>发送不同的HTTP请求，例如：GET, POST, PUT</li>\n<li>通过修改报头，认证，查询字符串和消息这个问，自定义请求</li>\n<li>检查发送给服务器的数据，以及从服务器接收的数据</li>\n<li>SSL证书验证</li>\n<li>通过max_retries, timeout, Sessions和Transport Adapters，更有效的使用<code>requests</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>注：本文翻译自<a href=\"https://realpython.com/python-requests/\">Python’s Requests Library (Guide)</a>。</p>\n</blockquote>\n<p>在Python中，<code>requests</code>库是处理HTTP请求的标准。它使得复杂的HTTP请求变得简单、易用，用户只需要专注于处理与Web服务之间的交互过程，并获取所需的数据。</p>\n<p>通过本文，你可以学到许多<code>requests</code>库中的有用功能，并且可以根据实际的使用场景，定制和优化这些功能。你还会学到如何有效地使用<code>requests</code>库，避免由于网络的原因影响应用的响应速度。</p>\n<p>在本指南中，你将学到以下内容：</p>\n<ul>\n<li>最常见的HTTP方式</li>\n<li>定制HTTP请求中的报头和数据，使用查询字符和消息内容</li>\n<li>检查请求和响应中的数据</li>\n<li>发送认证请求</li>\n<li>配置请求，防止应用的响应速度变慢</li>\n</ul>","more":"<h2 id=\"开始使用requests\"><a href=\"#开始使用requests\" class=\"headerlink\" title=\"开始使用requests\"></a>开始使用requests</h2><p>首先，需要安装<code>requests</code>库：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$ </span><span class=\"language-bash\">pip install requests</span></span><br></pre></td></tr></table></figure>\n\n<p>安装完成后，需要先导入<code>requests</code>库：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"GET请求\"><a href=\"#GET请求\" class=\"headerlink\" title=\"GET请求\"></a>GET请求</h2><p>HTTP有很多种请求方式，例如GET和POST，不同的请求方式，所执行的操作是不同的。其中，GET是最常用的HTTP请求。GET主要是用来获取Web数据。如果发起一个GET请求，就会调用<code>requests.get()</code>。</p>\n<p>以下例子中，你可以看到通过调用<code>get()</code>发送GET请求给Github的<a href=\"https://developer.github.com/v3/#root-endpoint\">Root REST API</a>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.get(<span class=\"string\">&#x27;https://api.github.com&#x27;</span>)</span><br><span class=\"line\">&lt;Response [<span class=\"number\">200</span>]&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h2><p>通过发送GET请求以后，我们可以得到一个Response的对象。将该对象存储到一个变量中后，我们可以查看该对象的属性和方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response = requests.get(<span class=\"string\">&#x27;https://api.github.com&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>在以上例子中，我们将响应对象存储到<code>response</code>变量中。</p>\n<h3 id=\"状态码（Status-Codes）\"><a href=\"#状态码（Status-Codes）\" class=\"headerlink\" title=\"状态码（Status Codes）\"></a>状态码（Status Codes）</h3><p>从响应<code>Response</code>中首先可以获取状态码，通过状态码来判断请求是否成功。</p>\n<p>例如，如果状态码是<code>200 OK</code>，那么说明请求是成功的，但是如果状态码是<code>404 NOT FOUND</code>，则说明未找到需要获取的资源。关于状态码的详细说明，请参考文档：<a href=\"https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\">many other possible status codes</a></p>\n<p>通过访问响应<code>response</code>的属性<code>.status_code</code>，可以看到服务器返回的状态码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.status_code</span><br><span class=\"line\"><span class=\"number\">200</span></span><br></pre></td></tr></table></figure>\n\n<p><code>.status_code</code>返回的是<code>200</code>，说明请求时成功的，并且服务器返回了你需要获取的数据。</p>\n<p>有些情况下，你可能想要通过状态码来作为判断条件：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> response.status_code == <span class=\"number\">200</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Success!&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">elif</span> response.status_code == <span class=\"number\">404</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Not Found.&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>以上例子中，如果服务器返回<code>200</code>的状态码，那么程序就会打印<code>Success!</code>。如果服务器返回<code>404</code>的状态码，程序就会打印<code>Not Found.</code>。</p>\n<p><code>requests</code>提供了一种更为简便的方法。如果直接使用<code>Response</code>实例作为判断的条件，假设状态码在<code>200</code>和<code>400</code>之间，那么表达式就会被评估为<code>True</code>，否则就会被评估为<code>False</code>。</p>\n<p>因此，你可以将之前的例子改写如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> response:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Success!&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;An error has occurred.&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>技术细节：This <a href=\"https://docs.python.org/3/library/stdtypes.html#truth-value-testing\">Truth Value Test</a> is made possible because <a href=\"https://realpython.com/operator-function-overloading/#making-your-objects-truthy-or-falsey-using-bool\"><code>__bool__()</code> is an overloaded method</a> on <code>Response</code>.</p>\n<p>This means that the default behavior of <code>Response</code> has been redefined to take the status code into account when determining the truth value of the object.</p>\n</blockquote>\n<p>记住这种方式并不是检验状态码是否等于<code>200</code>，而是检验状态码是否在<code>200</code>到<code>400</code>之间，例如<code>204 NO CONTENT</code>和<code>304 NOT MODIFIED</code>，也被认为是请求成功的。</p>\n<p>例如，<code>204</code>是说明请求是成功的，但是返回的消息正文并没有任何内容。</p>\n<p>因此，如果只是为了知道请求是否成功，可以使用这种简便的方法，否则，建议还是根据具体的状态码来判断。</p>\n<p>有时候，可能你不希望用<code>if</code>语句来检查状态码，而是希望在请求失败的情况下，引发异常。那么你就可以使用<code>.raise_for_status()</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">from</span> requests.exceptions <span class=\"keyword\">import</span> HTTPError</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> url <span class=\"keyword\">in</span> [<span class=\"string\">&#x27;https://api.github.com&#x27;</span>, <span class=\"string\">&#x27;https://api.github.com/invalid&#x27;</span>]:</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        response = requests.get(url)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># If the response was successful, no Exception will be raised</span></span><br><span class=\"line\">        response.raise_for_status()</span><br><span class=\"line\">    <span class=\"keyword\">except</span> HTTPError <span class=\"keyword\">as</span> http_err:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;HTTP error occurred: <span class=\"subst\">&#123;http_err&#125;</span>&#x27;</span>)  <span class=\"comment\"># Python 3.6</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> err:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Other error occurred: <span class=\"subst\">&#123;err&#125;</span>&#x27;</span>)  <span class=\"comment\"># Python 3.6</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Success!&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>如果你调用<code>.raise_for_status()</code>，就会对某些失败的状态码引发<code>HTTPError</code>的异常错误。如果状态码显示请求是成功的，那么程序就不会引发异常。</p>\n<p>通过以上内容，你了解了很多关于如何处理状态码的知识。下面，你将看到如何查看服务器返回的具体数据内容。</p>\n<h3 id=\"内容（Content）\"><a href=\"#内容（Content）\" class=\"headerlink\" title=\"内容（Content）\"></a>内容（Content）</h3><p>GET请求得到的响应经常包含很多有价值的信息，如消息正文中的payload。通过使用<code>Response</code>的属性和方法，你可以用不同的格式来查看payload。</p>\n<p>用bytes的格式查看响应的内容，你可以使用<code>.content</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response = requests.get(<span class=\"string\">&#x27;https://api.github.com&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.content</span><br><span class=\"line\"><span class=\"string\">b&#x27;&#123;&quot;current_user_url&quot;:&quot;https://api.github.com/user&quot;,&quot;current_user_authorizations_html_url&quot;:&quot;https://github.com/settings/connections/applications&#123;/client_id&#125;&quot;,&quot;authorizations_url&quot;:&quot;https://api.github.com/authorizations&quot;,&quot;code_search_url&quot;:&quot;https://api.github.com/search/code?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;commit_search_url&quot;:&quot;https://api.github.com/search/commits?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;emails_url&quot;:&quot;https://api.github.com/user/emails&quot;,&quot;emojis_url&quot;:&quot;https://api.github.com/emojis&quot;,&quot;events_url&quot;:&quot;https://api.github.com/events&quot;,&quot;feeds_url&quot;:&quot;https://api.github.com/feeds&quot;,&quot;followers_url&quot;:&quot;https://api.github.com/user/followers&quot;,&quot;following_url&quot;:&quot;https://api.github.com/user/following&#123;/target&#125;&quot;,&quot;gists_url&quot;:&quot;https://api.github.com/gists&#123;/gist_id&#125;&quot;,&quot;hub_url&quot;:&quot;https://api.github.com/hub&quot;,&quot;issue_search_url&quot;:&quot;https://api.github.com/search/issues?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;issues_url&quot;:&quot;https://api.github.com/issues&quot;,&quot;keys_url&quot;:&quot;https://api.github.com/user/keys&quot;,&quot;notifications_url&quot;:&quot;https://api.github.com/notifications&quot;,&quot;organization_repositories_url&quot;:&quot;https://api.github.com/orgs/&#123;org&#125;/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;organization_url&quot;:&quot;https://api.github.com/orgs/&#123;org&#125;&quot;,&quot;public_gists_url&quot;:&quot;https://api.github.com/gists/public&quot;,&quot;rate_limit_url&quot;:&quot;https://api.github.com/rate_limit&quot;,&quot;repository_url&quot;:&quot;https://api.github.com/repos/&#123;owner&#125;/&#123;repo&#125;&quot;,&quot;repository_search_url&quot;:&quot;https://api.github.com/search/repositories?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;current_user_repositories_url&quot;:&quot;https://api.github.com/user/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;starred_url&quot;:&quot;https://api.github.com/user/starred&#123;/owner&#125;&#123;/repo&#125;&quot;,&quot;starred_gists_url&quot;:&quot;https://api.github.com/gists/starred&quot;,&quot;team_url&quot;:&quot;https://api.github.com/teams&quot;,&quot;user_url&quot;:&quot;https://api.github.com/users/&#123;user&#125;&quot;,&quot;user_organizations_url&quot;:&quot;https://api.github.com/user/orgs&quot;,&quot;user_repositories_url&quot;:&quot;https://api.github.com/users/&#123;user&#125;/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;user_search_url&quot;:&quot;https://api.github.com/search/users?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>通过<code>.content</code>读取到的是字节格式的payload，如果你想要将其转换成UTF-8编码的字符串，你可以使用<code>.text</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.text</span><br><span class=\"line\"><span class=\"string\">&#x27;&#123;&quot;current_user_url&quot;:&quot;https://api.github.com/user&quot;,&quot;current_user_authorizations_html_url&quot;:&quot;https://github.com/settings/connections/applications&#123;/client_id&#125;&quot;,&quot;authorizations_url&quot;:&quot;https://api.github.com/authorizations&quot;,&quot;code_search_url&quot;:&quot;https://api.github.com/search/code?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;commit_search_url&quot;:&quot;https://api.github.com/search/commits?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;emails_url&quot;:&quot;https://api.github.com/user/emails&quot;,&quot;emojis_url&quot;:&quot;https://api.github.com/emojis&quot;,&quot;events_url&quot;:&quot;https://api.github.com/events&quot;,&quot;feeds_url&quot;:&quot;https://api.github.com/feeds&quot;,&quot;followers_url&quot;:&quot;https://api.github.com/user/followers&quot;,&quot;following_url&quot;:&quot;https://api.github.com/user/following&#123;/target&#125;&quot;,&quot;gists_url&quot;:&quot;https://api.github.com/gists&#123;/gist_id&#125;&quot;,&quot;hub_url&quot;:&quot;https://api.github.com/hub&quot;,&quot;issue_search_url&quot;:&quot;https://api.github.com/search/issues?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;issues_url&quot;:&quot;https://api.github.com/issues&quot;,&quot;keys_url&quot;:&quot;https://api.github.com/user/keys&quot;,&quot;notifications_url&quot;:&quot;https://api.github.com/notifications&quot;,&quot;organization_repositories_url&quot;:&quot;https://api.github.com/orgs/&#123;org&#125;/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;organization_url&quot;:&quot;https://api.github.com/orgs/&#123;org&#125;&quot;,&quot;public_gists_url&quot;:&quot;https://api.github.com/gists/public&quot;,&quot;rate_limit_url&quot;:&quot;https://api.github.com/rate_limit&quot;,&quot;repository_url&quot;:&quot;https://api.github.com/repos/&#123;owner&#125;/&#123;repo&#125;&quot;,&quot;repository_search_url&quot;:&quot;https://api.github.com/search/repositories?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;current_user_repositories_url&quot;:&quot;https://api.github.com/user/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;starred_url&quot;:&quot;https://api.github.com/user/starred&#123;/owner&#125;&#123;/repo&#125;&quot;,&quot;starred_gists_url&quot;:&quot;https://api.github.com/gists/starred&quot;,&quot;team_url&quot;:&quot;https://api.github.com/teams&quot;,&quot;user_url&quot;:&quot;https://api.github.com/users/&#123;user&#125;&quot;,&quot;user_organizations_url&quot;:&quot;https://api.github.com/user/orgs&quot;,&quot;user_repositories_url&quot;:&quot;https://api.github.com/users/&#123;user&#125;/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;user_search_url&quot;:&quot;https://api.github.com/search/users?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>因为将<code>bytes</code>转换成<code>str</code>需要指定编码的方式，<code>requests</code>会根据响应中的<code>hearders</code>内容来猜测编码的方式，或者，你也可以通过设置<code>.encoding</code>指定编码的方式：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.encoding = <span class=\"string\">&#x27;utf-8&#x27;</span> <span class=\"comment\"># Optional: requests infers this internally</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.text</span><br><span class=\"line\"><span class=\"string\">&#x27;&#123;&quot;current_user_url&quot;:&quot;https://api.github.com/user&quot;,&quot;current_user_authorizations_html_url&quot;:&quot;https://github.com/settings/connections/applications&#123;/client_id&#125;&quot;,&quot;authorizations_url&quot;:&quot;https://api.github.com/authorizations&quot;,&quot;code_search_url&quot;:&quot;https://api.github.com/search/code?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;commit_search_url&quot;:&quot;https://api.github.com/search/commits?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;emails_url&quot;:&quot;https://api.github.com/user/emails&quot;,&quot;emojis_url&quot;:&quot;https://api.github.com/emojis&quot;,&quot;events_url&quot;:&quot;https://api.github.com/events&quot;,&quot;feeds_url&quot;:&quot;https://api.github.com/feeds&quot;,&quot;followers_url&quot;:&quot;https://api.github.com/user/followers&quot;,&quot;following_url&quot;:&quot;https://api.github.com/user/following&#123;/target&#125;&quot;,&quot;gists_url&quot;:&quot;https://api.github.com/gists&#123;/gist_id&#125;&quot;,&quot;hub_url&quot;:&quot;https://api.github.com/hub&quot;,&quot;issue_search_url&quot;:&quot;https://api.github.com/search/issues?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;issues_url&quot;:&quot;https://api.github.com/issues&quot;,&quot;keys_url&quot;:&quot;https://api.github.com/user/keys&quot;,&quot;notifications_url&quot;:&quot;https://api.github.com/notifications&quot;,&quot;organization_repositories_url&quot;:&quot;https://api.github.com/orgs/&#123;org&#125;/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;organization_url&quot;:&quot;https://api.github.com/orgs/&#123;org&#125;&quot;,&quot;public_gists_url&quot;:&quot;https://api.github.com/gists/public&quot;,&quot;rate_limit_url&quot;:&quot;https://api.github.com/rate_limit&quot;,&quot;repository_url&quot;:&quot;https://api.github.com/repos/&#123;owner&#125;/&#123;repo&#125;&quot;,&quot;repository_search_url&quot;:&quot;https://api.github.com/search/repositories?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;current_user_repositories_url&quot;:&quot;https://api.github.com/user/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;starred_url&quot;:&quot;https://api.github.com/user/starred&#123;/owner&#125;&#123;/repo&#125;&quot;,&quot;starred_gists_url&quot;:&quot;https://api.github.com/gists/starred&quot;,&quot;team_url&quot;:&quot;https://api.github.com/teams&quot;,&quot;user_url&quot;:&quot;https://api.github.com/users/&#123;user&#125;&quot;,&quot;user_organizations_url&quot;:&quot;https://api.github.com/user/orgs&quot;,&quot;user_repositories_url&quot;:&quot;https://api.github.com/users/&#123;user&#125;/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;user_search_url&quot;:&quot;https://api.github.com/search/users?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果你仔细看一下响应的内容，你会发现实际上是序列化的<code>JSON</code>内容。因此，你可以通过<code>.text</code>的方式先获取字符串，然后再通过<a href=\"https://realpython.com/python-json/#deserializing-json\"><code>json.loads()</code></a>的方式获取字典。其实，还有一种更为简单的方法，可以使用<code>.json()</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.json()</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;current_user_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/user&#x27;</span>, <span class=\"string\">&#x27;current_user_authorizations_html_url&#x27;</span>: <span class=\"string\">&#x27;https://github.com/settings/connections/applications&#123;/client_id&#125;&#x27;</span>, <span class=\"string\">&#x27;authorizations_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/authorizations&#x27;</span>, <span class=\"string\">&#x27;code_search_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/search/code?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&#x27;</span>, <span class=\"string\">&#x27;commit_search_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/search/commits?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&#x27;</span>, <span class=\"string\">&#x27;emails_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/user/emails&#x27;</span>, <span class=\"string\">&#x27;emojis_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/emojis&#x27;</span>, <span class=\"string\">&#x27;events_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/events&#x27;</span>, <span class=\"string\">&#x27;feeds_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/feeds&#x27;</span>, <span class=\"string\">&#x27;followers_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/user/followers&#x27;</span>, <span class=\"string\">&#x27;following_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/user/following&#123;/target&#125;&#x27;</span>, <span class=\"string\">&#x27;gists_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/gists&#123;/gist_id&#125;&#x27;</span>, <span class=\"string\">&#x27;hub_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/hub&#x27;</span>, <span class=\"string\">&#x27;issue_search_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/search/issues?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&#x27;</span>, <span class=\"string\">&#x27;issues_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/issues&#x27;</span>, <span class=\"string\">&#x27;keys_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/user/keys&#x27;</span>, <span class=\"string\">&#x27;notifications_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/notifications&#x27;</span>, <span class=\"string\">&#x27;organization_repositories_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/orgs/&#123;org&#125;/repos&#123;?type,page,per_page,sort&#125;&#x27;</span>, <span class=\"string\">&#x27;organization_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/orgs/&#123;org&#125;&#x27;</span>, <span class=\"string\">&#x27;public_gists_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/gists/public&#x27;</span>, <span class=\"string\">&#x27;rate_limit_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/rate_limit&#x27;</span>, <span class=\"string\">&#x27;repository_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/repos/&#123;owner&#125;/&#123;repo&#125;&#x27;</span>, <span class=\"string\">&#x27;repository_search_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/search/repositories?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&#x27;</span>, <span class=\"string\">&#x27;current_user_repositories_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/user/repos&#123;?type,page,per_page,sort&#125;&#x27;</span>, <span class=\"string\">&#x27;starred_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/user/starred&#123;/owner&#125;&#123;/repo&#125;&#x27;</span>, <span class=\"string\">&#x27;starred_gists_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/gists/starred&#x27;</span>, <span class=\"string\">&#x27;team_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/teams&#x27;</span>, <span class=\"string\">&#x27;user_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/users/&#123;user&#125;&#x27;</span>, <span class=\"string\">&#x27;user_organizations_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/user/orgs&#x27;</span>, <span class=\"string\">&#x27;user_repositories_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/users/&#123;user&#125;/repos&#123;?type,page,per_page,sort&#125;&#x27;</span>, <span class=\"string\">&#x27;user_search_url&#x27;</span>: <span class=\"string\">&#x27;https://api.github.com/search/users?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>.json()</code>返回的结果是一个字典，因此你可以通过键来访问字典中的值。</p>\n<p>除了状态码和消息正文，你还可以查看响应中的Headers。</p>\n<h2 id=\"报头（Headers）\"><a href=\"#报头（Headers）\" class=\"headerlink\" title=\"报头（Headers）\"></a>报头（Headers）</h2><p>响应中的报头通常包含很多有用的信息，例如内容类型，缓存内容的时间限制。</p>\n<p>可以通过<code>.headers</code>来查看报头的内容：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.headers</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;Server&#x27;</span>: <span class=\"string\">&#x27;GitHub.com&#x27;</span>, <span class=\"string\">&#x27;Date&#x27;</span>: <span class=\"string\">&#x27;Mon, 10 Dec 2018 17:49:54 GMT&#x27;</span>, <span class=\"string\">&#x27;Content-Type&#x27;</span>: <span class=\"string\">&#x27;application/json; charset=utf-8&#x27;</span>, <span class=\"string\">&#x27;Transfer-Encoding&#x27;</span>: <span class=\"string\">&#x27;chunked&#x27;</span>, <span class=\"string\">&#x27;Status&#x27;</span>: <span class=\"string\">&#x27;200 OK&#x27;</span>, <span class=\"string\">&#x27;X-RateLimit-Limit&#x27;</span>: <span class=\"string\">&#x27;60&#x27;</span>, <span class=\"string\">&#x27;X-RateLimit-Remaining&#x27;</span>: <span class=\"string\">&#x27;59&#x27;</span>, <span class=\"string\">&#x27;X-RateLimit-Reset&#x27;</span>: <span class=\"string\">&#x27;1544467794&#x27;</span>, <span class=\"string\">&#x27;Cache-Control&#x27;</span>: <span class=\"string\">&#x27;public, max-age=60, s-maxage=60&#x27;</span>, <span class=\"string\">&#x27;Vary&#x27;</span>: <span class=\"string\">&#x27;Accept&#x27;</span>, <span class=\"string\">&#x27;ETag&#x27;</span>: <span class=\"string\">&#x27;W/&quot;7dc470913f1fe9bb6c7355b50a0737bc&quot;&#x27;</span>, <span class=\"string\">&#x27;X-GitHub-Media-Type&#x27;</span>: <span class=\"string\">&#x27;github.v3; format=json&#x27;</span>, <span class=\"string\">&#x27;Access-Control-Expose-Headers&#x27;</span>: <span class=\"string\">&#x27;ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type&#x27;</span>, <span class=\"string\">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class=\"string\">&#x27;*&#x27;</span>, <span class=\"string\">&#x27;Strict-Transport-Security&#x27;</span>: <span class=\"string\">&#x27;max-age=31536000; includeSubdomains; preload&#x27;</span>, <span class=\"string\">&#x27;X-Frame-Options&#x27;</span>: <span class=\"string\">&#x27;deny&#x27;</span>, <span class=\"string\">&#x27;X-Content-Type-Options&#x27;</span>: <span class=\"string\">&#x27;nosniff&#x27;</span>, <span class=\"string\">&#x27;X-XSS-Protection&#x27;</span>: <span class=\"string\">&#x27;1; mode=block&#x27;</span>, <span class=\"string\">&#x27;Referrer-Policy&#x27;</span>: <span class=\"string\">&#x27;origin-when-cross-origin, strict-origin-when-cross-origin&#x27;</span>, <span class=\"string\">&#x27;Content-Security-Policy&#x27;</span>: <span class=\"string\">&quot;default-src &#x27;none&#x27;&quot;</span>, <span class=\"string\">&#x27;Content-Encoding&#x27;</span>: <span class=\"string\">&#x27;gzip&#x27;</span>, <span class=\"string\">&#x27;X-GitHub-Request-Id&#x27;</span>: <span class=\"string\">&#x27;E439:4581:CF2351:1CA3E06:5C0EA741&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>.headers</code>返回的是字典类型的<strong>对象</strong>，因此，你可以像访问字典一样来获取值：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.headers[<span class=\"string\">&#x27;Content-Type&#x27;</span>]</span><br><span class=\"line\"><span class=\"string\">&#x27;application/json; charset=utf-8&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>headers对象有一个特殊的地方。由于HTTP标准定义headers不区分大小写，所以，我们访问headers的时候，不需要担心大小写：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.headers[<span class=\"string\">&#x27;content-type&#x27;</span>]</span><br><span class=\"line\"><span class=\"string\">&#x27;application/json; charset=utf-8&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>以上例子中，无论使用<code>content-type</code>还是<code>Content-Type</code>，你都能得到相同的结果。</p>\n<h2 id=\"查询字符串参数（Query-String-Parameters）\"><a href=\"#查询字符串参数（Query-String-Parameters）\" class=\"headerlink\" title=\"查询字符串参数（Query String Parameters）\"></a>查询字符串参数（Query String Parameters）</h2><p>通过在URL中传递查询字符串参数，可以定制GET请求。在方法<code>get()</code>中，可以传递参数<code>params</code>。例如，你可以使用GitHub的查询API来查找<code>requests</code>库。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Search GitHub&#x27;s repositories for requests</span></span><br><span class=\"line\">response = requests.get(</span><br><span class=\"line\">    <span class=\"string\">&#x27;https://api.github.com/search/repositories&#x27;</span>,</span><br><span class=\"line\">    params=&#123;<span class=\"string\">&#x27;q&#x27;</span>: <span class=\"string\">&#x27;requests+language:python&#x27;</span>&#125;,</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Inspect some attributes of the `requests` repository</span></span><br><span class=\"line\">json_response = response.json()</span><br><span class=\"line\">repository = json_response[<span class=\"string\">&#x27;items&#x27;</span>][<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Repository name: <span class=\"subst\">&#123;repository[<span class=\"string\">&quot;name&quot;</span>]&#125;</span>&#x27;</span>)  <span class=\"comment\"># Python 3.6+</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Repository description: <span class=\"subst\">&#123;repository[<span class=\"string\">&quot;description&quot;</span>]&#125;</span>&#x27;</span>)  <span class=\"comment\"># Python 3.6+</span></span><br></pre></td></tr></table></figure>\n\n<p>在方法<code>.get()</code>中，通过将字典<code>&#123;&#39;q&#39;: &#39;requests+language:python&#39;&#125;</code>传递给参数<code>params</code>，你可以改变从查询API返回的结果。</p>\n<p>你也可以用字典作为参数<code>params</code>的值，也可以使用以元组为成员的数组作为参数<code>params</code>的值：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.get(</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"string\">&#x27;https://api.github.com/search/repositories&#x27;</span>,</span><br><span class=\"line\"><span class=\"meta\">... </span>    params=[(<span class=\"string\">&#x27;q&#x27;</span>, <span class=\"string\">&#x27;requests+language:python&#x27;</span>)],</span><br><span class=\"line\"><span class=\"meta\">... </span>)</span><br><span class=\"line\">&lt;Response [<span class=\"number\">200</span>]&gt;</span><br></pre></td></tr></table></figure>\n\n<p>甚至，你还可以传递bytes作为值传递给参数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.get(</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"string\">&#x27;https://api.github.com/search/repositories&#x27;</span>,</span><br><span class=\"line\"><span class=\"meta\">... </span>    params=<span class=\"string\">b&#x27;q=requests+language:python&#x27;</span>,</span><br><span class=\"line\"><span class=\"meta\">... </span>)</span><br><span class=\"line\">&lt;Response [<span class=\"number\">200</span>]&gt;</span><br></pre></td></tr></table></figure>\n\n<p>查询字符串对于自定义GET请求非常有用。同时，你还可以通过添加或者修改报头来自定义GET请求。</p>\n<h2 id=\"请求报头（Request-Headers）\"><a href=\"#请求报头（Request-Headers）\" class=\"headerlink\" title=\"请求报头（Request Headers）\"></a>请求报头（Request Headers）</h2><p>在方法<code>.get()</code>中，你可以通过将字典作为值传递给参数<code>headers</code>的方式，来自定义报头。例如，在之前的查询例子中，你可以通过在<code>Accept</code>报头中指定<code>text-match</code>类型：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">response = requests.get(</span><br><span class=\"line\">    <span class=\"string\">&#x27;https://api.github.com/search/repositories&#x27;</span>,</span><br><span class=\"line\">    params=&#123;<span class=\"string\">&#x27;q&#x27;</span>: <span class=\"string\">&#x27;requests+language:python&#x27;</span>&#125;,</span><br><span class=\"line\">    headers=&#123;<span class=\"string\">&#x27;Accept&#x27;</span>: <span class=\"string\">&#x27;application/vnd.github.v3.text-match+json&#x27;</span>&#125;,</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># View the new `text-matches` array which provides information</span></span><br><span class=\"line\"><span class=\"comment\"># about your search term within the results</span></span><br><span class=\"line\">json_response = response.json()</span><br><span class=\"line\">repository = json_response[<span class=\"string\">&#x27;items&#x27;</span>][<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Text matches: <span class=\"subst\">&#123;repository[<span class=\"string\">&quot;text_matches&quot;</span>]&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><code>Accept</code>报头可以告诉服务器，你的应用可以处理的消息正文类型。在本例中，你使用的报头值是<code>application/vnd.github.v3.text-match+json</code>，这是GitHub网站<code>Accept</code>报头的专有属性，正文内容是一种特殊的JSON格式。</p>\n<p>在学习其它自定义请求的方式之前，我们先简单了解一下其它的HTTP方法。</p>\n<h2 id=\"其它的HTTP方法\"><a href=\"#其它的HTTP方法\" class=\"headerlink\" title=\"其它的HTTP方法\"></a>其它的HTTP方法</h2><p>除了GET以前，HTTP还支持<code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>HEAD</code>, <code>PATCH</code>和<code>OPTIONS</code>。在<code>requests</code>库中给，这些方法的使用方法和<code>get()</code>相似：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.post(<span class=\"string\">&#x27;https://httpbin.org/post&#x27;</span>, data=&#123;<span class=\"string\">&#x27;key&#x27;</span>:<span class=\"string\">&#x27;value&#x27;</span>&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.put(<span class=\"string\">&#x27;https://httpbin.org/put&#x27;</span>, data=&#123;<span class=\"string\">&#x27;key&#x27;</span>:<span class=\"string\">&#x27;value&#x27;</span>&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.delete(<span class=\"string\">&#x27;https://httpbin.org/delete&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.head(<span class=\"string\">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.patch(<span class=\"string\">&#x27;https://httpbin.org/patch&#x27;</span>, data=&#123;<span class=\"string\">&#x27;key&#x27;</span>:<span class=\"string\">&#x27;value&#x27;</span>&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.options(<span class=\"string\">&#x27;https://httpbin.org/get&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>以下例子中，每一个函数调用都会对httpbin服务发起相应的HTTP方法。每一种方法，你都可以使用和之前相同的方式，查看服务器响应的内容：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response = requests.head(<span class=\"string\">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.headers[<span class=\"string\">&#x27;Content-Type&#x27;</span>]</span><br><span class=\"line\"><span class=\"string\">&#x27;application/json&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response = requests.delete(<span class=\"string\">&#x27;https://httpbin.org/delete&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json_response = response.json()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json_response[<span class=\"string\">&#x27;args&#x27;</span>]</span><br><span class=\"line\">&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>报头、响应正文、状态码和其它信息都会包含在每一种HTTP方法的<code>Response</code>中。接下来，你将更为详细地了解<code>POST</code>，<code>PUT</code>和<code>PATCH</code>方法，以及它们之间的区别。</p>\n<h2 id=\"消息正文\"><a href=\"#消息正文\" class=\"headerlink\" title=\"消息正文\"></a>消息正文</h2><p>根据HTTP的规格说明，<code>POST</code>，<code>PUT</code>和<code>PATCH</code>都是通过将数据传递给消息正文，而不是通过将查询字符串传递给参数的方式。通过使用<code>requests</code>，你可以将<code>payload</code>传递给<code>data</code>参数。</p>\n<p>你可以将字典，元组为成员的列表或者文件对象传递给参数<code>data</code>。在请求的正文中，根据具体的类型需要，你可以采用不同的数据类型：</p>\n<p>例如，如果你请求的内容类型为<code>application/x-www-form-urlencoded</code>，那么你就可以将字典作为表格数据，传递给参数<code>data</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.post(<span class=\"string\">&#x27;https://httpbin.org/post&#x27;</span>, data=&#123;<span class=\"string\">&#x27;key&#x27;</span>:<span class=\"string\">&#x27;value&#x27;</span>&#125;)</span><br><span class=\"line\">&lt;Response [<span class=\"number\">200</span>]&gt;</span><br></pre></td></tr></table></figure>\n\n<p>你也可以使用以元组为成员的列表：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.post(<span class=\"string\">&#x27;https://httpbin.org/post&#x27;</span>, data=[(<span class=\"string\">&#x27;key&#x27;</span>, <span class=\"string\">&#x27;value&#x27;</span>)])</span><br><span class=\"line\">&lt;Response [<span class=\"number\">200</span>]&gt;</span><br></pre></td></tr></table></figure>\n\n<p>但是，如果你需要发送JSON格式的数据，你可以使用参数<code>json</code>。当你将值传递给参数<code>json</code>后，<code>requests</code>库会序列化你的数据和正确的<code>Content-Type</code>报头。</p>\n<p><a href=\"https://httpbin.org/\">httpbin.org</a>是由<code>requests</code>库的开发者 <a href=\"https://realpython.com/interview-kenneth-reitz/\">Kenneth Reitz</a>创建的一个用于测试的网站。该网站可以用来测试<code>requests</code>发起的各种请求。例如，你可以用它来测试POST请求：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response = requests.post(<span class=\"string\">&#x27;https://httpbin.org/post&#x27;</span>, json=&#123;<span class=\"string\">&#x27;key&#x27;</span>:<span class=\"string\">&#x27;value&#x27;</span>&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json_response = response.json()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json_response[<span class=\"string\">&#x27;data&#x27;</span>]</span><br><span class=\"line\"><span class=\"string\">&#x27;&#123;&quot;key&quot;: &quot;value&quot;&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json_response[<span class=\"string\">&#x27;headers&#x27;</span>][<span class=\"string\">&#x27;Content-Type&#x27;</span>]</span><br><span class=\"line\"><span class=\"string\">&#x27;application/json&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"检查请求\"><a href=\"#检查请求\" class=\"headerlink\" title=\"检查请求\"></a>检查请求</h2><p>在发送请求到服务器之前，<code>requests</code>库会先将请求准备好。请求的准备包括验证报头以及序列化JSON内容。</p>\n<p>你可以通过<code>.request</code>来访问准备请求（<code>PrepareRequest</code>）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response = requests.post(<span class=\"string\">&#x27;https://httpbin.org/post&#x27;</span>, json=&#123;<span class=\"string\">&#x27;key&#x27;</span>:<span class=\"string\">&#x27;value&#x27;</span>&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.request.headers[<span class=\"string\">&#x27;Content-Type&#x27;</span>]</span><br><span class=\"line\"><span class=\"string\">&#x27;application/json&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.request.url</span><br><span class=\"line\"><span class=\"string\">&#x27;https://httpbin.org/post&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.request.body</span><br><span class=\"line\"><span class=\"string\">b&#x27;&#123;&quot;key&quot;: &quot;value&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>检查准备请求可以让你访问各种信息，包括payload, URL, headers, authentication等等。</p>\n<h2 id=\"认证\"><a href=\"#认证\" class=\"headerlink\" title=\"认证\"></a>认证</h2><p>认证可以让服务器知道你是谁。通常情况下，你可以通过<code>Authorization</code>报头提供你的身份信息，或者也可以通过自定义的报头来提供身份信息。在<code>requests</code>中，你可以使用参数<code>auth</code>来传递你的身份信息。</p>\n<p>下面以GitHub的<a href=\"https://developer.github.com/v3/users/#get-the-authenticated-user\">Authenticated User</a> API为例。为了访问该API，你需要通过一个元组来传递用户名和密码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> getpass <span class=\"keyword\">import</span> getpass</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.get(<span class=\"string\">&#x27;https://api.github.com/user&#x27;</span>, auth=(<span class=\"string\">&#x27;username&#x27;</span>, getpass()))</span><br><span class=\"line\">&lt;Response [<span class=\"number\">200</span>]&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果身份信息正确，request请求就会返回成功过。如果request请求中没有包含身份信息，服务器就会返回<code>401 Unauthorized</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.get(<span class=\"string\">&#x27;https://api.github.com/user&#x27;</span>)</span><br><span class=\"line\">&lt;Response [<span class=\"number\">401</span>]&gt;</span><br></pre></td></tr></table></figure>\n\n<p>当你通过以上这种方式传递身份信息的时候，实际上<code>requests</code>使用的是HTTP的 <a href=\"https://en.wikipedia.org/wiki/Basic_access_authentication\">Basic access authentication scheme</a>。</p>\n<p>因此，你还可以使用<code>HTTPBasicAuth</code>来传递身份信息：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> requests.auth <span class=\"keyword\">import</span> HTTPBasicAuth</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> getpass <span class=\"keyword\">import</span> getpass</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.get(</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"string\">&#x27;https://api.github.com/user&#x27;</span>,</span><br><span class=\"line\"><span class=\"meta\">... </span>    auth=HTTPBasicAuth(<span class=\"string\">&#x27;username&#x27;</span>, getpass())</span><br><span class=\"line\"><span class=\"meta\">... </span>)</span><br><span class=\"line\">&lt;Response [<span class=\"number\">200</span>]&gt;</span><br></pre></td></tr></table></figure>\n\n<p>除了Basic认证方式以外，<code>requests</code>还支持其它认证方式，例如<code>HTTPDigestAuth</code>和<code>HTTPProxyAuth</code>。</p>\n<p>你甚至还可以提供自定义的认证方式。但是，你必须首先创建一个继承<code>AuthBase</code>的子类。然后，你需要定义<code>__call__()</code>函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">from</span> requests.auth <span class=\"keyword\">import</span> AuthBase</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TokenAuth</span>(<span class=\"title class_ inherited__\">AuthBase</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Implements a custom authentication scheme.&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, token</span>):</span><br><span class=\"line\">        self.token = token</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__call__</span>(<span class=\"params\">self, r</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Attach an API token to a custom auth header.&quot;&quot;&quot;</span></span><br><span class=\"line\">        r.headers[<span class=\"string\">&#x27;X-TokenAuth&#x27;</span>] = <span class=\"string\">f&#x27;<span class=\"subst\">&#123;self.token&#125;</span>&#x27;</span>  <span class=\"comment\"># Python 3.6+</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> r</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">requests.get(<span class=\"string\">&#x27;https://httpbin.org/get&#x27;</span>, auth=TokenAuth(<span class=\"string\">&#x27;12345abcde-token&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>以上例子中，自定义的类<code>TokenAuth</code>会收到一个Token，然后将收到的token放到<code>x-TokenAuth</code>报头中。</p>\n<p>不健全的认证机制会导致安全隐患，所以除非有特殊需求，否则应该使用成熟的认证机制，比如Basic或者OAuth。</p>\n<h2 id=\"SSL证书验证\"><a href=\"#SSL证书验证\" class=\"headerlink\" title=\"SSL证书验证\"></a>SSL证书验证</h2><p>任何时候，当发送和接收的信息比较机密，安全往往是最重要的。因此，当你访问安全站点的时候，都会通过SSL建立安全连接，这时候对服务器的SSL证书进行验证显得尤为重要。</p>\n<p>默认情况下，<code>requests</code>已经为你执行了SSL证书的验证。但是，在某些情况下，你可能希望改变这种默认的行为。</p>\n<p>如果你想要关闭SSL证书的验证，你可以将参数<code>verify</code>设置为<code>False</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.get(<span class=\"string\">&#x27;https://api.github.com&#x27;</span>, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\">InsecureRequestWarning: Unverified HTTPS request <span class=\"keyword\">is</span> being made. Adding certificate verification <span class=\"keyword\">is</span> strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html<span class=\"comment\">#ssl-warnings</span></span><br><span class=\"line\">  InsecureRequestWarning)</span><br><span class=\"line\">&lt;Response [<span class=\"number\">200</span>]&gt;</span><br></pre></td></tr></table></figure>\n\n<p>当你正在访问一个不安全的站点时，<code>requests</code>会发出警告信息提醒你。</p>\n<blockquote>\n<p>注意：<code>requests</code>使用<a href=\"http://docs.python-requests.org/en/master/user/advanced/#ca-certificates\"><code>certifi</code></a>来提供SSL证书的颁发机构（ Certificate Authorities）。这可以让<code>requests</code>知道有哪些可以信任的证书颁发机构。因此，你需要定期更新<code>certifi</code>来保证安全性。</p>\n</blockquote>\n<h2 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h2><p>当在生产环境中使用<code>requests</code>的时候，特别需要考虑性能的影响。<code>requests</code>库的一些特性，例如超时控制（timeout control），会话（sessions）和重试限制（retry limits）可以使得应用运行得更流畅。</p>\n<h3 id=\"Timeouts\"><a href=\"#Timeouts\" class=\"headerlink\" title=\"Timeouts\"></a>Timeouts</h3><p>当你向服务发送请求以后，你得应用将会等待服务端的响应，得到响应以后，才会执行下一步操作。如果应用等待的时间太长，请求就会一直处于等待状态，导致用户体验变差，或者后台任务挂起。</p>\n<p>默认情况下，<code>requests</code>将会无限制地等待响应，所以你应该指定一个超时的时间值。你可以通过参数<code>timeout</code>来设置超时的时间值。<code>timeout</code>的值可以是整型或者浮点型，时间的单位是秒。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.get(<span class=\"string\">&#x27;https://api.github.com&#x27;</span>, timeout=<span class=\"number\">1</span>)</span><br><span class=\"line\">&lt;Response [<span class=\"number\">200</span>]&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.get(<span class=\"string\">&#x27;https://api.github.com&#x27;</span>, timeout=<span class=\"number\">3.05</span>)</span><br><span class=\"line\">&lt;Response [<span class=\"number\">200</span>]&gt;</span><br></pre></td></tr></table></figure>\n\n<p>以上例子中，第一个请求的超时时间是1秒，第二个请求的超时时间是3.05秒。</p>\n<p>你还可以传递一个<a href=\"http://docs.python-requests.org/en/master/user/advanced/#timeouts\">元组</a>给参数<code>timeout</code>，元组中的第一个值是TCP连接的超时时间（客户端和服务器之间建立连接的时长，通常建议设置为比3的倍数大一点），第二个值是数据传输的超时时间（建立连接后，等待响应的超时时间）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>requests.get(<span class=\"string\">&#x27;https://api.github.com&#x27;</span>, timeout=(<span class=\"number\">2</span>, <span class=\"number\">5</span>))</span><br><span class=\"line\">&lt;Response [<span class=\"number\">200</span>]&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果请求建立连接的时间在2秒以内，建立连接后，接收数据的时间在5秒以内，那么就可以正常获取到响应。但是，如果请求超时，那么函数就会抛出一个<code>Timeout</code>的异常。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">from</span> requests.exceptions <span class=\"keyword\">import</span> Timeout</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    response = requests.get(<span class=\"string\">&#x27;https://api.github.com&#x27;</span>, timeout=<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">except</span> Timeout:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;The request timed out&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;The request did not time out&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>你的程序可以捕获这个<code>Timeout</code>的异常，并做相应的处理。</p>\n<h3 id=\"The-Session-Object\"><a href=\"#The-Session-Object\" class=\"headerlink\" title=\"The Session Object\"></a>The Session Object</h3><p>到目前为止，你都是使用<code>requests</code>的<code>get()</code>和<code>post()</code>来发送请求。这些函数隐藏了一些细节，例如连接是如何建立以及管理的。</p>\n<p>实际上，这些细节都是由类<code>Session</code>来负责处理。如果你需要微调你的请求，或者改进性能，你需要直接使用<code>Session</code>的实例。</p>\n<p>会话主要是在一些列的请求中，保持持久的参数。例如，如果你想要在多个请求中使用相同的认证信息，你就可以使用会话：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">from</span> getpass <span class=\"keyword\">import</span> getpass</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># By using a context manager, you can ensure the resources used by</span></span><br><span class=\"line\"><span class=\"comment\"># the session will be released after use</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> requests.Session() <span class=\"keyword\">as</span> session:</span><br><span class=\"line\">    session.auth = (<span class=\"string\">&#x27;username&#x27;</span>, getpass())</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Instead of requests.get(), you&#x27;ll use session.get()</span></span><br><span class=\"line\">    response = session.get(<span class=\"string\">&#x27;https://api.github.com/user&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># You can inspect the response just like you did before</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(response.headers)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(response.json())</span><br></pre></td></tr></table></figure>\n\n<p>每次你用session发起请求，一旦该会话在初始化时，设定了认证的身份信息，那么该身份信息就可以在多个requests中重复使用。</p>\n<p>通过session改进性能，主要是通过保持长连接的方式。当你的应用通过Session来发起请求，它就会在连接池中长时间保持该连接。当应用想要再次连接到同一个服务器的时候，就可以重复使用连接池中的连接，而不需要再新建连接。</p>\n<h3 id=\"Max-Retries\"><a href=\"#Max-Retries\" class=\"headerlink\" title=\"Max Retries\"></a>Max Retries</h3><p>当请求失败的时候，你可能希望应用重新发起同样的请求。但是，<code>requests</code>默认并不会帮你重新发送请求。为了实现这个功能，你需要使用<a href=\"http://docs.python-requests.org/en/master/user/advanced/#transport-adapters\">Transport Adapter</a>。</p>\n<p>Transport Adapters可以让你为每一个需要访问的服务定义一组配置信息。例如，你想要所有访问<code>https://api.github.com</code>的请求失败后重复三次，你可以创建一个Transport Adapter，设置参数<code>max_retries</code>的值为3，并将其挂载到当前的会话上：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">from</span> requests.adapters <span class=\"keyword\">import</span> HTTPAdapter</span><br><span class=\"line\"><span class=\"keyword\">from</span> requests.exceptions <span class=\"keyword\">import</span> ConnectionError</span><br><span class=\"line\"></span><br><span class=\"line\">github_adapter = HTTPAdapter(max_retries=<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">session = requests.Session()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Use `github_adapter` for all requests to endpoints that start with this URL</span></span><br><span class=\"line\">session.mount(<span class=\"string\">&#x27;https://api.github.com&#x27;</span>, github_adapter)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    session.get(<span class=\"string\">&#x27;https://api.github.com&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">except</span> ConnectionError <span class=\"keyword\">as</span> ce:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(ce)</span><br></pre></td></tr></table></figure>\n\n<p>当你挂载github_adapter到会话的时候，会话会遵循该配置的设置。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过以上内容，你现在可以：</p>\n<ul>\n<li>发送不同的HTTP请求，例如：GET, POST, PUT</li>\n<li>通过修改报头，认证，查询字符串和消息这个问，自定义请求</li>\n<li>检查发送给服务器的数据，以及从服务器接收的数据</li>\n<li>SSL证书验证</li>\n<li>通过max_retries, timeout, Sessions和Transport Adapters，更有效的使用<code>requests</code></li>\n</ul>"},{"title":"如何使用Home Assistant更新DDNS记录","date":"2024-09-26T02:05:00.000Z","updated":"2024-09-26T07:12:25.426Z","_content":"\n## 缘起\n\n由于家中的宽带运营商不提供公网IPv4地址，所以一直都没有将Home Assistant发布到公网。最近无意中从网上了解到可以使用IPv6的公网地址，经过测试，确实有效。\n\n考虑到IPv6地址是动态分配的，间隔一段时间就会自动更新为新的IPv6地址，于是就在免费的DDNS服务商[Dynv6](https://dynv6.com/)申请了动态域名。根据Dynv6官方API文档介绍，IPv6不支持用`Remote Access API`，也就意味着不支持用[ddclient](https://ddclient.net/)作为客户端，来自动更新DDNS记录。\n\n```\n### DynDNS API\n\nWe implemented the dyn.com [Remote Access API](https://help.dyn.com/remote-access-api/) that is also known as the _Members NIC Update API_ or _DNS Update API_. It can only be used to update the IPv4 address of a zone.\n\nTo use the endpoint https://dynv6.com/nic/update please set the server in your client to 'dynv6.com'.\n```\n\n根据[REST API for dynv6](https://dynv6.github.io/api-spec/)文档，自己用Python写了一个脚本，用于自动更新DDNS记录。经过一段时间的使用，基本能满足需求，但是仍然有一些小瑕疵，比如运营商自动分配IPv6地址的过程中，有时候会出现短时间内（5-10分钟）多次分配IP地址的情况，并且网络也会变得很不稳定，这时会导致DDNS更新出现问题。\n\n最近在使用Home Assistant的过程中，发现了`RESTful Command`的集成，于是想到为何不干脆使用Home Assistant来完成DDNS记录的更新，这样还省去了单独维护Python脚本的时间成本。\n\n## 需求\n\n其实需求很简单，就是当Home Assistant的IPv6地址自动更新为新地址的时候，Home Assistant自动将新地址更新到`Dynv6`的动态域名记录中。\n\n### 具体细节\n\n为了实现上述需求，需要考虑以下细节：\n\n- 触发器\n\n\tHome Assistant会实时监控公网IPv6地址的变化，当IP地址发生变化，就会触发Home Assistant更新DDNS记录的动作。\n\t\n- 触发的先决条件\n\n\tHome Assistant需要实时监控Dynv6 Rest API的网络连接，以确保可以成功更新DDNS记录。如果网络连接异常，即使公网IPv6地址发生改变，也不会触发Home Assistant的更新DDNS记录的动作。\n\n- 动作\n\n\tHome Assistant执行更新DDNS记录的动作。\n\n## System Monitor\n\n**System Monitor**可以用来监控CPU、内存、硬盘等硬件信息，在这里，主要用来实时获取网口的IPv6地址信息。当IPv6地址发生改变时，就可以触发Home Assistant的自动化操作。\n\n**System Monitor**是Home Assistant的一个集成，或者说是扩展功能，使用之前需要手工添加和配置。\n\n以下是网口IPv6地址的实体ID，该实体的值是IPv6地址：\n\n```\nentity_id: sensor.system_monitor_ipv6_address_eth0\n```\n\n## Dynv6 Rest API\n\n[REST API for dynv6](https://dynv6.github.io/api-spec/)\n\n**Rest API URL**\nhttps://dynv6.com/api/v2\n\nDynv6 Rest API主要分为两大类：**Zones**和**Records**。\n\n### Zones\n\n**GET**          Get a list of records\n**POST**       Add a new record\n**GET**          Get details for a record\n**PATCH**     Update an existing record\n**DEL**           Delete a record\n\n### Records\n\n**GET**          Get a list of zones\n**POST**       Register a new zone\n**GET**          Get details for a zone\n**PATCH**     Update an existing zone\n**DEL**           Delete the zone\n**GET**           Get details of a zone by its name\n\n下载：[openapi.json](openapi.json)\n\n## Command Line\n\n**Command Line**是Home Assistant中的一个集成功能，可以通过命令的方式，定义一种传感器实体。因此，通过该集成，可以定义一个二进制传感器，检测Dynv6 Rest API的网络连接性。\n\n### nc工具\n\n为了检测Dynv6 Rest API的网络连接性，可以使用命令行工具`nc`。\n\n以下命令可以用来检测Home Assistant和Dynv6 Rest API服务之间的网络连接性。如果Home Assistant与Dynv6 Rest API服务的TCP 443端口连接成功，返回“success”，否则返回“fail”。\n\n```\nnc -6z -w 2 dynv6.com 443 > /dev/null 2>&1 && echo success || echo fail'\"\t\n```\n\n参数说明：\n\n-6        指定nc使用本机的IPv6地址。使用该选项，主要是为了确保IPv6已经更新完成，并能够与Dynv6 API服务之间正常通讯，这也是为了避免前面所提到的，自己写的脚本中的“小瑕疵”。\n-z         nc只做端口扫描，不传输数据。\n-w        如果连接不上，2秒后超时。\n\n### SSH远程命令\n\n另外，由于Home Assistant是通过容器的方式安装，并且容器中`nc`工具的版本不支持IPv6，所以只能考虑用主机的`nc`。为了能调用主机的`nc`，决定使用SSH的方式远程调用命令。\n\n```\nssh -o StrictHostKeychecking=no pi@pi -i /config/.ssh/id_rsa 'nc -6z -w 2 \\\n\t\t\t dynv6.com 443 > /dev/null 2>&1 && echo success || echo fail'\n```\n\n参数说明：\n\n-o StrictHostKeychecking=no      登录时不需要验证目标主机的Key\n-i /config/.ssh/id_rsa                        私钥文件的位置\n\n### configuration.yaml\n\n以下是Home Assistant的配置文件`configuration.yaml`中的详细配置信息：\n\n```\n- binary_sensor:\t\n\tname: 'Dynv6 API'\t\n\tcommand: \"ssh -o StrictHostKeychecking=no pi@pi -i /config/.ssh/id_rsa 'nc -6z -w 2 \\\n\t\t\t dynv6.com 443 > /dev/null 2>&1 && echo success || echo fail'\"\t\n\tpayload_on: success\t\n\tpayload_off: fail\t\n\tscan_interval: 60\t\n\ticon: mdi:api\t\n\tunique_id: cmd_dynv6_api\t\n\tdevice_class: connectivity\n```\n\n以上配置定义了一个二进制传感器，该传感器的名字为“Dynv6 API”，每60秒执行一次网络连接性测试，如果成功则返回“success”，否则返回“fail”。\n\n## RESTful Command\n\n**RESTful Command**是Home Assistant中的一个集成功能，通过该集成，可以定义一个对Rest API的操作请求，执行DDNS记录的更新。\n\n```\nrest_command:\n\tdynv6_update_zone:\n\turl: https://dynv6.com/api/v2/zones/<zone_id>\n\tmethod: patch\n\tcontent_type: application/json\n\theaders:\t\n\t\tauthorization: 'Bearer <Token>'\n\tpayload: '{\"ipv6prefix\":\"{{ states(\"sensor.system_monitor_ipv6_address_eth0\") }}\"}'\n```\n\nurl               zone_id需要替换成与Zone对应的id。\nmethod     更新Zone的方法需要用PATCH。\nauthorization        需要用Token。\npayload:    更新后的IPv6地址，此处是读取传感器`sensor.system_monitor_ipv6_address_eth0`的值。\n\n## 自动化\n\n在Home Assistant中，创建一个名为“DDNS｜自动更新动态域名”的自动化，该自动化可以实现自动更新DDNS记录的需求。\n\n### trigger\n\n如果传感器`sensor.system_monitor_ipv6_address_eth0`值发生变化，触发器就会被自动触发。\n\nto: null 传感器的值发生任何变化都会导致触发器被触发。\n\n```\ntrigger:\n  - platform: state\n    entity_id:\n      - sensor.system_monitor_ipv6_address_eth0\n    to: null\n    enabled: true\n```\n\n### condition\n\n触发器被触发的先决条件是，二进制传感器`binary_sensor.dynv6_api`的状态必须是`on`。\n\n```\ncondition:\n  - condition: state\n    entity_id: binary_sensor.dynv6_api\n    state: \"on\"\n```\n\n### action\n\n当自动化被触发器成功触发后，就会执行操作`rest_command.dynv6_update_zone`，该操作将执行DDNS记录的更新。\n\n```\naction:\n  - action: rest_command.dynv6_update_zone\n    data: {}\n```\n\n### configuration.yaml\n\n以下是自动化的详细配置信息：\n\n```\nalias: DDNS｜自动更新动态域名\ndescription: \"\"\ntrigger:\n  - platform: state\n    entity_id:\n      - sensor.system_monitor_ipv6_address_eth0\n    to: null\n    enabled: true\ncondition:\n  - condition: state\n    entity_id: binary_sensor.dynv6_api\n    state: \"on\"\naction:\n  - action: rest_command.dynv6_update_zone\n    data: {}\nmode: single\n```","source":"_posts/Home_Assistant/如何使用Home Assistant更新DDNS记录.md","raw":"---\ntitle: 如何使用Home Assistant更新DDNS记录\ndate: 2024-09-26 10:05\ntags:\n  - home_assistant\ncategories:\n  - Home_Assistant\nupdated:\n---\n\n## 缘起\n\n由于家中的宽带运营商不提供公网IPv4地址，所以一直都没有将Home Assistant发布到公网。最近无意中从网上了解到可以使用IPv6的公网地址，经过测试，确实有效。\n\n考虑到IPv6地址是动态分配的，间隔一段时间就会自动更新为新的IPv6地址，于是就在免费的DDNS服务商[Dynv6](https://dynv6.com/)申请了动态域名。根据Dynv6官方API文档介绍，IPv6不支持用`Remote Access API`，也就意味着不支持用[ddclient](https://ddclient.net/)作为客户端，来自动更新DDNS记录。\n\n```\n### DynDNS API\n\nWe implemented the dyn.com [Remote Access API](https://help.dyn.com/remote-access-api/) that is also known as the _Members NIC Update API_ or _DNS Update API_. It can only be used to update the IPv4 address of a zone.\n\nTo use the endpoint https://dynv6.com/nic/update please set the server in your client to 'dynv6.com'.\n```\n\n根据[REST API for dynv6](https://dynv6.github.io/api-spec/)文档，自己用Python写了一个脚本，用于自动更新DDNS记录。经过一段时间的使用，基本能满足需求，但是仍然有一些小瑕疵，比如运营商自动分配IPv6地址的过程中，有时候会出现短时间内（5-10分钟）多次分配IP地址的情况，并且网络也会变得很不稳定，这时会导致DDNS更新出现问题。\n\n最近在使用Home Assistant的过程中，发现了`RESTful Command`的集成，于是想到为何不干脆使用Home Assistant来完成DDNS记录的更新，这样还省去了单独维护Python脚本的时间成本。\n\n## 需求\n\n其实需求很简单，就是当Home Assistant的IPv6地址自动更新为新地址的时候，Home Assistant自动将新地址更新到`Dynv6`的动态域名记录中。\n\n### 具体细节\n\n为了实现上述需求，需要考虑以下细节：\n\n- 触发器\n\n\tHome Assistant会实时监控公网IPv6地址的变化，当IP地址发生变化，就会触发Home Assistant更新DDNS记录的动作。\n\t\n- 触发的先决条件\n\n\tHome Assistant需要实时监控Dynv6 Rest API的网络连接，以确保可以成功更新DDNS记录。如果网络连接异常，即使公网IPv6地址发生改变，也不会触发Home Assistant的更新DDNS记录的动作。\n\n- 动作\n\n\tHome Assistant执行更新DDNS记录的动作。\n\n## System Monitor\n\n**System Monitor**可以用来监控CPU、内存、硬盘等硬件信息，在这里，主要用来实时获取网口的IPv6地址信息。当IPv6地址发生改变时，就可以触发Home Assistant的自动化操作。\n\n**System Monitor**是Home Assistant的一个集成，或者说是扩展功能，使用之前需要手工添加和配置。\n\n以下是网口IPv6地址的实体ID，该实体的值是IPv6地址：\n\n```\nentity_id: sensor.system_monitor_ipv6_address_eth0\n```\n\n## Dynv6 Rest API\n\n[REST API for dynv6](https://dynv6.github.io/api-spec/)\n\n**Rest API URL**\nhttps://dynv6.com/api/v2\n\nDynv6 Rest API主要分为两大类：**Zones**和**Records**。\n\n### Zones\n\n**GET**          Get a list of records\n**POST**       Add a new record\n**GET**          Get details for a record\n**PATCH**     Update an existing record\n**DEL**           Delete a record\n\n### Records\n\n**GET**          Get a list of zones\n**POST**       Register a new zone\n**GET**          Get details for a zone\n**PATCH**     Update an existing zone\n**DEL**           Delete the zone\n**GET**           Get details of a zone by its name\n\n下载：[openapi.json](openapi.json)\n\n## Command Line\n\n**Command Line**是Home Assistant中的一个集成功能，可以通过命令的方式，定义一种传感器实体。因此，通过该集成，可以定义一个二进制传感器，检测Dynv6 Rest API的网络连接性。\n\n### nc工具\n\n为了检测Dynv6 Rest API的网络连接性，可以使用命令行工具`nc`。\n\n以下命令可以用来检测Home Assistant和Dynv6 Rest API服务之间的网络连接性。如果Home Assistant与Dynv6 Rest API服务的TCP 443端口连接成功，返回“success”，否则返回“fail”。\n\n```\nnc -6z -w 2 dynv6.com 443 > /dev/null 2>&1 && echo success || echo fail'\"\t\n```\n\n参数说明：\n\n-6        指定nc使用本机的IPv6地址。使用该选项，主要是为了确保IPv6已经更新完成，并能够与Dynv6 API服务之间正常通讯，这也是为了避免前面所提到的，自己写的脚本中的“小瑕疵”。\n-z         nc只做端口扫描，不传输数据。\n-w        如果连接不上，2秒后超时。\n\n### SSH远程命令\n\n另外，由于Home Assistant是通过容器的方式安装，并且容器中`nc`工具的版本不支持IPv6，所以只能考虑用主机的`nc`。为了能调用主机的`nc`，决定使用SSH的方式远程调用命令。\n\n```\nssh -o StrictHostKeychecking=no pi@pi -i /config/.ssh/id_rsa 'nc -6z -w 2 \\\n\t\t\t dynv6.com 443 > /dev/null 2>&1 && echo success || echo fail'\n```\n\n参数说明：\n\n-o StrictHostKeychecking=no      登录时不需要验证目标主机的Key\n-i /config/.ssh/id_rsa                        私钥文件的位置\n\n### configuration.yaml\n\n以下是Home Assistant的配置文件`configuration.yaml`中的详细配置信息：\n\n```\n- binary_sensor:\t\n\tname: 'Dynv6 API'\t\n\tcommand: \"ssh -o StrictHostKeychecking=no pi@pi -i /config/.ssh/id_rsa 'nc -6z -w 2 \\\n\t\t\t dynv6.com 443 > /dev/null 2>&1 && echo success || echo fail'\"\t\n\tpayload_on: success\t\n\tpayload_off: fail\t\n\tscan_interval: 60\t\n\ticon: mdi:api\t\n\tunique_id: cmd_dynv6_api\t\n\tdevice_class: connectivity\n```\n\n以上配置定义了一个二进制传感器，该传感器的名字为“Dynv6 API”，每60秒执行一次网络连接性测试，如果成功则返回“success”，否则返回“fail”。\n\n## RESTful Command\n\n**RESTful Command**是Home Assistant中的一个集成功能，通过该集成，可以定义一个对Rest API的操作请求，执行DDNS记录的更新。\n\n```\nrest_command:\n\tdynv6_update_zone:\n\turl: https://dynv6.com/api/v2/zones/<zone_id>\n\tmethod: patch\n\tcontent_type: application/json\n\theaders:\t\n\t\tauthorization: 'Bearer <Token>'\n\tpayload: '{\"ipv6prefix\":\"{{ states(\"sensor.system_monitor_ipv6_address_eth0\") }}\"}'\n```\n\nurl               zone_id需要替换成与Zone对应的id。\nmethod     更新Zone的方法需要用PATCH。\nauthorization        需要用Token。\npayload:    更新后的IPv6地址，此处是读取传感器`sensor.system_monitor_ipv6_address_eth0`的值。\n\n## 自动化\n\n在Home Assistant中，创建一个名为“DDNS｜自动更新动态域名”的自动化，该自动化可以实现自动更新DDNS记录的需求。\n\n### trigger\n\n如果传感器`sensor.system_monitor_ipv6_address_eth0`值发生变化，触发器就会被自动触发。\n\nto: null 传感器的值发生任何变化都会导致触发器被触发。\n\n```\ntrigger:\n  - platform: state\n    entity_id:\n      - sensor.system_monitor_ipv6_address_eth0\n    to: null\n    enabled: true\n```\n\n### condition\n\n触发器被触发的先决条件是，二进制传感器`binary_sensor.dynv6_api`的状态必须是`on`。\n\n```\ncondition:\n  - condition: state\n    entity_id: binary_sensor.dynv6_api\n    state: \"on\"\n```\n\n### action\n\n当自动化被触发器成功触发后，就会执行操作`rest_command.dynv6_update_zone`，该操作将执行DDNS记录的更新。\n\n```\naction:\n  - action: rest_command.dynv6_update_zone\n    data: {}\n```\n\n### configuration.yaml\n\n以下是自动化的详细配置信息：\n\n```\nalias: DDNS｜自动更新动态域名\ndescription: \"\"\ntrigger:\n  - platform: state\n    entity_id:\n      - sensor.system_monitor_ipv6_address_eth0\n    to: null\n    enabled: true\ncondition:\n  - condition: state\n    entity_id: binary_sensor.dynv6_api\n    state: \"on\"\naction:\n  - action: rest_command.dynv6_update_zone\n    data: {}\nmode: single\n```","slug":"Home_Assistant/如何使用Home Assistant更新DDNS记录","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cm1iylgev0000axechk9cak7e","content":"<h2 id=\"缘起\"><a href=\"#缘起\" class=\"headerlink\" title=\"缘起\"></a>缘起</h2><p>由于家中的宽带运营商不提供公网IPv4地址，所以一直都没有将Home Assistant发布到公网。最近无意中从网上了解到可以使用IPv6的公网地址，经过测试，确实有效。</p>\n<p>考虑到IPv6地址是动态分配的，间隔一段时间就会自动更新为新的IPv6地址，于是就在免费的DDNS服务商<a href=\"https://dynv6.com/\">Dynv6</a>申请了动态域名。根据Dynv6官方API文档介绍，IPv6不支持用<code>Remote Access API</code>，也就意味着不支持用<a href=\"https://ddclient.net/\">ddclient</a>作为客户端，来自动更新DDNS记录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">### DynDNS API</span><br><span class=\"line\"></span><br><span class=\"line\">We implemented the dyn.com [Remote Access API](https://help.dyn.com/remote-access-api/) that is also known as the _Members NIC Update API_ or _DNS Update API_. It can only be used to update the IPv4 address of a zone.</span><br><span class=\"line\"></span><br><span class=\"line\">To use the endpoint https://dynv6.com/nic/update please set the server in your client to &#x27;dynv6.com&#x27;.</span><br></pre></td></tr></table></figure>\n\n<p>根据<a href=\"https://dynv6.github.io/api-spec/\">REST API for dynv6</a>文档，自己用Python写了一个脚本，用于自动更新DDNS记录。经过一段时间的使用，基本能满足需求，但是仍然有一些小瑕疵，比如运营商自动分配IPv6地址的过程中，有时候会出现短时间内（5-10分钟）多次分配IP地址的情况，并且网络也会变得很不稳定，这时会导致DDNS更新出现问题。</p>\n<p>最近在使用Home Assistant的过程中，发现了<code>RESTful Command</code>的集成，于是想到为何不干脆使用Home Assistant来完成DDNS记录的更新，这样还省去了单独维护Python脚本的时间成本。</p>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>其实需求很简单，就是当Home Assistant的IPv6地址自动更新为新地址的时候，Home Assistant自动将新地址更新到<code>Dynv6</code>的动态域名记录中。</p>\n<h3 id=\"具体细节\"><a href=\"#具体细节\" class=\"headerlink\" title=\"具体细节\"></a>具体细节</h3><p>为了实现上述需求，需要考虑以下细节：</p>\n<ul>\n<li><p>触发器</p>\n<p>  Home Assistant会实时监控公网IPv6地址的变化，当IP地址发生变化，就会触发Home Assistant更新DDNS记录的动作。</p>\n</li>\n<li><p>触发的先决条件</p>\n<p>  Home Assistant需要实时监控Dynv6 Rest API的网络连接，以确保可以成功更新DDNS记录。如果网络连接异常，即使公网IPv6地址发生改变，也不会触发Home Assistant的更新DDNS记录的动作。</p>\n</li>\n<li><p>动作</p>\n<p>  Home Assistant执行更新DDNS记录的动作。</p>\n</li>\n</ul>\n<h2 id=\"System-Monitor\"><a href=\"#System-Monitor\" class=\"headerlink\" title=\"System Monitor\"></a>System Monitor</h2><p><strong>System Monitor</strong>可以用来监控CPU、内存、硬盘等硬件信息，在这里，主要用来实时获取网口的IPv6地址信息。当IPv6地址发生改变时，就可以触发Home Assistant的自动化操作。</p>\n<p><strong>System Monitor</strong>是Home Assistant的一个集成，或者说是扩展功能，使用之前需要手工添加和配置。</p>\n<p>以下是网口IPv6地址的实体ID，该实体的值是IPv6地址：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">entity_id: sensor.system_monitor_ipv6_address_eth0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Dynv6-Rest-API\"><a href=\"#Dynv6-Rest-API\" class=\"headerlink\" title=\"Dynv6 Rest API\"></a>Dynv6 Rest API</h2><p><a href=\"https://dynv6.github.io/api-spec/\">REST API for dynv6</a></p>\n<p><strong>Rest API URL</strong><br><a href=\"https://dynv6.com/api/v2\">https://dynv6.com/api/v2</a></p>\n<p>Dynv6 Rest API主要分为两大类：<strong>Zones</strong>和<strong>Records</strong>。</p>\n<h3 id=\"Zones\"><a href=\"#Zones\" class=\"headerlink\" title=\"Zones\"></a>Zones</h3><p><strong>GET</strong>          Get a list of records<br><strong>POST</strong>       Add a new record<br><strong>GET</strong>          Get details for a record<br><strong>PATCH</strong>     Update an existing record<br><strong>DEL</strong>           Delete a record</p>\n<h3 id=\"Records\"><a href=\"#Records\" class=\"headerlink\" title=\"Records\"></a>Records</h3><p><strong>GET</strong>          Get a list of zones<br><strong>POST</strong>       Register a new zone<br><strong>GET</strong>          Get details for a zone<br><strong>PATCH</strong>     Update an existing zone<br><strong>DEL</strong>           Delete the zone<br><strong>GET</strong>           Get details of a zone by its name</p>\n<p>下载：<a href=\"openapi.json\">openapi.json</a></p>\n<h2 id=\"Command-Line\"><a href=\"#Command-Line\" class=\"headerlink\" title=\"Command Line\"></a>Command Line</h2><p><strong>Command Line</strong>是Home Assistant中的一个集成功能，可以通过命令的方式，定义一种传感器实体。因此，通过该集成，可以定义一个二进制传感器，检测Dynv6 Rest API的网络连接性。</p>\n<h3 id=\"nc工具\"><a href=\"#nc工具\" class=\"headerlink\" title=\"nc工具\"></a>nc工具</h3><p>为了检测Dynv6 Rest API的网络连接性，可以使用命令行工具<code>nc</code>。</p>\n<p>以下命令可以用来检测Home Assistant和Dynv6 Rest API服务之间的网络连接性。如果Home Assistant与Dynv6 Rest API服务的TCP 443端口连接成功，返回“success”，否则返回“fail”。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">nc -6z -w 2 dynv6.com 443 &gt; /dev/null 2&gt;&amp;1 &amp;&amp; echo success || echo fail&#x27;&quot;\t</span><br></pre></td></tr></table></figure>\n\n<p>参数说明：</p>\n<p>-6        指定nc使用本机的IPv6地址。使用该选项，主要是为了确保IPv6已经更新完成，并能够与Dynv6 API服务之间正常通讯，这也是为了避免前面所提到的，自己写的脚本中的“小瑕疵”。<br>-z         nc只做端口扫描，不传输数据。<br>-w        如果连接不上，2秒后超时。</p>\n<h3 id=\"SSH远程命令\"><a href=\"#SSH远程命令\" class=\"headerlink\" title=\"SSH远程命令\"></a>SSH远程命令</h3><p>另外，由于Home Assistant是通过容器的方式安装，并且容器中<code>nc</code>工具的版本不支持IPv6，所以只能考虑用主机的<code>nc</code>。为了能调用主机的<code>nc</code>，决定使用SSH的方式远程调用命令。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh -o StrictHostKeychecking=no pi@pi -i /config/.ssh/id_rsa &#x27;nc -6z -w 2 \\</span><br><span class=\"line\">\t\t\t dynv6.com 443 &gt; /dev/null 2&gt;&amp;1 &amp;&amp; echo success || echo fail&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>参数说明：</p>\n<p>-o StrictHostKeychecking&#x3D;no      登录时不需要验证目标主机的Key<br>-i &#x2F;config&#x2F;.ssh&#x2F;id_rsa                        私钥文件的位置</p>\n<h3 id=\"configuration-yaml\"><a href=\"#configuration-yaml\" class=\"headerlink\" title=\"configuration.yaml\"></a>configuration.yaml</h3><p>以下是Home Assistant的配置文件<code>configuration.yaml</code>中的详细配置信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">- binary_sensor:\t</span><br><span class=\"line\">\tname: &#x27;Dynv6 API&#x27;\t</span><br><span class=\"line\">\tcommand: &quot;ssh -o StrictHostKeychecking=no pi@pi -i /config/.ssh/id_rsa &#x27;nc -6z -w 2 \\</span><br><span class=\"line\">\t\t\t dynv6.com 443 &gt; /dev/null 2&gt;&amp;1 &amp;&amp; echo success || echo fail&#x27;&quot;\t</span><br><span class=\"line\">\tpayload_on: success\t</span><br><span class=\"line\">\tpayload_off: fail\t</span><br><span class=\"line\">\tscan_interval: 60\t</span><br><span class=\"line\">\ticon: mdi:api\t</span><br><span class=\"line\">\tunique_id: cmd_dynv6_api\t</span><br><span class=\"line\">\tdevice_class: connectivity</span><br></pre></td></tr></table></figure>\n\n<p>以上配置定义了一个二进制传感器，该传感器的名字为“Dynv6 API”，每60秒执行一次网络连接性测试，如果成功则返回“success”，否则返回“fail”。</p>\n<h2 id=\"RESTful-Command\"><a href=\"#RESTful-Command\" class=\"headerlink\" title=\"RESTful Command\"></a>RESTful Command</h2><p><strong>RESTful Command</strong>是Home Assistant中的一个集成功能，通过该集成，可以定义一个对Rest API的操作请求，执行DDNS记录的更新。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">rest_command:</span><br><span class=\"line\">\tdynv6_update_zone:</span><br><span class=\"line\">\turl: https://dynv6.com/api/v2/zones/&lt;zone_id&gt;</span><br><span class=\"line\">\tmethod: patch</span><br><span class=\"line\">\tcontent_type: application/json</span><br><span class=\"line\">\theaders:\t</span><br><span class=\"line\">\t\tauthorization: &#x27;Bearer &lt;Token&gt;&#x27;</span><br><span class=\"line\">\tpayload: &#x27;&#123;&quot;ipv6prefix&quot;:&quot;&#123;&#123; states(&quot;sensor.system_monitor_ipv6_address_eth0&quot;) &#125;&#125;&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>url               zone_id需要替换成与Zone对应的id。<br>method     更新Zone的方法需要用PATCH。<br>authorization        需要用Token。<br>payload:    更新后的IPv6地址，此处是读取传感器<code>sensor.system_monitor_ipv6_address_eth0</code>的值。</p>\n<h2 id=\"自动化\"><a href=\"#自动化\" class=\"headerlink\" title=\"自动化\"></a>自动化</h2><p>在Home Assistant中，创建一个名为“DDNS｜自动更新动态域名”的自动化，该自动化可以实现自动更新DDNS记录的需求。</p>\n<h3 id=\"trigger\"><a href=\"#trigger\" class=\"headerlink\" title=\"trigger\"></a>trigger</h3><p>如果传感器<code>sensor.system_monitor_ipv6_address_eth0</code>值发生变化，触发器就会被自动触发。</p>\n<p>to: null 传感器的值发生任何变化都会导致触发器被触发。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">trigger:</span><br><span class=\"line\">  - platform: state</span><br><span class=\"line\">    entity_id:</span><br><span class=\"line\">      - sensor.system_monitor_ipv6_address_eth0</span><br><span class=\"line\">    to: null</span><br><span class=\"line\">    enabled: true</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"condition\"><a href=\"#condition\" class=\"headerlink\" title=\"condition\"></a>condition</h3><p>触发器被触发的先决条件是，二进制传感器<code>binary_sensor.dynv6_api</code>的状态必须是<code>on</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">condition:</span><br><span class=\"line\">  - condition: state</span><br><span class=\"line\">    entity_id: binary_sensor.dynv6_api</span><br><span class=\"line\">    state: &quot;on&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"action\"><a href=\"#action\" class=\"headerlink\" title=\"action\"></a>action</h3><p>当自动化被触发器成功触发后，就会执行操作<code>rest_command.dynv6_update_zone</code>，该操作将执行DDNS记录的更新。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">action:</span><br><span class=\"line\">  - action: rest_command.dynv6_update_zone</span><br><span class=\"line\">    data: &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"configuration-yaml-1\"><a href=\"#configuration-yaml-1\" class=\"headerlink\" title=\"configuration.yaml\"></a>configuration.yaml</h3><p>以下是自动化的详细配置信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">alias: DDNS｜自动更新动态域名</span><br><span class=\"line\">description: &quot;&quot;</span><br><span class=\"line\">trigger:</span><br><span class=\"line\">  - platform: state</span><br><span class=\"line\">    entity_id:</span><br><span class=\"line\">      - sensor.system_monitor_ipv6_address_eth0</span><br><span class=\"line\">    to: null</span><br><span class=\"line\">    enabled: true</span><br><span class=\"line\">condition:</span><br><span class=\"line\">  - condition: state</span><br><span class=\"line\">    entity_id: binary_sensor.dynv6_api</span><br><span class=\"line\">    state: &quot;on&quot;</span><br><span class=\"line\">action:</span><br><span class=\"line\">  - action: rest_command.dynv6_update_zone</span><br><span class=\"line\">    data: &#123;&#125;</span><br><span class=\"line\">mode: single</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"缘起\"><a href=\"#缘起\" class=\"headerlink\" title=\"缘起\"></a>缘起</h2><p>由于家中的宽带运营商不提供公网IPv4地址，所以一直都没有将Home Assistant发布到公网。最近无意中从网上了解到可以使用IPv6的公网地址，经过测试，确实有效。</p>\n<p>考虑到IPv6地址是动态分配的，间隔一段时间就会自动更新为新的IPv6地址，于是就在免费的DDNS服务商<a href=\"https://dynv6.com/\">Dynv6</a>申请了动态域名。根据Dynv6官方API文档介绍，IPv6不支持用<code>Remote Access API</code>，也就意味着不支持用<a href=\"https://ddclient.net/\">ddclient</a>作为客户端，来自动更新DDNS记录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">### DynDNS API</span><br><span class=\"line\"></span><br><span class=\"line\">We implemented the dyn.com [Remote Access API](https://help.dyn.com/remote-access-api/) that is also known as the _Members NIC Update API_ or _DNS Update API_. It can only be used to update the IPv4 address of a zone.</span><br><span class=\"line\"></span><br><span class=\"line\">To use the endpoint https://dynv6.com/nic/update please set the server in your client to &#x27;dynv6.com&#x27;.</span><br></pre></td></tr></table></figure>\n\n<p>根据<a href=\"https://dynv6.github.io/api-spec/\">REST API for dynv6</a>文档，自己用Python写了一个脚本，用于自动更新DDNS记录。经过一段时间的使用，基本能满足需求，但是仍然有一些小瑕疵，比如运营商自动分配IPv6地址的过程中，有时候会出现短时间内（5-10分钟）多次分配IP地址的情况，并且网络也会变得很不稳定，这时会导致DDNS更新出现问题。</p>\n<p>最近在使用Home Assistant的过程中，发现了<code>RESTful Command</code>的集成，于是想到为何不干脆使用Home Assistant来完成DDNS记录的更新，这样还省去了单独维护Python脚本的时间成本。</p>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>其实需求很简单，就是当Home Assistant的IPv6地址自动更新为新地址的时候，Home Assistant自动将新地址更新到<code>Dynv6</code>的动态域名记录中。</p>\n<h3 id=\"具体细节\"><a href=\"#具体细节\" class=\"headerlink\" title=\"具体细节\"></a>具体细节</h3><p>为了实现上述需求，需要考虑以下细节：</p>\n<ul>\n<li><p>触发器</p>\n<p>  Home Assistant会实时监控公网IPv6地址的变化，当IP地址发生变化，就会触发Home Assistant更新DDNS记录的动作。</p>\n</li>\n<li><p>触发的先决条件</p>\n<p>  Home Assistant需要实时监控Dynv6 Rest API的网络连接，以确保可以成功更新DDNS记录。如果网络连接异常，即使公网IPv6地址发生改变，也不会触发Home Assistant的更新DDNS记录的动作。</p>\n</li>\n<li><p>动作</p>\n<p>  Home Assistant执行更新DDNS记录的动作。</p>\n</li>\n</ul>\n<h2 id=\"System-Monitor\"><a href=\"#System-Monitor\" class=\"headerlink\" title=\"System Monitor\"></a>System Monitor</h2><p><strong>System Monitor</strong>可以用来监控CPU、内存、硬盘等硬件信息，在这里，主要用来实时获取网口的IPv6地址信息。当IPv6地址发生改变时，就可以触发Home Assistant的自动化操作。</p>\n<p><strong>System Monitor</strong>是Home Assistant的一个集成，或者说是扩展功能，使用之前需要手工添加和配置。</p>\n<p>以下是网口IPv6地址的实体ID，该实体的值是IPv6地址：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">entity_id: sensor.system_monitor_ipv6_address_eth0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Dynv6-Rest-API\"><a href=\"#Dynv6-Rest-API\" class=\"headerlink\" title=\"Dynv6 Rest API\"></a>Dynv6 Rest API</h2><p><a href=\"https://dynv6.github.io/api-spec/\">REST API for dynv6</a></p>\n<p><strong>Rest API URL</strong><br><a href=\"https://dynv6.com/api/v2\">https://dynv6.com/api/v2</a></p>\n<p>Dynv6 Rest API主要分为两大类：<strong>Zones</strong>和<strong>Records</strong>。</p>\n<h3 id=\"Zones\"><a href=\"#Zones\" class=\"headerlink\" title=\"Zones\"></a>Zones</h3><p><strong>GET</strong>          Get a list of records<br><strong>POST</strong>       Add a new record<br><strong>GET</strong>          Get details for a record<br><strong>PATCH</strong>     Update an existing record<br><strong>DEL</strong>           Delete a record</p>\n<h3 id=\"Records\"><a href=\"#Records\" class=\"headerlink\" title=\"Records\"></a>Records</h3><p><strong>GET</strong>          Get a list of zones<br><strong>POST</strong>       Register a new zone<br><strong>GET</strong>          Get details for a zone<br><strong>PATCH</strong>     Update an existing zone<br><strong>DEL</strong>           Delete the zone<br><strong>GET</strong>           Get details of a zone by its name</p>\n<p>下载：<a href=\"openapi.json\">openapi.json</a></p>\n<h2 id=\"Command-Line\"><a href=\"#Command-Line\" class=\"headerlink\" title=\"Command Line\"></a>Command Line</h2><p><strong>Command Line</strong>是Home Assistant中的一个集成功能，可以通过命令的方式，定义一种传感器实体。因此，通过该集成，可以定义一个二进制传感器，检测Dynv6 Rest API的网络连接性。</p>\n<h3 id=\"nc工具\"><a href=\"#nc工具\" class=\"headerlink\" title=\"nc工具\"></a>nc工具</h3><p>为了检测Dynv6 Rest API的网络连接性，可以使用命令行工具<code>nc</code>。</p>\n<p>以下命令可以用来检测Home Assistant和Dynv6 Rest API服务之间的网络连接性。如果Home Assistant与Dynv6 Rest API服务的TCP 443端口连接成功，返回“success”，否则返回“fail”。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">nc -6z -w 2 dynv6.com 443 &gt; /dev/null 2&gt;&amp;1 &amp;&amp; echo success || echo fail&#x27;&quot;\t</span><br></pre></td></tr></table></figure>\n\n<p>参数说明：</p>\n<p>-6        指定nc使用本机的IPv6地址。使用该选项，主要是为了确保IPv6已经更新完成，并能够与Dynv6 API服务之间正常通讯，这也是为了避免前面所提到的，自己写的脚本中的“小瑕疵”。<br>-z         nc只做端口扫描，不传输数据。<br>-w        如果连接不上，2秒后超时。</p>\n<h3 id=\"SSH远程命令\"><a href=\"#SSH远程命令\" class=\"headerlink\" title=\"SSH远程命令\"></a>SSH远程命令</h3><p>另外，由于Home Assistant是通过容器的方式安装，并且容器中<code>nc</code>工具的版本不支持IPv6，所以只能考虑用主机的<code>nc</code>。为了能调用主机的<code>nc</code>，决定使用SSH的方式远程调用命令。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh -o StrictHostKeychecking=no pi@pi -i /config/.ssh/id_rsa &#x27;nc -6z -w 2 \\</span><br><span class=\"line\">\t\t\t dynv6.com 443 &gt; /dev/null 2&gt;&amp;1 &amp;&amp; echo success || echo fail&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>参数说明：</p>\n<p>-o StrictHostKeychecking&#x3D;no      登录时不需要验证目标主机的Key<br>-i &#x2F;config&#x2F;.ssh&#x2F;id_rsa                        私钥文件的位置</p>\n<h3 id=\"configuration-yaml\"><a href=\"#configuration-yaml\" class=\"headerlink\" title=\"configuration.yaml\"></a>configuration.yaml</h3><p>以下是Home Assistant的配置文件<code>configuration.yaml</code>中的详细配置信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">- binary_sensor:\t</span><br><span class=\"line\">\tname: &#x27;Dynv6 API&#x27;\t</span><br><span class=\"line\">\tcommand: &quot;ssh -o StrictHostKeychecking=no pi@pi -i /config/.ssh/id_rsa &#x27;nc -6z -w 2 \\</span><br><span class=\"line\">\t\t\t dynv6.com 443 &gt; /dev/null 2&gt;&amp;1 &amp;&amp; echo success || echo fail&#x27;&quot;\t</span><br><span class=\"line\">\tpayload_on: success\t</span><br><span class=\"line\">\tpayload_off: fail\t</span><br><span class=\"line\">\tscan_interval: 60\t</span><br><span class=\"line\">\ticon: mdi:api\t</span><br><span class=\"line\">\tunique_id: cmd_dynv6_api\t</span><br><span class=\"line\">\tdevice_class: connectivity</span><br></pre></td></tr></table></figure>\n\n<p>以上配置定义了一个二进制传感器，该传感器的名字为“Dynv6 API”，每60秒执行一次网络连接性测试，如果成功则返回“success”，否则返回“fail”。</p>\n<h2 id=\"RESTful-Command\"><a href=\"#RESTful-Command\" class=\"headerlink\" title=\"RESTful Command\"></a>RESTful Command</h2><p><strong>RESTful Command</strong>是Home Assistant中的一个集成功能，通过该集成，可以定义一个对Rest API的操作请求，执行DDNS记录的更新。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">rest_command:</span><br><span class=\"line\">\tdynv6_update_zone:</span><br><span class=\"line\">\turl: https://dynv6.com/api/v2/zones/&lt;zone_id&gt;</span><br><span class=\"line\">\tmethod: patch</span><br><span class=\"line\">\tcontent_type: application/json</span><br><span class=\"line\">\theaders:\t</span><br><span class=\"line\">\t\tauthorization: &#x27;Bearer &lt;Token&gt;&#x27;</span><br><span class=\"line\">\tpayload: &#x27;&#123;&quot;ipv6prefix&quot;:&quot;&#123;&#123; states(&quot;sensor.system_monitor_ipv6_address_eth0&quot;) &#125;&#125;&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>url               zone_id需要替换成与Zone对应的id。<br>method     更新Zone的方法需要用PATCH。<br>authorization        需要用Token。<br>payload:    更新后的IPv6地址，此处是读取传感器<code>sensor.system_monitor_ipv6_address_eth0</code>的值。</p>\n<h2 id=\"自动化\"><a href=\"#自动化\" class=\"headerlink\" title=\"自动化\"></a>自动化</h2><p>在Home Assistant中，创建一个名为“DDNS｜自动更新动态域名”的自动化，该自动化可以实现自动更新DDNS记录的需求。</p>\n<h3 id=\"trigger\"><a href=\"#trigger\" class=\"headerlink\" title=\"trigger\"></a>trigger</h3><p>如果传感器<code>sensor.system_monitor_ipv6_address_eth0</code>值发生变化，触发器就会被自动触发。</p>\n<p>to: null 传感器的值发生任何变化都会导致触发器被触发。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">trigger:</span><br><span class=\"line\">  - platform: state</span><br><span class=\"line\">    entity_id:</span><br><span class=\"line\">      - sensor.system_monitor_ipv6_address_eth0</span><br><span class=\"line\">    to: null</span><br><span class=\"line\">    enabled: true</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"condition\"><a href=\"#condition\" class=\"headerlink\" title=\"condition\"></a>condition</h3><p>触发器被触发的先决条件是，二进制传感器<code>binary_sensor.dynv6_api</code>的状态必须是<code>on</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">condition:</span><br><span class=\"line\">  - condition: state</span><br><span class=\"line\">    entity_id: binary_sensor.dynv6_api</span><br><span class=\"line\">    state: &quot;on&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"action\"><a href=\"#action\" class=\"headerlink\" title=\"action\"></a>action</h3><p>当自动化被触发器成功触发后，就会执行操作<code>rest_command.dynv6_update_zone</code>，该操作将执行DDNS记录的更新。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">action:</span><br><span class=\"line\">  - action: rest_command.dynv6_update_zone</span><br><span class=\"line\">    data: &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"configuration-yaml-1\"><a href=\"#configuration-yaml-1\" class=\"headerlink\" title=\"configuration.yaml\"></a>configuration.yaml</h3><p>以下是自动化的详细配置信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">alias: DDNS｜自动更新动态域名</span><br><span class=\"line\">description: &quot;&quot;</span><br><span class=\"line\">trigger:</span><br><span class=\"line\">  - platform: state</span><br><span class=\"line\">    entity_id:</span><br><span class=\"line\">      - sensor.system_monitor_ipv6_address_eth0</span><br><span class=\"line\">    to: null</span><br><span class=\"line\">    enabled: true</span><br><span class=\"line\">condition:</span><br><span class=\"line\">  - condition: state</span><br><span class=\"line\">    entity_id: binary_sensor.dynv6_api</span><br><span class=\"line\">    state: &quot;on&quot;</span><br><span class=\"line\">action:</span><br><span class=\"line\">  - action: rest_command.dynv6_update_zone</span><br><span class=\"line\">    data: &#123;&#125;</span><br><span class=\"line\">mode: single</span><br></pre></td></tr></table></figure>"},{"title":"用Home Assistanat跟踪汽油价格","date":"2024-09-29T08:48:00.000Z","_content":"\n## 缘起\n\n虽然新能源汽车越来越普及，但是就目前而言，传统的燃油车仍然是占比最高的车型。因此，每次油价的调整自然会备受车主的关注。\n\n由于平时懒得打开App查看油价，所以每次加油时才会看一眼加油站的标价。因此，其实本人对汽油的价格并不感冒。但是，最近一直在“折腾”Home Assistant，脑海中浮现的想法都是围绕着它展开，于是就想到了用Home Assistant来跟踪油价的变化。\n\n## 需求\n\n首先，汽油的价格能够被实时获取，并且获得的数据能够被存储到Home Assistant中。当汽油的价格发生变化时，例如上涨或者下跌，Home Assistant可以发送通知到本人的手机。\n\n## 数据源\n\n在网上查找了一下关于汽油价格的网站，发现以下网站的信息比较全面，并且提供的油价可以精确到区级。\n\nhttp://www.qiyoujiage.com/\n\n下面以上海为例，访问的网址是： http://www.qiyoujiage.com/shanghai.shtml ，网页的部分源代码如下：\n\n\\<dl> \\<dt> \\<dd>是HTML中的一套组合标签，可以用于制作网页中的表格。\n\n```\n<div id=\"youjia\">\n\t<dl>\n\t\t<dt>上海92#汽油</dt>\n\t\t<dd>7.34</dd>\n\t</dl>\n\t<dl>\n\t\t<dt>上海95#汽油</dt>\n\t\t<dd>7.81</dd>\n\t</dl>\n\t<dl>\n\t\t<dt>上海98#汽油</dt>\n\t\t<dd>9.71</dd>\n\t</dl>\n\t<dl>\n\t\t<dt>上海0#柴油</dt>\n\t\t<dd>6.99</dd>\n\t</dl>\n</div>\n```\n\n## Beautiful Soup\n\n`Beautiful Soup`是一款非常著名的Python第三方库，可以用来解析HTML文本，且非常简单易用。\n\n首先，用`Requests`获取网页的内容，并将返回的结果存储到`response`变量。\n\n```python\nimport requests\nfrom bs4 import BeautifulSoup\nimport json\nfrom datetime import datetime\n\nurl = 'http://www.qiyoujiage.com/shanghai.shtml'\nresponse = requests.get(url, timeout=(5, 10))\n```\n\n用`Beautiful Soup`来解析网页内容（`response.content`），先查找所有`dl`标签，然后用`for`循环语句迭代每一个`dl`标签的内容，如果找到关键字`92`，就结束循环，并返回`name`和`price`。\n\n为了便于Home Assistant处理脚本返回的值，此处最终结果以JSON字符串的格式输出。\n\n```python\nformat_string = '%Y-%m-%d %H:%M:%S'\nnow = datetime.strftime(datetime.now(), format_string)\n\nyoujia_92 = {}\nsoup = BeautifulSoup(response.content, 'html.parser')\nfor dl in soup.find_all('dl'):\n\tname = dl.find('dt').text.strip()\n\tvalue = float(dl.find('dd').text.strip())\n\tif '92' in name:\n\t\tyoujia_92['name'] = name\n\t\tyoujia_92['price'] = value\n\t\tyoujia_92['last_update'] = now\n\t\tprint(json.dumps(youjia_92))\n\t\tbreak\n```\n\n运行以上代码，就会得到下面的结果：\n\n```python\n{\"name\": \"上海92#汽油\", \"price\": 7.34, \"last_update\": \"2024-09-28 12:33:01\"}\n```\n\n## Command Line\n\n打开并编辑Home Assistant的配置文件`configuration.yaml`，添加传感器的配置内容。\n\n```yaml\ncommand_line:\n\t- sensor:\n\t\tname: \"上海92#油价\"\n\t\tcommand: python3 ./scripts/oil_price/oil_price.py\n\t\tjson_attributes:\n\t\t\t- name\n\t\t\t- last_update\n\t\tvalue_template: \"{{ value_json.price }}\"\n\t\tdevice_class: monetary\n\t\tunit_of_measurement: 元\n\t\tunique_id: command_oil_price\n\t\tscan_interval: 7200\n\t\tcommand_timeout: 60\n```\n\n配置参数说明：\n\nname                         传感器的名称\ncommand                需要执行的命令或者脚本\njson_attributes       传感器的属性，此处有两个属性：name和last_update\nvalue_template      获取命令或者脚本返回的值\ndevice_class           实体的类型，Home Assistant会根据设置的类型，在Dashboard中适配相应的图表\nunit_of_measurement   值的单位\nscan_interval          执行脚本的时间间隔，默认单位为“秒”\ncommand_timeout  命令或者脚本默认15秒后超时，此处设置为60秒\n\n完成以上配置，并重载命令行配置以后，在Home Assistant中就会新增一个实体，该实体的标识符为\n`sensor.shang_hai_92_you_jie`。\n\n该实体的状态属性如下：\n\n```\nname: 上海92#汽油\nlast_update: \"2024-09-29 16:19:12\"\nprice_changed: 油价下跌\nunit_of_measurement: 元\ndevice_class: monetary\nicon: mdi:gas-station\nfriendly_name: 上海92#油价\n```\n\n## 油价涨跌变化\n\n为了能跟踪油价的涨跌变化，并且可以在第一时间接收到关于油价涨跌的信息，需要根据油价在发生变化前后的比较，来判断油价的涨跌。\n\n**弯路：** 根据文档[automation | trigger state](https://www.home-assistant.io/docs/automation/templating/#state)，自动化的触发器可以提供触发前后的数据：`trigger.from_state`和`trigger.to_state`，但是实际测试过程中，发现如果触发器是基于状态（state）的变化，而不是数值区间（numeric_state）的变化，则无法在消息通知中通过`jinja`模板来进行数值对比。\n\n因此，我决定通过执行脚本来反映油价的涨跌情况。那么，如何在脚本中获取油价变化前的数据呢？此时，我想到了用[home assistant rest api](https://developers.home-assistant.io/docs/api/rest/)。在获取最新油价之前，先从Home Assistant获取当前的油价信息。\n\n```python\nfrom requests.packages.urllib3.exceptions import InsecureRequestWarning\n\nrest_url = 'https://localhost:8123/api/states/<entity_id>'\ntoken = <token id>\n\nheaders = {\n\t\"Authorization\": f\"Bearer {token}\",\n\t\"Content-Type\": \"application/json\"\n}\n```\n\n请将`entity_id`换成实体的真实ID标识符。长期有效的Token需要在Home Assistant管理界面的个人配置文件中生成，具体可以参考文档：[Authentication](https://www.home-assistant.io/docs/authentication/#your-account-profile)\n\n```python\nprevious_price = 0\ntry:\n\trequests.packages.urllib3.disable_warnings(InsecureRequestWarning)\n\tresponse_api = requests.get(\n\t\trest_url, headers=headers, verify=False, timeout=(5, 10)\n\t)\n\tprevious_price = float(response_api.json()['state'])\nexcept Exception as err:\n\tpass\n```\n\n因为用`requests`访问API的时候会出现SSL证书错误的告警信息，且访问会失败，所以需要添加参数`verify=Fales`，这样就不会对SSL证书进行检查。但是，仍然会打印告警信息。因此，还需要用以下方法关闭告警信息。\n\n```python\nfrom requests.packages.urllib3.exceptions import InsecureRequestWarning\n\nrequests.packages.urllib3.disable_warnings(InsecureRequestWarning)\n```\n\n通过以上代码，就获取到了油价变化前的价格`previous_price`。\n\n通过跟最新油价的比较，就可以判断油价的上涨和下跌。这样，油价传感器的属性又增加了一项`price_changed`。\n\n```python\ncurrent_price = youjia_92['price']\nif current_price > previous_price:\n\tyoujia_92['price_changed'] = '油价上涨'\nelif current_price < previous_price:\n\tyoujia_92['price_changed'] = '油价下跌'\nelse:\n\tyoujia_92['price_changed'] = 'N/A'\n```\n\n## 自动化\n\n### trigger\n\n当实体`sensor.hui_shan_92_you_jie`的属性`price_changed`值从`N/A`变化成任何其它状态，自动化都会被触发。\n\n```\ntrigger:\n  - platform: state\n    entity_id:\n      - sensor.shang_hai_92_you_jie\n    attribute: price_changed\n    from: N/A\n```\n\n### action\n\n自动化触发后，执行通知动作，将通知消息发送到目标手机，消息的标题是实体`sensor.shang_hai_92_you_jie`的属性值`price_changed`，消息的正文是自动化触发前的价格`{{ trigger.to_state.state }}`和触发后的价格`{{ trigger.from_state.state }}`。\n\n```\naction:\n  - action: notify.mobile_app_iphone\n    metadata: {}\n    data:\n      message: 当前价格：{{ trigger.to_state.state }} 以前价格：{{ trigger.from_state.state }}\n      title: \"{{ state_attr('sensor.shang_hai_92_you_jie', 'price_changed') }}\"\n      data:\n        push:\n          sound: Doorbell.caf\n```\n\n手机上收到的通知消息见下图：\n\n![通知消息](F8B7D9EE-6145-4C58-AF0D-72244715D40B_1_201_a.jpeg)\n\n## 开发者工具\n\nHome Assistant的开发者工具中有两项功能对于测试很有帮助，分别是：**设置状态**和**动作**。\n\n### 设置状态\n\n设置状态可以改变实体的状态值，例如，可以改变实体`sensor.shang_hai_92_you_jie`的油价，这样就可以帮助测试自动化的运行结果是否正确。例如，真实油价是7.34，我们就可以将油价改成7.50，然后当传感器再次获取到真实油价的时候，就可以触发自动化的运行。\n\n打开**开发者工具**，在**状态**中可以**设置状态**的选项。\n\n![开发者工具_设置状态](Pasted_image_20240929162823.png)\n\n### 动作\n\n由于传感器只能根据设定的时间间隔更新数据，没有手动更新的选项。但是，测试时需要立即获取到最新的数据，这时可以用`homeassistant.update_entity`来实现。\n\n打开**开发者工具**，进入**动作**页面，进入**YAML模式**，输入以下内容，或者也可以在**用户界面模式**下操作。点击**执行动作**后，就会更新实体`sensor.shang_hai_92_you_jie`。\n\n```\naction: homeassistant.update_entity\ndata:\n  entity_id:\n    - sensor.shang_hai_92_you_jie\n```\n\n## 参考资料\n\n[templating](https://www.home-assistant.io/docs/configuration/templating/)\n[jinja | templates](https://jinja.palletsprojects.com/en/latest/templates/)\n[memory of previous state](https://community.home-assistant.io/t/memory-of-previous-state/290288)\n[automation | trigger state](https://www.home-assistant.io/docs/automation/templating/#state)\n[manually refresh rest sensors](https://community.home-assistant.io/t/manually-refresh-rest-sensor/353208)\n[perform actions](https://www.home-assistant.io/docs/scripts/perform-actions/#homeassistant-services)\n[Automation: template value should be a string for dictionary value @ data[‘value_template’]. Got None](https://community.home-assistant.io/t/automation-template-value-should-be-a-string-for-dictionary-value-data-value-template-got-none/419519)\n[home assistant rest api](https://developers.home-assistant.io/docs/api/rest/)\n[# Python ‘requests’ Module: How to Disable Warnings](https://www.slingacademy.com/article/python-requests-module-how-to-disable-warnings/)\n","source":"_posts/Home_Assistant/用Home Assistanat跟踪汽油价格.md","raw":"---\ntitle: 用Home Assistanat跟踪汽油价格\ndate: 2024-9-29 16:48:00\ntags:\n  - home_assistant\ncategories:\n  - Home_Assistant\n---\n\n## 缘起\n\n虽然新能源汽车越来越普及，但是就目前而言，传统的燃油车仍然是占比最高的车型。因此，每次油价的调整自然会备受车主的关注。\n\n由于平时懒得打开App查看油价，所以每次加油时才会看一眼加油站的标价。因此，其实本人对汽油的价格并不感冒。但是，最近一直在“折腾”Home Assistant，脑海中浮现的想法都是围绕着它展开，于是就想到了用Home Assistant来跟踪油价的变化。\n\n## 需求\n\n首先，汽油的价格能够被实时获取，并且获得的数据能够被存储到Home Assistant中。当汽油的价格发生变化时，例如上涨或者下跌，Home Assistant可以发送通知到本人的手机。\n\n## 数据源\n\n在网上查找了一下关于汽油价格的网站，发现以下网站的信息比较全面，并且提供的油价可以精确到区级。\n\nhttp://www.qiyoujiage.com/\n\n下面以上海为例，访问的网址是： http://www.qiyoujiage.com/shanghai.shtml ，网页的部分源代码如下：\n\n\\<dl> \\<dt> \\<dd>是HTML中的一套组合标签，可以用于制作网页中的表格。\n\n```\n<div id=\"youjia\">\n\t<dl>\n\t\t<dt>上海92#汽油</dt>\n\t\t<dd>7.34</dd>\n\t</dl>\n\t<dl>\n\t\t<dt>上海95#汽油</dt>\n\t\t<dd>7.81</dd>\n\t</dl>\n\t<dl>\n\t\t<dt>上海98#汽油</dt>\n\t\t<dd>9.71</dd>\n\t</dl>\n\t<dl>\n\t\t<dt>上海0#柴油</dt>\n\t\t<dd>6.99</dd>\n\t</dl>\n</div>\n```\n\n## Beautiful Soup\n\n`Beautiful Soup`是一款非常著名的Python第三方库，可以用来解析HTML文本，且非常简单易用。\n\n首先，用`Requests`获取网页的内容，并将返回的结果存储到`response`变量。\n\n```python\nimport requests\nfrom bs4 import BeautifulSoup\nimport json\nfrom datetime import datetime\n\nurl = 'http://www.qiyoujiage.com/shanghai.shtml'\nresponse = requests.get(url, timeout=(5, 10))\n```\n\n用`Beautiful Soup`来解析网页内容（`response.content`），先查找所有`dl`标签，然后用`for`循环语句迭代每一个`dl`标签的内容，如果找到关键字`92`，就结束循环，并返回`name`和`price`。\n\n为了便于Home Assistant处理脚本返回的值，此处最终结果以JSON字符串的格式输出。\n\n```python\nformat_string = '%Y-%m-%d %H:%M:%S'\nnow = datetime.strftime(datetime.now(), format_string)\n\nyoujia_92 = {}\nsoup = BeautifulSoup(response.content, 'html.parser')\nfor dl in soup.find_all('dl'):\n\tname = dl.find('dt').text.strip()\n\tvalue = float(dl.find('dd').text.strip())\n\tif '92' in name:\n\t\tyoujia_92['name'] = name\n\t\tyoujia_92['price'] = value\n\t\tyoujia_92['last_update'] = now\n\t\tprint(json.dumps(youjia_92))\n\t\tbreak\n```\n\n运行以上代码，就会得到下面的结果：\n\n```python\n{\"name\": \"上海92#汽油\", \"price\": 7.34, \"last_update\": \"2024-09-28 12:33:01\"}\n```\n\n## Command Line\n\n打开并编辑Home Assistant的配置文件`configuration.yaml`，添加传感器的配置内容。\n\n```yaml\ncommand_line:\n\t- sensor:\n\t\tname: \"上海92#油价\"\n\t\tcommand: python3 ./scripts/oil_price/oil_price.py\n\t\tjson_attributes:\n\t\t\t- name\n\t\t\t- last_update\n\t\tvalue_template: \"{{ value_json.price }}\"\n\t\tdevice_class: monetary\n\t\tunit_of_measurement: 元\n\t\tunique_id: command_oil_price\n\t\tscan_interval: 7200\n\t\tcommand_timeout: 60\n```\n\n配置参数说明：\n\nname                         传感器的名称\ncommand                需要执行的命令或者脚本\njson_attributes       传感器的属性，此处有两个属性：name和last_update\nvalue_template      获取命令或者脚本返回的值\ndevice_class           实体的类型，Home Assistant会根据设置的类型，在Dashboard中适配相应的图表\nunit_of_measurement   值的单位\nscan_interval          执行脚本的时间间隔，默认单位为“秒”\ncommand_timeout  命令或者脚本默认15秒后超时，此处设置为60秒\n\n完成以上配置，并重载命令行配置以后，在Home Assistant中就会新增一个实体，该实体的标识符为\n`sensor.shang_hai_92_you_jie`。\n\n该实体的状态属性如下：\n\n```\nname: 上海92#汽油\nlast_update: \"2024-09-29 16:19:12\"\nprice_changed: 油价下跌\nunit_of_measurement: 元\ndevice_class: monetary\nicon: mdi:gas-station\nfriendly_name: 上海92#油价\n```\n\n## 油价涨跌变化\n\n为了能跟踪油价的涨跌变化，并且可以在第一时间接收到关于油价涨跌的信息，需要根据油价在发生变化前后的比较，来判断油价的涨跌。\n\n**弯路：** 根据文档[automation | trigger state](https://www.home-assistant.io/docs/automation/templating/#state)，自动化的触发器可以提供触发前后的数据：`trigger.from_state`和`trigger.to_state`，但是实际测试过程中，发现如果触发器是基于状态（state）的变化，而不是数值区间（numeric_state）的变化，则无法在消息通知中通过`jinja`模板来进行数值对比。\n\n因此，我决定通过执行脚本来反映油价的涨跌情况。那么，如何在脚本中获取油价变化前的数据呢？此时，我想到了用[home assistant rest api](https://developers.home-assistant.io/docs/api/rest/)。在获取最新油价之前，先从Home Assistant获取当前的油价信息。\n\n```python\nfrom requests.packages.urllib3.exceptions import InsecureRequestWarning\n\nrest_url = 'https://localhost:8123/api/states/<entity_id>'\ntoken = <token id>\n\nheaders = {\n\t\"Authorization\": f\"Bearer {token}\",\n\t\"Content-Type\": \"application/json\"\n}\n```\n\n请将`entity_id`换成实体的真实ID标识符。长期有效的Token需要在Home Assistant管理界面的个人配置文件中生成，具体可以参考文档：[Authentication](https://www.home-assistant.io/docs/authentication/#your-account-profile)\n\n```python\nprevious_price = 0\ntry:\n\trequests.packages.urllib3.disable_warnings(InsecureRequestWarning)\n\tresponse_api = requests.get(\n\t\trest_url, headers=headers, verify=False, timeout=(5, 10)\n\t)\n\tprevious_price = float(response_api.json()['state'])\nexcept Exception as err:\n\tpass\n```\n\n因为用`requests`访问API的时候会出现SSL证书错误的告警信息，且访问会失败，所以需要添加参数`verify=Fales`，这样就不会对SSL证书进行检查。但是，仍然会打印告警信息。因此，还需要用以下方法关闭告警信息。\n\n```python\nfrom requests.packages.urllib3.exceptions import InsecureRequestWarning\n\nrequests.packages.urllib3.disable_warnings(InsecureRequestWarning)\n```\n\n通过以上代码，就获取到了油价变化前的价格`previous_price`。\n\n通过跟最新油价的比较，就可以判断油价的上涨和下跌。这样，油价传感器的属性又增加了一项`price_changed`。\n\n```python\ncurrent_price = youjia_92['price']\nif current_price > previous_price:\n\tyoujia_92['price_changed'] = '油价上涨'\nelif current_price < previous_price:\n\tyoujia_92['price_changed'] = '油价下跌'\nelse:\n\tyoujia_92['price_changed'] = 'N/A'\n```\n\n## 自动化\n\n### trigger\n\n当实体`sensor.hui_shan_92_you_jie`的属性`price_changed`值从`N/A`变化成任何其它状态，自动化都会被触发。\n\n```\ntrigger:\n  - platform: state\n    entity_id:\n      - sensor.shang_hai_92_you_jie\n    attribute: price_changed\n    from: N/A\n```\n\n### action\n\n自动化触发后，执行通知动作，将通知消息发送到目标手机，消息的标题是实体`sensor.shang_hai_92_you_jie`的属性值`price_changed`，消息的正文是自动化触发前的价格`{{ trigger.to_state.state }}`和触发后的价格`{{ trigger.from_state.state }}`。\n\n```\naction:\n  - action: notify.mobile_app_iphone\n    metadata: {}\n    data:\n      message: 当前价格：{{ trigger.to_state.state }} 以前价格：{{ trigger.from_state.state }}\n      title: \"{{ state_attr('sensor.shang_hai_92_you_jie', 'price_changed') }}\"\n      data:\n        push:\n          sound: Doorbell.caf\n```\n\n手机上收到的通知消息见下图：\n\n![通知消息](F8B7D9EE-6145-4C58-AF0D-72244715D40B_1_201_a.jpeg)\n\n## 开发者工具\n\nHome Assistant的开发者工具中有两项功能对于测试很有帮助，分别是：**设置状态**和**动作**。\n\n### 设置状态\n\n设置状态可以改变实体的状态值，例如，可以改变实体`sensor.shang_hai_92_you_jie`的油价，这样就可以帮助测试自动化的运行结果是否正确。例如，真实油价是7.34，我们就可以将油价改成7.50，然后当传感器再次获取到真实油价的时候，就可以触发自动化的运行。\n\n打开**开发者工具**，在**状态**中可以**设置状态**的选项。\n\n![开发者工具_设置状态](Pasted_image_20240929162823.png)\n\n### 动作\n\n由于传感器只能根据设定的时间间隔更新数据，没有手动更新的选项。但是，测试时需要立即获取到最新的数据，这时可以用`homeassistant.update_entity`来实现。\n\n打开**开发者工具**，进入**动作**页面，进入**YAML模式**，输入以下内容，或者也可以在**用户界面模式**下操作。点击**执行动作**后，就会更新实体`sensor.shang_hai_92_you_jie`。\n\n```\naction: homeassistant.update_entity\ndata:\n  entity_id:\n    - sensor.shang_hai_92_you_jie\n```\n\n## 参考资料\n\n[templating](https://www.home-assistant.io/docs/configuration/templating/)\n[jinja | templates](https://jinja.palletsprojects.com/en/latest/templates/)\n[memory of previous state](https://community.home-assistant.io/t/memory-of-previous-state/290288)\n[automation | trigger state](https://www.home-assistant.io/docs/automation/templating/#state)\n[manually refresh rest sensors](https://community.home-assistant.io/t/manually-refresh-rest-sensor/353208)\n[perform actions](https://www.home-assistant.io/docs/scripts/perform-actions/#homeassistant-services)\n[Automation: template value should be a string for dictionary value @ data[‘value_template’]. Got None](https://community.home-assistant.io/t/automation-template-value-should-be-a-string-for-dictionary-value-data-value-template-got-none/419519)\n[home assistant rest api](https://developers.home-assistant.io/docs/api/rest/)\n[# Python ‘requests’ Module: How to Disable Warnings](https://www.slingacademy.com/article/python-requests-module-how-to-disable-warnings/)\n","slug":"Home_Assistant/用Home Assistanat跟踪汽油价格","published":1,"updated":"2024-09-29T08:56:21.121Z","_id":"cm1nccdd60000s2ec2e8u0qty","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"缘起\"><a href=\"#缘起\" class=\"headerlink\" title=\"缘起\"></a>缘起</h2><p>虽然新能源汽车越来越普及，但是就目前而言，传统的燃油车仍然是占比最高的车型。因此，每次油价的调整自然会备受车主的关注。</p>\n<p>由于平时懒得打开App查看油价，所以每次加油时才会看一眼加油站的标价。因此，其实本人对汽油的价格并不感冒。但是，最近一直在“折腾”Home Assistant，脑海中浮现的想法都是围绕着它展开，于是就想到了用Home Assistant来跟踪油价的变化。</p>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>首先，汽油的价格能够被实时获取，并且获得的数据能够被存储到Home Assistant中。当汽油的价格发生变化时，例如上涨或者下跌，Home Assistant可以发送通知到本人的手机。</p>\n<h2 id=\"数据源\"><a href=\"#数据源\" class=\"headerlink\" title=\"数据源\"></a>数据源</h2><p>在网上查找了一下关于汽油价格的网站，发现以下网站的信息比较全面，并且提供的油价可以精确到区级。</p>\n<p><a href=\"http://www.qiyoujiage.com/\">http://www.qiyoujiage.com/</a></p>\n<p>下面以上海为例，访问的网址是： <a href=\"http://www.qiyoujiage.com/shanghai.shtml\">http://www.qiyoujiage.com/shanghai.shtml</a> ，网页的部分源代码如下：</p>\n<p>&lt;dl&gt; &lt;dt&gt; &lt;dd&gt;是HTML中的一套组合标签，可以用于制作网页中的表格。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;youjia&quot;&gt;</span><br><span class=\"line\">\t&lt;dl&gt;</span><br><span class=\"line\">\t\t&lt;dt&gt;上海92#汽油&lt;/dt&gt;</span><br><span class=\"line\">\t\t&lt;dd&gt;7.34&lt;/dd&gt;</span><br><span class=\"line\">\t&lt;/dl&gt;</span><br><span class=\"line\">\t&lt;dl&gt;</span><br><span class=\"line\">\t\t&lt;dt&gt;上海95#汽油&lt;/dt&gt;</span><br><span class=\"line\">\t\t&lt;dd&gt;7.81&lt;/dd&gt;</span><br><span class=\"line\">\t&lt;/dl&gt;</span><br><span class=\"line\">\t&lt;dl&gt;</span><br><span class=\"line\">\t\t&lt;dt&gt;上海98#汽油&lt;/dt&gt;</span><br><span class=\"line\">\t\t&lt;dd&gt;9.71&lt;/dd&gt;</span><br><span class=\"line\">\t&lt;/dl&gt;</span><br><span class=\"line\">\t&lt;dl&gt;</span><br><span class=\"line\">\t\t&lt;dt&gt;上海0#柴油&lt;/dt&gt;</span><br><span class=\"line\">\t\t&lt;dd&gt;6.99&lt;/dd&gt;</span><br><span class=\"line\">\t&lt;/dl&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Beautiful-Soup\"><a href=\"#Beautiful-Soup\" class=\"headerlink\" title=\"Beautiful Soup\"></a>Beautiful Soup</h2><p><code>Beautiful Soup</code>是一款非常著名的Python第三方库，可以用来解析HTML文本，且非常简单易用。</p>\n<p>首先，用<code>Requests</code>获取网页的内容，并将返回的结果存储到<code>response</code>变量。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">from</span> bs4 <span class=\"keyword\">import</span> BeautifulSoup</span><br><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"></span><br><span class=\"line\">url = <span class=\"string\">&#x27;http://www.qiyoujiage.com/shanghai.shtml&#x27;</span></span><br><span class=\"line\">response = requests.get(url, timeout=(<span class=\"number\">5</span>, <span class=\"number\">10</span>))</span><br></pre></td></tr></table></figure>\n\n<p>用<code>Beautiful Soup</code>来解析网页内容（<code>response.content</code>），先查找所有<code>dl</code>标签，然后用<code>for</code>循环语句迭代每一个<code>dl</code>标签的内容，如果找到关键字<code>92</code>，就结束循环，并返回<code>name</code>和<code>price</code>。</p>\n<p>为了便于Home Assistant处理脚本返回的值，此处最终结果以JSON字符串的格式输出。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">format_string = <span class=\"string\">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span></span><br><span class=\"line\">now = datetime.strftime(datetime.now(), format_string)</span><br><span class=\"line\"></span><br><span class=\"line\">youjia_92 = &#123;&#125;</span><br><span class=\"line\">soup = BeautifulSoup(response.content, <span class=\"string\">&#x27;html.parser&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> dl <span class=\"keyword\">in</span> soup.find_all(<span class=\"string\">&#x27;dl&#x27;</span>):</span><br><span class=\"line\">\tname = dl.find(<span class=\"string\">&#x27;dt&#x27;</span>).text.strip()</span><br><span class=\"line\">\tvalue = <span class=\"built_in\">float</span>(dl.find(<span class=\"string\">&#x27;dd&#x27;</span>).text.strip())</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"string\">&#x27;92&#x27;</span> <span class=\"keyword\">in</span> name:</span><br><span class=\"line\">\t\tyoujia_92[<span class=\"string\">&#x27;name&#x27;</span>] = name</span><br><span class=\"line\">\t\tyoujia_92[<span class=\"string\">&#x27;price&#x27;</span>] = value</span><br><span class=\"line\">\t\tyoujia_92[<span class=\"string\">&#x27;last_update&#x27;</span>] = now</span><br><span class=\"line\">\t\t<span class=\"built_in\">print</span>(json.dumps(youjia_92))</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\n\n<p>运行以上代码，就会得到下面的结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;上海92#汽油&quot;</span>, <span class=\"string\">&quot;price&quot;</span>: <span class=\"number\">7.34</span>, <span class=\"string\">&quot;last_update&quot;</span>: <span class=\"string\">&quot;2024-09-28 12:33:01&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Command-Line\"><a href=\"#Command-Line\" class=\"headerlink\" title=\"Command Line\"></a>Command Line</h2><p>打开并编辑Home Assistant的配置文件<code>configuration.yaml</code>，添加传感器的配置内容。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">command_line:</span></span><br><span class=\"line\">\t<span class=\"bullet\">-</span> <span class=\"attr\">sensor:</span></span><br><span class=\"line\">\t\t<span class=\"attr\">name:</span> <span class=\"string\">&quot;上海92#油价&quot;</span></span><br><span class=\"line\">\t\t<span class=\"attr\">command:</span> <span class=\"string\">python3</span> <span class=\"string\">./scripts/oil_price/oil_price.py</span></span><br><span class=\"line\">\t\t<span class=\"attr\">json_attributes:</span></span><br><span class=\"line\">\t\t\t<span class=\"bullet\">-</span> <span class=\"string\">name</span></span><br><span class=\"line\">\t\t\t<span class=\"bullet\">-</span> <span class=\"string\">last_update</span></span><br><span class=\"line\">\t\t<span class=\"attr\">value_template:</span> <span class=\"string\">&quot;<span class=\"template-variable\">&#123;&#123; value_json.price &#125;&#125;</span>&quot;</span></span><br><span class=\"line\">\t\t<span class=\"attr\">device_class:</span> <span class=\"string\">monetary</span></span><br><span class=\"line\">\t\t<span class=\"attr\">unit_of_measurement:</span> <span class=\"string\">元</span></span><br><span class=\"line\">\t\t<span class=\"attr\">unique_id:</span> <span class=\"string\">command_oil_price</span></span><br><span class=\"line\">\t\t<span class=\"attr\">scan_interval:</span> <span class=\"number\">7200</span></span><br><span class=\"line\">\t\t<span class=\"attr\">command_timeout:</span> <span class=\"number\">60</span></span><br></pre></td></tr></table></figure>\n\n<p>配置参数说明：</p>\n<p>name                         传感器的名称<br>command                需要执行的命令或者脚本<br>json_attributes       传感器的属性，此处有两个属性：name和last_update<br>value_template      获取命令或者脚本返回的值<br>device_class           实体的类型，Home Assistant会根据设置的类型，在Dashboard中适配相应的图表<br>unit_of_measurement   值的单位<br>scan_interval          执行脚本的时间间隔，默认单位为“秒”<br>command_timeout  命令或者脚本默认15秒后超时，此处设置为60秒</p>\n<p>完成以上配置，并重载命令行配置以后，在Home Assistant中就会新增一个实体，该实体的标识符为<br><code>sensor.shang_hai_92_you_jie</code>。</p>\n<p>该实体的状态属性如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">name: 上海92#汽油</span><br><span class=\"line\">last_update: &quot;2024-09-29 16:19:12&quot;</span><br><span class=\"line\">price_changed: 油价下跌</span><br><span class=\"line\">unit_of_measurement: 元</span><br><span class=\"line\">device_class: monetary</span><br><span class=\"line\">icon: mdi:gas-station</span><br><span class=\"line\">friendly_name: 上海92#油价</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"油价涨跌变化\"><a href=\"#油价涨跌变化\" class=\"headerlink\" title=\"油价涨跌变化\"></a>油价涨跌变化</h2><p>为了能跟踪油价的涨跌变化，并且可以在第一时间接收到关于油价涨跌的信息，需要根据油价在发生变化前后的比较，来判断油价的涨跌。</p>\n<p><strong>弯路：</strong> 根据文档<a href=\"https://www.home-assistant.io/docs/automation/templating/#state\">automation | trigger state</a>，自动化的触发器可以提供触发前后的数据：<code>trigger.from_state</code>和<code>trigger.to_state</code>，但是实际测试过程中，发现如果触发器是基于状态（state）的变化，而不是数值区间（numeric_state）的变化，则无法在消息通知中通过<code>jinja</code>模板来进行数值对比。</p>\n<p>因此，我决定通过执行脚本来反映油价的涨跌情况。那么，如何在脚本中获取油价变化前的数据呢？此时，我想到了用<a href=\"https://developers.home-assistant.io/docs/api/rest/\">home assistant rest api</a>。在获取最新油价之前，先从Home Assistant获取当前的油价信息。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> requests.packages.urllib3.exceptions <span class=\"keyword\">import</span> InsecureRequestWarning</span><br><span class=\"line\"></span><br><span class=\"line\">rest_url = <span class=\"string\">&#x27;https://localhost:8123/api/states/&lt;entity_id&gt;&#x27;</span></span><br><span class=\"line\">token = &lt;token <span class=\"built_in\">id</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">headers = &#123;</span><br><span class=\"line\">\t<span class=\"string\">&quot;Authorization&quot;</span>: <span class=\"string\">f&quot;Bearer <span class=\"subst\">&#123;token&#125;</span>&quot;</span>,</span><br><span class=\"line\">\t<span class=\"string\">&quot;Content-Type&quot;</span>: <span class=\"string\">&quot;application/json&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请将<code>entity_id</code>换成实体的真实ID标识符。长期有效的Token需要在Home Assistant管理界面的个人配置文件中生成，具体可以参考文档：<a href=\"https://www.home-assistant.io/docs/authentication/#your-account-profile\">Authentication</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">previous_price = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">\trequests.packages.urllib3.disable_warnings(InsecureRequestWarning)</span><br><span class=\"line\">\tresponse_api = requests.get(</span><br><span class=\"line\">\t\trest_url, headers=headers, verify=<span class=\"literal\">False</span>, timeout=(<span class=\"number\">5</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\tprevious_price = <span class=\"built_in\">float</span>(response_api.json()[<span class=\"string\">&#x27;state&#x27;</span>])</span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> err:</span><br><span class=\"line\">\t<span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n\n<p>因为用<code>requests</code>访问API的时候会出现SSL证书错误的告警信息，且访问会失败，所以需要添加参数<code>verify=Fales</code>，这样就不会对SSL证书进行检查。但是，仍然会打印告警信息。因此，还需要用以下方法关闭告警信息。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> requests.packages.urllib3.exceptions <span class=\"keyword\">import</span> InsecureRequestWarning</span><br><span class=\"line\"></span><br><span class=\"line\">requests.packages.urllib3.disable_warnings(InsecureRequestWarning)</span><br></pre></td></tr></table></figure>\n\n<p>通过以上代码，就获取到了油价变化前的价格<code>previous_price</code>。</p>\n<p>通过跟最新油价的比较，就可以判断油价的上涨和下跌。这样，油价传感器的属性又增加了一项<code>price_changed</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">current_price = youjia_92[<span class=\"string\">&#x27;price&#x27;</span>]</span><br><span class=\"line\"><span class=\"keyword\">if</span> current_price &gt; previous_price:</span><br><span class=\"line\">\tyoujia_92[<span class=\"string\">&#x27;price_changed&#x27;</span>] = <span class=\"string\">&#x27;油价上涨&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">elif</span> current_price &lt; previous_price:</span><br><span class=\"line\">\tyoujia_92[<span class=\"string\">&#x27;price_changed&#x27;</span>] = <span class=\"string\">&#x27;油价下跌&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">\tyoujia_92[<span class=\"string\">&#x27;price_changed&#x27;</span>] = <span class=\"string\">&#x27;N/A&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自动化\"><a href=\"#自动化\" class=\"headerlink\" title=\"自动化\"></a>自动化</h2><h3 id=\"trigger\"><a href=\"#trigger\" class=\"headerlink\" title=\"trigger\"></a>trigger</h3><p>当实体<code>sensor.hui_shan_92_you_jie</code>的属性<code>price_changed</code>值从<code>N/A</code>变化成任何其它状态，自动化都会被触发。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">trigger:</span><br><span class=\"line\">  - platform: state</span><br><span class=\"line\">    entity_id:</span><br><span class=\"line\">      - sensor.shang_hai_92_you_jie</span><br><span class=\"line\">    attribute: price_changed</span><br><span class=\"line\">    from: N/A</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"action\"><a href=\"#action\" class=\"headerlink\" title=\"action\"></a>action</h3><p>自动化触发后，执行通知动作，将通知消息发送到目标手机，消息的标题是实体<code>sensor.shang_hai_92_you_jie</code>的属性值<code>price_changed</code>，消息的正文是自动化触发前的价格<code>&#123;&#123; trigger.to_state.state &#125;&#125;</code>和触发后的价格<code>&#123;&#123; trigger.from_state.state &#125;&#125;</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">action:</span><br><span class=\"line\">  - action: notify.mobile_app_iphone</span><br><span class=\"line\">    metadata: &#123;&#125;</span><br><span class=\"line\">    data:</span><br><span class=\"line\">      message: 当前价格：&#123;&#123; trigger.to_state.state &#125;&#125; 以前价格：&#123;&#123; trigger.from_state.state &#125;&#125;</span><br><span class=\"line\">      title: &quot;&#123;&#123; state_attr(&#x27;sensor.shang_hai_92_you_jie&#x27;, &#x27;price_changed&#x27;) &#125;&#125;&quot;</span><br><span class=\"line\">      data:</span><br><span class=\"line\">        push:</span><br><span class=\"line\">          sound: Doorbell.caf</span><br></pre></td></tr></table></figure>\n\n<p>手机上收到的通知消息见下图：</p>\n<p><img src=\"/2024/09/29/home-assistant/yong-home-assistanat-gen-zong-qi-you-jie-ge/F8B7D9EE-6145-4C58-AF0D-72244715D40B_1_201_a.jpeg\" alt=\"通知消息\"></p>\n<h2 id=\"开发者工具\"><a href=\"#开发者工具\" class=\"headerlink\" title=\"开发者工具\"></a>开发者工具</h2><p>Home Assistant的开发者工具中有两项功能对于测试很有帮助，分别是：<strong>设置状态</strong>和<strong>动作</strong>。</p>\n<h3 id=\"设置状态\"><a href=\"#设置状态\" class=\"headerlink\" title=\"设置状态\"></a>设置状态</h3><p>设置状态可以改变实体的状态值，例如，可以改变实体<code>sensor.shang_hai_92_you_jie</code>的油价，这样就可以帮助测试自动化的运行结果是否正确。例如，真实油价是7.34，我们就可以将油价改成7.50，然后当传感器再次获取到真实油价的时候，就可以触发自动化的运行。</p>\n<p>打开<strong>开发者工具</strong>，在<strong>状态</strong>中可以<strong>设置状态</strong>的选项。</p>\n<p><img src=\"/2024/09/29/home-assistant/yong-home-assistanat-gen-zong-qi-you-jie-ge/Pasted_image_20240929162823.png\" alt=\"开发者工具_设置状态\"></p>\n<h3 id=\"动作\"><a href=\"#动作\" class=\"headerlink\" title=\"动作\"></a>动作</h3><p>由于传感器只能根据设定的时间间隔更新数据，没有手动更新的选项。但是，测试时需要立即获取到最新的数据，这时可以用<code>homeassistant.update_entity</code>来实现。</p>\n<p>打开<strong>开发者工具</strong>，进入<strong>动作</strong>页面，进入<strong>YAML模式</strong>，输入以下内容，或者也可以在<strong>用户界面模式</strong>下操作。点击<strong>执行动作</strong>后，就会更新实体<code>sensor.shang_hai_92_you_jie</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">action: homeassistant.update_entity</span><br><span class=\"line\">data:</span><br><span class=\"line\">  entity_id:</span><br><span class=\"line\">    - sensor.shang_hai_92_you_jie</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://www.home-assistant.io/docs/configuration/templating/\">templating</a><br><a href=\"https://jinja.palletsprojects.com/en/latest/templates/\">jinja | templates</a><br><a href=\"https://community.home-assistant.io/t/memory-of-previous-state/290288\">memory of previous state</a><br><a href=\"https://www.home-assistant.io/docs/automation/templating/#state\">automation | trigger state</a><br><a href=\"https://community.home-assistant.io/t/manually-refresh-rest-sensor/353208\">manually refresh rest sensors</a><br><a href=\"https://www.home-assistant.io/docs/scripts/perform-actions/#homeassistant-services\">perform actions</a><br><a href=\"https://community.home-assistant.io/t/automation-template-value-should-be-a-string-for-dictionary-value-data-value-template-got-none/419519\">Automation: template value should be a string for dictionary value @ data[‘value_template’]. Got None</a><br><a href=\"https://developers.home-assistant.io/docs/api/rest/\">home assistant rest api</a><br><a href=\"https://www.slingacademy.com/article/python-requests-module-how-to-disable-warnings/\"># Python ‘requests’ Module: How to Disable Warnings</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"缘起\"><a href=\"#缘起\" class=\"headerlink\" title=\"缘起\"></a>缘起</h2><p>虽然新能源汽车越来越普及，但是就目前而言，传统的燃油车仍然是占比最高的车型。因此，每次油价的调整自然会备受车主的关注。</p>\n<p>由于平时懒得打开App查看油价，所以每次加油时才会看一眼加油站的标价。因此，其实本人对汽油的价格并不感冒。但是，最近一直在“折腾”Home Assistant，脑海中浮现的想法都是围绕着它展开，于是就想到了用Home Assistant来跟踪油价的变化。</p>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>首先，汽油的价格能够被实时获取，并且获得的数据能够被存储到Home Assistant中。当汽油的价格发生变化时，例如上涨或者下跌，Home Assistant可以发送通知到本人的手机。</p>\n<h2 id=\"数据源\"><a href=\"#数据源\" class=\"headerlink\" title=\"数据源\"></a>数据源</h2><p>在网上查找了一下关于汽油价格的网站，发现以下网站的信息比较全面，并且提供的油价可以精确到区级。</p>\n<p><a href=\"http://www.qiyoujiage.com/\">http://www.qiyoujiage.com/</a></p>\n<p>下面以上海为例，访问的网址是： <a href=\"http://www.qiyoujiage.com/shanghai.shtml\">http://www.qiyoujiage.com/shanghai.shtml</a> ，网页的部分源代码如下：</p>\n<p>&lt;dl&gt; &lt;dt&gt; &lt;dd&gt;是HTML中的一套组合标签，可以用于制作网页中的表格。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;youjia&quot;&gt;</span><br><span class=\"line\">\t&lt;dl&gt;</span><br><span class=\"line\">\t\t&lt;dt&gt;上海92#汽油&lt;/dt&gt;</span><br><span class=\"line\">\t\t&lt;dd&gt;7.34&lt;/dd&gt;</span><br><span class=\"line\">\t&lt;/dl&gt;</span><br><span class=\"line\">\t&lt;dl&gt;</span><br><span class=\"line\">\t\t&lt;dt&gt;上海95#汽油&lt;/dt&gt;</span><br><span class=\"line\">\t\t&lt;dd&gt;7.81&lt;/dd&gt;</span><br><span class=\"line\">\t&lt;/dl&gt;</span><br><span class=\"line\">\t&lt;dl&gt;</span><br><span class=\"line\">\t\t&lt;dt&gt;上海98#汽油&lt;/dt&gt;</span><br><span class=\"line\">\t\t&lt;dd&gt;9.71&lt;/dd&gt;</span><br><span class=\"line\">\t&lt;/dl&gt;</span><br><span class=\"line\">\t&lt;dl&gt;</span><br><span class=\"line\">\t\t&lt;dt&gt;上海0#柴油&lt;/dt&gt;</span><br><span class=\"line\">\t\t&lt;dd&gt;6.99&lt;/dd&gt;</span><br><span class=\"line\">\t&lt;/dl&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Beautiful-Soup\"><a href=\"#Beautiful-Soup\" class=\"headerlink\" title=\"Beautiful Soup\"></a>Beautiful Soup</h2><p><code>Beautiful Soup</code>是一款非常著名的Python第三方库，可以用来解析HTML文本，且非常简单易用。</p>\n<p>首先，用<code>Requests</code>获取网页的内容，并将返回的结果存储到<code>response</code>变量。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">from</span> bs4 <span class=\"keyword\">import</span> BeautifulSoup</span><br><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"></span><br><span class=\"line\">url = <span class=\"string\">&#x27;http://www.qiyoujiage.com/shanghai.shtml&#x27;</span></span><br><span class=\"line\">response = requests.get(url, timeout=(<span class=\"number\">5</span>, <span class=\"number\">10</span>))</span><br></pre></td></tr></table></figure>\n\n<p>用<code>Beautiful Soup</code>来解析网页内容（<code>response.content</code>），先查找所有<code>dl</code>标签，然后用<code>for</code>循环语句迭代每一个<code>dl</code>标签的内容，如果找到关键字<code>92</code>，就结束循环，并返回<code>name</code>和<code>price</code>。</p>\n<p>为了便于Home Assistant处理脚本返回的值，此处最终结果以JSON字符串的格式输出。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">format_string = <span class=\"string\">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span></span><br><span class=\"line\">now = datetime.strftime(datetime.now(), format_string)</span><br><span class=\"line\"></span><br><span class=\"line\">youjia_92 = &#123;&#125;</span><br><span class=\"line\">soup = BeautifulSoup(response.content, <span class=\"string\">&#x27;html.parser&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> dl <span class=\"keyword\">in</span> soup.find_all(<span class=\"string\">&#x27;dl&#x27;</span>):</span><br><span class=\"line\">\tname = dl.find(<span class=\"string\">&#x27;dt&#x27;</span>).text.strip()</span><br><span class=\"line\">\tvalue = <span class=\"built_in\">float</span>(dl.find(<span class=\"string\">&#x27;dd&#x27;</span>).text.strip())</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"string\">&#x27;92&#x27;</span> <span class=\"keyword\">in</span> name:</span><br><span class=\"line\">\t\tyoujia_92[<span class=\"string\">&#x27;name&#x27;</span>] = name</span><br><span class=\"line\">\t\tyoujia_92[<span class=\"string\">&#x27;price&#x27;</span>] = value</span><br><span class=\"line\">\t\tyoujia_92[<span class=\"string\">&#x27;last_update&#x27;</span>] = now</span><br><span class=\"line\">\t\t<span class=\"built_in\">print</span>(json.dumps(youjia_92))</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\n\n<p>运行以上代码，就会得到下面的结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;上海92#汽油&quot;</span>, <span class=\"string\">&quot;price&quot;</span>: <span class=\"number\">7.34</span>, <span class=\"string\">&quot;last_update&quot;</span>: <span class=\"string\">&quot;2024-09-28 12:33:01&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Command-Line\"><a href=\"#Command-Line\" class=\"headerlink\" title=\"Command Line\"></a>Command Line</h2><p>打开并编辑Home Assistant的配置文件<code>configuration.yaml</code>，添加传感器的配置内容。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">command_line:</span></span><br><span class=\"line\">\t<span class=\"bullet\">-</span> <span class=\"attr\">sensor:</span></span><br><span class=\"line\">\t\t<span class=\"attr\">name:</span> <span class=\"string\">&quot;上海92#油价&quot;</span></span><br><span class=\"line\">\t\t<span class=\"attr\">command:</span> <span class=\"string\">python3</span> <span class=\"string\">./scripts/oil_price/oil_price.py</span></span><br><span class=\"line\">\t\t<span class=\"attr\">json_attributes:</span></span><br><span class=\"line\">\t\t\t<span class=\"bullet\">-</span> <span class=\"string\">name</span></span><br><span class=\"line\">\t\t\t<span class=\"bullet\">-</span> <span class=\"string\">last_update</span></span><br><span class=\"line\">\t\t<span class=\"attr\">value_template:</span> <span class=\"string\">&quot;<span class=\"template-variable\">&#123;&#123; value_json.price &#125;&#125;</span>&quot;</span></span><br><span class=\"line\">\t\t<span class=\"attr\">device_class:</span> <span class=\"string\">monetary</span></span><br><span class=\"line\">\t\t<span class=\"attr\">unit_of_measurement:</span> <span class=\"string\">元</span></span><br><span class=\"line\">\t\t<span class=\"attr\">unique_id:</span> <span class=\"string\">command_oil_price</span></span><br><span class=\"line\">\t\t<span class=\"attr\">scan_interval:</span> <span class=\"number\">7200</span></span><br><span class=\"line\">\t\t<span class=\"attr\">command_timeout:</span> <span class=\"number\">60</span></span><br></pre></td></tr></table></figure>\n\n<p>配置参数说明：</p>\n<p>name                         传感器的名称<br>command                需要执行的命令或者脚本<br>json_attributes       传感器的属性，此处有两个属性：name和last_update<br>value_template      获取命令或者脚本返回的值<br>device_class           实体的类型，Home Assistant会根据设置的类型，在Dashboard中适配相应的图表<br>unit_of_measurement   值的单位<br>scan_interval          执行脚本的时间间隔，默认单位为“秒”<br>command_timeout  命令或者脚本默认15秒后超时，此处设置为60秒</p>\n<p>完成以上配置，并重载命令行配置以后，在Home Assistant中就会新增一个实体，该实体的标识符为<br><code>sensor.shang_hai_92_you_jie</code>。</p>\n<p>该实体的状态属性如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">name: 上海92#汽油</span><br><span class=\"line\">last_update: &quot;2024-09-29 16:19:12&quot;</span><br><span class=\"line\">price_changed: 油价下跌</span><br><span class=\"line\">unit_of_measurement: 元</span><br><span class=\"line\">device_class: monetary</span><br><span class=\"line\">icon: mdi:gas-station</span><br><span class=\"line\">friendly_name: 上海92#油价</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"油价涨跌变化\"><a href=\"#油价涨跌变化\" class=\"headerlink\" title=\"油价涨跌变化\"></a>油价涨跌变化</h2><p>为了能跟踪油价的涨跌变化，并且可以在第一时间接收到关于油价涨跌的信息，需要根据油价在发生变化前后的比较，来判断油价的涨跌。</p>\n<p><strong>弯路：</strong> 根据文档<a href=\"https://www.home-assistant.io/docs/automation/templating/#state\">automation | trigger state</a>，自动化的触发器可以提供触发前后的数据：<code>trigger.from_state</code>和<code>trigger.to_state</code>，但是实际测试过程中，发现如果触发器是基于状态（state）的变化，而不是数值区间（numeric_state）的变化，则无法在消息通知中通过<code>jinja</code>模板来进行数值对比。</p>\n<p>因此，我决定通过执行脚本来反映油价的涨跌情况。那么，如何在脚本中获取油价变化前的数据呢？此时，我想到了用<a href=\"https://developers.home-assistant.io/docs/api/rest/\">home assistant rest api</a>。在获取最新油价之前，先从Home Assistant获取当前的油价信息。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> requests.packages.urllib3.exceptions <span class=\"keyword\">import</span> InsecureRequestWarning</span><br><span class=\"line\"></span><br><span class=\"line\">rest_url = <span class=\"string\">&#x27;https://localhost:8123/api/states/&lt;entity_id&gt;&#x27;</span></span><br><span class=\"line\">token = &lt;token <span class=\"built_in\">id</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">headers = &#123;</span><br><span class=\"line\">\t<span class=\"string\">&quot;Authorization&quot;</span>: <span class=\"string\">f&quot;Bearer <span class=\"subst\">&#123;token&#125;</span>&quot;</span>,</span><br><span class=\"line\">\t<span class=\"string\">&quot;Content-Type&quot;</span>: <span class=\"string\">&quot;application/json&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请将<code>entity_id</code>换成实体的真实ID标识符。长期有效的Token需要在Home Assistant管理界面的个人配置文件中生成，具体可以参考文档：<a href=\"https://www.home-assistant.io/docs/authentication/#your-account-profile\">Authentication</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">previous_price = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">\trequests.packages.urllib3.disable_warnings(InsecureRequestWarning)</span><br><span class=\"line\">\tresponse_api = requests.get(</span><br><span class=\"line\">\t\trest_url, headers=headers, verify=<span class=\"literal\">False</span>, timeout=(<span class=\"number\">5</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\tprevious_price = <span class=\"built_in\">float</span>(response_api.json()[<span class=\"string\">&#x27;state&#x27;</span>])</span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> err:</span><br><span class=\"line\">\t<span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n\n<p>因为用<code>requests</code>访问API的时候会出现SSL证书错误的告警信息，且访问会失败，所以需要添加参数<code>verify=Fales</code>，这样就不会对SSL证书进行检查。但是，仍然会打印告警信息。因此，还需要用以下方法关闭告警信息。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> requests.packages.urllib3.exceptions <span class=\"keyword\">import</span> InsecureRequestWarning</span><br><span class=\"line\"></span><br><span class=\"line\">requests.packages.urllib3.disable_warnings(InsecureRequestWarning)</span><br></pre></td></tr></table></figure>\n\n<p>通过以上代码，就获取到了油价变化前的价格<code>previous_price</code>。</p>\n<p>通过跟最新油价的比较，就可以判断油价的上涨和下跌。这样，油价传感器的属性又增加了一项<code>price_changed</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">current_price = youjia_92[<span class=\"string\">&#x27;price&#x27;</span>]</span><br><span class=\"line\"><span class=\"keyword\">if</span> current_price &gt; previous_price:</span><br><span class=\"line\">\tyoujia_92[<span class=\"string\">&#x27;price_changed&#x27;</span>] = <span class=\"string\">&#x27;油价上涨&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">elif</span> current_price &lt; previous_price:</span><br><span class=\"line\">\tyoujia_92[<span class=\"string\">&#x27;price_changed&#x27;</span>] = <span class=\"string\">&#x27;油价下跌&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">\tyoujia_92[<span class=\"string\">&#x27;price_changed&#x27;</span>] = <span class=\"string\">&#x27;N/A&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自动化\"><a href=\"#自动化\" class=\"headerlink\" title=\"自动化\"></a>自动化</h2><h3 id=\"trigger\"><a href=\"#trigger\" class=\"headerlink\" title=\"trigger\"></a>trigger</h3><p>当实体<code>sensor.hui_shan_92_you_jie</code>的属性<code>price_changed</code>值从<code>N/A</code>变化成任何其它状态，自动化都会被触发。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">trigger:</span><br><span class=\"line\">  - platform: state</span><br><span class=\"line\">    entity_id:</span><br><span class=\"line\">      - sensor.shang_hai_92_you_jie</span><br><span class=\"line\">    attribute: price_changed</span><br><span class=\"line\">    from: N/A</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"action\"><a href=\"#action\" class=\"headerlink\" title=\"action\"></a>action</h3><p>自动化触发后，执行通知动作，将通知消息发送到目标手机，消息的标题是实体<code>sensor.shang_hai_92_you_jie</code>的属性值<code>price_changed</code>，消息的正文是自动化触发前的价格<code>&#123;&#123; trigger.to_state.state &#125;&#125;</code>和触发后的价格<code>&#123;&#123; trigger.from_state.state &#125;&#125;</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">action:</span><br><span class=\"line\">  - action: notify.mobile_app_iphone</span><br><span class=\"line\">    metadata: &#123;&#125;</span><br><span class=\"line\">    data:</span><br><span class=\"line\">      message: 当前价格：&#123;&#123; trigger.to_state.state &#125;&#125; 以前价格：&#123;&#123; trigger.from_state.state &#125;&#125;</span><br><span class=\"line\">      title: &quot;&#123;&#123; state_attr(&#x27;sensor.shang_hai_92_you_jie&#x27;, &#x27;price_changed&#x27;) &#125;&#125;&quot;</span><br><span class=\"line\">      data:</span><br><span class=\"line\">        push:</span><br><span class=\"line\">          sound: Doorbell.caf</span><br></pre></td></tr></table></figure>\n\n<p>手机上收到的通知消息见下图：</p>\n<p><img src=\"/2024/09/29/home-assistant/yong-home-assistanat-gen-zong-qi-you-jie-ge/F8B7D9EE-6145-4C58-AF0D-72244715D40B_1_201_a.jpeg\" alt=\"通知消息\"></p>\n<h2 id=\"开发者工具\"><a href=\"#开发者工具\" class=\"headerlink\" title=\"开发者工具\"></a>开发者工具</h2><p>Home Assistant的开发者工具中有两项功能对于测试很有帮助，分别是：<strong>设置状态</strong>和<strong>动作</strong>。</p>\n<h3 id=\"设置状态\"><a href=\"#设置状态\" class=\"headerlink\" title=\"设置状态\"></a>设置状态</h3><p>设置状态可以改变实体的状态值，例如，可以改变实体<code>sensor.shang_hai_92_you_jie</code>的油价，这样就可以帮助测试自动化的运行结果是否正确。例如，真实油价是7.34，我们就可以将油价改成7.50，然后当传感器再次获取到真实油价的时候，就可以触发自动化的运行。</p>\n<p>打开<strong>开发者工具</strong>，在<strong>状态</strong>中可以<strong>设置状态</strong>的选项。</p>\n<p><img src=\"/2024/09/29/home-assistant/yong-home-assistanat-gen-zong-qi-you-jie-ge/Pasted_image_20240929162823.png\" alt=\"开发者工具_设置状态\"></p>\n<h3 id=\"动作\"><a href=\"#动作\" class=\"headerlink\" title=\"动作\"></a>动作</h3><p>由于传感器只能根据设定的时间间隔更新数据，没有手动更新的选项。但是，测试时需要立即获取到最新的数据，这时可以用<code>homeassistant.update_entity</code>来实现。</p>\n<p>打开<strong>开发者工具</strong>，进入<strong>动作</strong>页面，进入<strong>YAML模式</strong>，输入以下内容，或者也可以在<strong>用户界面模式</strong>下操作。点击<strong>执行动作</strong>后，就会更新实体<code>sensor.shang_hai_92_you_jie</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">action: homeassistant.update_entity</span><br><span class=\"line\">data:</span><br><span class=\"line\">  entity_id:</span><br><span class=\"line\">    - sensor.shang_hai_92_you_jie</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://www.home-assistant.io/docs/configuration/templating/\">templating</a><br><a href=\"https://jinja.palletsprojects.com/en/latest/templates/\">jinja | templates</a><br><a href=\"https://community.home-assistant.io/t/memory-of-previous-state/290288\">memory of previous state</a><br><a href=\"https://www.home-assistant.io/docs/automation/templating/#state\">automation | trigger state</a><br><a href=\"https://community.home-assistant.io/t/manually-refresh-rest-sensor/353208\">manually refresh rest sensors</a><br><a href=\"https://www.home-assistant.io/docs/scripts/perform-actions/#homeassistant-services\">perform actions</a><br><a href=\"https://community.home-assistant.io/t/automation-template-value-should-be-a-string-for-dictionary-value-data-value-template-got-none/419519\">Automation: template value should be a string for dictionary value @ data[‘value_template’]. Got None</a><br><a href=\"https://developers.home-assistant.io/docs/api/rest/\">home assistant rest api</a><br><a href=\"https://www.slingacademy.com/article/python-requests-module-how-to-disable-warnings/\"># Python ‘requests’ Module: How to Disable Warnings</a></p>\n"}],"PostAsset":[{"_id":"source/_posts/Home_Assistant/Home_Assistant_HTTPS/20211019_001515000_iOS.png","slug":"20211019_001515000_iOS.png","post":"cls2tw2ad0000arecesey6xe6","modified":0,"renderable":0},{"_id":"source/_posts/Home_Assistant/Home_Assistant_HTTPS/20211019_001547000_iOS.png","slug":"20211019_001547000_iOS.png","post":"cls2tw2ad0000arecesey6xe6","modified":0,"renderable":0},{"_id":"source/_posts/Home_Assistant/Home_Assistant_HTTPS/20211019_001714000_iOS.png","slug":"20211019_001714000_iOS.png","post":"cls2tw2ad0000arecesey6xe6","modified":0,"renderable":0},{"_id":"source/_posts/Home_Assistant/如何使用Home Assistant更新DDNS记录/openapi.json","slug":"openapi.json","post":"cm1iylgev0000axechk9cak7e","modified":0,"renderable":0},{"_id":"source/_posts/Home_Assistant/用Home Assistanat跟踪汽油价格/F8B7D9EE-6145-4C58-AF0D-72244715D40B_1_201_a.jpeg","slug":"F8B7D9EE-6145-4C58-AF0D-72244715D40B_1_201_a.jpeg","post":"cm1nccdd60000s2ec2e8u0qty","modified":0,"renderable":0},{"_id":"source/_posts/Home_Assistant/用Home Assistanat跟踪汽油价格/Pasted_image_20240929162823.png","slug":"Pasted_image_20240929162823.png","post":"cm1nccdd60000s2ec2e8u0qty","modified":1,"renderable":0}],"PostCategory":[{"post_id":"cls2rtzhi00012yechax81l8w","category_id":"cls2rtzhn00042yec71sv7tha","_id":"cls2rtzhq00092yec923k6j5m"},{"post_id":"cls2tw2ad0000arecesey6xe6","category_id":"cls2rtzhq00072yecd8c3cgt1","_id":"cls2tw2am0002arecgjtc07l5"},{"post_id":"cm0ko1vvt0000m2ec2sxh79pu","category_id":"cls2rtzhq00072yecd8c3cgt1","_id":"cm0ko1vvx0002m2ec64ql850t"},{"post_id":"cm17gu7x000003tec3tsnfb1u","category_id":"cm17gu7x400013tec0qlrbqsn","_id":"cm17gu7xg00043tecgqwxfnoq"},{"post_id":"cm1iylgev0000axechk9cak7e","category_id":"cls2rtzhq00072yecd8c3cgt1","_id":"cm1iylgez0002axecel8z94rn"},{"post_id":"cm1nccdd60000s2ec2e8u0qty","category_id":"cls2rtzhq00072yecd8c3cgt1","_id":"cm1nccdda0002s2ec8hu7edmn"}],"PostTag":[{"post_id":"cls2rtzhi00012yechax81l8w","tag_id":"cls2rtzho00052yec1oqu2zrr","_id":"cls2rtzhr000b2yecf6589t73"},{"post_id":"cls2rtzhi00012yechax81l8w","tag_id":"cls2rtzhq00082yec8dwd3uvu","_id":"cls2rtzhr000c2yec7yzl6uit"},{"post_id":"cls2tw2ad0000arecesey6xe6","tag_id":"cls2rtzhq000a2yecdv1b1hil","_id":"cls2tw2am0001arec2cbsaoon"},{"post_id":"cm0ko1vvt0000m2ec2sxh79pu","tag_id":"cls2rtzhq000a2yecdv1b1hil","_id":"cm0ko1vvx0001m2ec1c8md37k"},{"post_id":"cm17gu7x000003tec3tsnfb1u","tag_id":"cm17gu7x500023tecejosdsgo","_id":"cm17gu7xg00033tec32ol5lqv"},{"post_id":"cm1iylgev0000axechk9cak7e","tag_id":"cls2rtzhq000a2yecdv1b1hil","_id":"cm1iylgez0001axeca83pdvpq"},{"post_id":"cm1nccdd60000s2ec2e8u0qty","tag_id":"cls2rtzhq000a2yecdv1b1hil","_id":"cm1nccdda0001s2ec3jt7can2"}],"Tag":[{"name":"#raspberrypi","_id":"cls2rtzho00052yec1oqu2zrr"},{"name":"#hexo","_id":"cls2rtzhq00082yec8dwd3uvu"},{"name":"home_assistant","_id":"cls2rtzhq000a2yecdv1b1hil"},{"name":"requests","_id":"cm17gu7x500023tecejosdsgo"}]}}