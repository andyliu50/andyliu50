---
title: 面向对象的编程
date: 2022-02-20 15:49:45
tags: 
 - python-intermediate
categories: 
 - Python
img: /medias/featureimages/30.jpg
---

# 面向对象的编程

> 注：本文翻译自[Object-Oriented Programming (OOP) in Python 3 – Real Python](https://realpython.com/python3-object-oriented-programming/)。

**面向对象的编程**（**Object-oriented programming** ）是一种构建程序的方式，这种方式将相关的属性和行为绑定到个别的对象上。通过本文，你将了解到关于面向对象编程的基础知识。

理论上来说，对象就好像是一个系统的组件。如果将一个程序想象成一家工厂的各种装配线。在装配线上的每一个环境，系统的部件都会对原材料进行加工处理，最后，原材料被加工成一个产品。

一个对象包含数据（就像是装配线上需要处理的原材料）和行为（装配线上的组件执行的操作）。

<!-- more -->

## 什么是面向对象的编程

**面向对象的编程**（**Object-oriented programming** ）是一种编程的范式。它提供了一种构建程序的方式，这种方式将相关的属性和行为绑定到个别的对象上。

例如，一个对象可以代表一个人，这个人拥有属性，如姓名，年龄和地址，以及拥有行为（方法），例如行走，讲话，呼吸和奔跑。或者一个对象也可以代表一封邮寄，这封邮件拥有属性，如收件人列表，主题和正文，以及拥有行为，例如添加附件和发送。

换一种说法，面向对象的编程用一种建模的方法来描述现实世界的事物，例如汽车，以及相关的事务，如工厂和工人，学生和老师等等。面向对象的编程通过建模的方式，将现实世界的个体描述为软件的对象，这些对象拥有相关的数据和哈数。

另外一种常见的编程方式是面向过程的编程。这种方式就像是一本菜谱，提供了一系列的步骤，以函数和代码块的方式，按顺序完成任务。

关键点是，对象是面向对象编程的核心，对象不仅代表数据，同时也代表了程序的整体结构。

## 定义一个类

基础的数据结构，如数字、字符串和列表，主要分别用来表示简单的信息，例如苹果的加个，诗的名称或者你喜欢的颜色。但是，如果你想要表示更为复杂的信息该怎么办呢？

例如，假设你想要记录组织的员工信息。你需要存储每一个员工的基本信息，例如他们的名字、年龄、职位和工作年限。

一种方式是通过列表来表示每一个员工的信息：

```python
kirk = ["James Kirk", 34, "Captain", 2265]
spock = ["Spock", 35, "Science Officer", 2254]
mccoy = ["Leonard McCoy", "Chief Medical Officer", 2266]
```

如果使用以上这种方式，会存在一些问题。

首先，它使得代码文件难以管理。如果你定义了`kirk`列表以后，隔了很多行才引用`kirk[0]`，你还会记得索引值为0的列表元素对应的是员工的名字吗？

其次，如果每一个员工在列表中的信息数量并不相同，就会导致代码运行出错。以上例子中，`mccoy`列表缺少年龄的信息，因此`mccoy[1]`返回的是"Chief Medical Officer"，而不是Dr. McCoy的年龄。

一种比较好的解决方式是使用类。

### 类和实例

类用于创建用户自己定义的数据结构。类定义的函数成为**方法**（**methods**）。方法定义了对象可以对数据所作的操作。

本文中，你将创建一个名为`Dog`的类，该类将用来存储狗的信息以及行为。

一个类本身并不包含任何数据，而是一种蓝图，用来定义事物。`Dog`类定义了狗的名字和年龄，但是并没有包含某一条狗的具体名字和年龄。

既然类是一种蓝图，那么实例就是根据蓝图创建的对象，包含实际的数据。一个`Dog`类的实例不再是一种蓝图，它是一只实际的狗，有名字，例如Miles，年龄是4岁。

换一种说法，一个类就像是一张空白的表格或者问卷表。一个实例就是一张已经填写了信息的表格。就像许多人都可以根据自己的信息来填写表格，根据同一个类，也可以创建许多实例。

### 如何定义一个类

首先定义一个类，需要以关键字`class`开头，然后后面是类的名称和冒号。换行后，下面缩进的内容都属于类的正文。

下面以`Dog`类为例：

```python
class Dog:
    pass
```

`Dog`类的正文只有一个声明：关键字`pass`。 `pass`不执行任何操作，只是一个占位符。在没有为类写任何代码的情况下，使用`pass`可以避免程序在运行时出错。

>注意：类的名称通常是首字母大写。例如，定义某一种狗的类，如 Jack Russell Terrier，那么类的名称就可以写为`JackRussellTerrier`。

目前，`Dog`类并没有任何属性，我们可以为它定义一些属性，例如名字、年龄、衣服颜色和品种。为了简单起见，我们只使用名字和年龄。

类的属性通常都是通过方法`.__init__()`来定义。每次创建一个`Dog`对象的时候，`.__init__()`就会通过为对象的属性赋值，来设置对象的初始状态。因此，`.__init__()`为类的每一个实例完成了初始化。

你可以为`.__init__()`设置任意数量的参数，但是第一个参数都是`self`。当一个类的实例被创建的时候，改实例自动被传递给`.__init__()`中的`self`参数，这样才能为对象定义新的属性。

让我们更改一下`Dog`类的`.__init__()`方法，创建`.name`和`.age`属性(attributes)。

```python
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age
```

注意到`.__init__()`方法缩进了4个空格，而方法的正文缩进了8个空格。空格缩进十分重要，通过空格缩进，Python才能知道`.__init__()`方法属于`Dog`类。

在`.__init__()`的正文中，有2个声明使用了`self`变量：

1. `self.name = name`创建了一个名为`name`的属性，并用参数`name`为它赋值。
2. `self.age = age`创建了一个名为`age`的属性，并用参数`age`为它赋值。

在`.__init__()`中创建的属性称为**实例属性**（**Instance attributes**）。实例属性的值只属于类的某一个实例。所有`Dog`对象都有名字和年龄，但是每一个实例的名字和年龄值是不相同的。

另一方面，**类的属性**（**class attributes**）在所有的类的实例中，都拥有相同的属性值。你可以在`.__init__()`以外的位置定义一个变量并为其赋值，该变量就是类的属性。

例如，下面的`Dog`类中有一个类的属性`species`，值为"Canis familiaris"：

```python
class Dog:
    # Class attribute
    species = "Canis familiaris"

    def __init__(self, name, age):
        self.name = name
        self.age = age
```

类的属性直接定义在类的名称下方第一行，并缩进4格。它们必须设置一个初始值。当创建类的实例的时候，类的属性被自动创建，并分配初始值。

当需要为每一个类的实例赋予相同属性值的时候，可以使用**类的属性**，当需要为每一个类的实例赋予不同属性值的时候，可以使用**实例属性**。

## 实例化一个对象

打开IDLE的交互窗口，输入以下内容：

```python
>>> class Dog:
...     pass
```

这样就创建了一个`Dog`类，但是这个类既没有属性也没有方法。

从一个类创建一个新的对象，成为**实例化**(**instantiating**)一个对象。通过输入类的名称并加上双括号，你可以实例化一个新的`Dog`对象：

```python
>>> Dog()
<__main__.Dog object at 0x106702d30>
```

现在，你在`0x106702d30`有一个新的`Dog`对象。`0x106702d30`代表的是内存地址。在不同的电脑上，该内存地址的值是不同的。

现在，实例化第二个对象：

```python
>>> Dog()
<__main__.Dog object at 0x0004ccc90>
```

这个新的`Dog`实例存储在完全不同的内存地址。因为这是一个全新的实例，与之前创建的第一个实例完全不同。

我们可以通过以下方式来判断两个实例是否相同：

```python
>>> a = Dog()
>>> b = Dog()
>>> a == b
False
```

通过以上代码，我们可以看到，虽然a和b都是通过`Dog`类创建的实例，但是他们代表了完全不同的对象。

### 类和实例属性

现在，创建一个`Dog`类，该类包含一个类的属性`.species`以及两个实例属性`.name`和`.age`。

```python
>>> class Dog:
...     species = "Canis familiaris"
...     def __init__(self, name, age):
...         self.name = name
...         self.age = age
```

为了实例化这个类，你需要为name和age提供参数值。否则，Python会抛出一个`TypeError`异常：

```python
>>> Dog()
Traceback (most recent call last):
  File "<pyshell#6>", line 1, in <module>
    Dog()
TypeError: __init__() missing 2 required positional arguments: 'name' and 'age'
```

通过在类名后面的括号中填入值，可以将参数传递给name和age。

```python
>>> buddy = Dog("Buddy", 9)
>>> miles = Dog("Miles", 4)
```

以上创建了两个`Dog`实例，一个是名叫Buddy的9岁小狗，另一个是名叫Miles的4岁小狗。

`Dog`类的`.__init__()`方法有三个参数，为什么在上面的例子中只使用了2个参数呢？

当你实例化一个`Dog`对象的时候，Python会创建一个新的实例，并将它传递给`.__init__()`的第一个参数。这样就移除了`self`参数，所以你只需要担心`name`和`age`参数。

当你创建了`Dog`实例后，你就可以使用**dot notation**访问实例的属性了。

```python
>>> buddy.name
'Buddy'
>>> buddy.age
9

>>> miles.name
'Miles'
>>> miles.age
4
```

你还可以用相同的访问访问类的属性：

```python
>>> buddy.species
'Canis familiaris'
```

使用类来组织数据的好处之一，就是可以确保实例拥有预期的属性。所有的`Dog`实例都有`.species`, `.name`和`.age`属性，所有你确定当访问这些属性的时候，总是能获取到相应的值。

虽然类能确保这些属性总是存在，但是相应的值却可以动态改变：

```python
>>> buddy.age = 10
>>> buddy.age
10

>>> miles.species = "Felis silvestris"
>>> miles.species
'Felis silvestris'
```

在上面的例子中，你将`buddy`对象的属性`.age`更改为10，然后你将`miles`对象的属性`.species`更改为猫的品种"Felis silvestris"。虽然这样使得Miles看起来像是一只奇怪的狗，但是这对Python而言是有效的。

这里的关键点是，默认情况下，自定义对象是可变的(mutable)的。如果一个对象可以被动态更改，那么它就是可变的(mutable)。例如，列表和字典都是可变的，但是字符串和元组是不可变的(immutable)。

### 实例方法

**实例方法**(**Instance methods**)是在类中定义的一种函数，这种函数只能被类的实例调用。跟`.__init__()`相同，实例方法的第一个参数都是`self`。

在IDLE打开一个新的文本编辑器，然后输入以下`Dog`类：

```python
class Dog:
    species = "Canis familiaris"

    def __init__(self, name, age):
        self.name = name
        self.age = age

    # Instance method
    def description(self):
        return f"{self.name} is {self.age} years old"

    # Another instance method
    def speak(self, sound):
        return f"{self.name} says {sound}"
```

该`Dog`类有两个实例方法：

1. **`.description()`**返回一个字符串，用于显示狗的名字和年龄。
2. **`.speak()`**有一个`sound`参数，返回一个字符串，用于显示狗的名字和吼叫声。

将以上代码保存到文件`dog.py`，然后按F5运行程序。

然后打开交互式窗口，输入以下实例方法：

```python
>>> miles = Dog("Miles", 4)

>>> miles.description()
'Miles is 4 years old'

>>> miles.speak("Woof Woof")
'Miles says Woof Woof'

>>> miles.speak("Bow Wow")
'Miles says Bow Wow'
```

在以上`Dog`类中，`.description()`返回了关于实例miles的信息。当你写类的时候，最好能有一个方法可以用来返回关于类的实例的说明信息。虽然`.description()`返回了实例的描述信息，但着并不是最佳的Python方式。

当你创建一个列表对象的时候，你可以用`print()`来显示以下内容：

```python
>>> names = ["Fletcher", "David", "Dan"]
>>> print(names)
['Fletcher', 'David', 'Dan']
```

如果我们用`print()`来打印miles对象，会发生什么呢：

```python
>>> print(miles)
<__main__.Dog object at 0x00aeff70>
```

当你`print(miles)`的时候，你看到的是一串很奇怪的字符串，miles是一个`Dog`的对象，内存地址为0x00aeff70。这些信息并不是很有用。你可以通过定义一个特殊的实例方法`.__str__()`来打印出更有用的信息。

下面，将`.description()`方法的名字更改为`.__str__()`:

```python
class Dog:
    # Leave other parts of Dog class as-is

    # Replace .description() with __str__()
    def __str__(self):
        return f"{self.name} is {self.age} years old"
```

保存文件然后按F5。现在，当你`print(miles)`的时候，你会得到更友好的输出内容：

```python
>>> miles = Dog("Miles", 4)
>>> print(miles)
'Miles is 4 years old'
```

像`.__init__()`和`.__str__()`这样的方法被称为**dunder methods**，因为他们的名字都是以双下划线开始，并以双下划线结尾。在Python中，有许多**dunder methods**可以用来定制类。虽然对于初学者来说，这些内容有点深奥，但是在Python中，**dunder methods**对于掌握面向对象的编程很重要。

## 类的继承

类的继承是指一个类可以继承另一个类的所有特性和方法。新创建的类成为子类，被继承的类成为父类。

子类可以重写或者扩展父类的特性和方法。也就是说，子类既可以继承父类的所有特性和方法，也可以定义自己独有的特性性和方法。

虽然这个比喻不是十分恰当，类的继承有点类似于人类的遗传。

你可能继承了你母亲头发的颜色，这是你出生时的特性。但是，你决定将头发染成紫色，由于你母亲的头发不是紫色，所有可以说你重新定义(**overridden** )了头发的特性。

### 遛狗公园的例子

假设你正在一个公园中遛狗。在这个公园里，有许多不同品种的狗，正在从事于各种不同的行为。

假设你想用Python类来为遛狗的公园建立一个模型。之前的`Dog`类可以通过狗的姓名和年龄来区分不同的狗，但是无法通过狗的品种来区分。

你可以在`Dog`类中添加`.breed`的特性：

```python
class Dog:
    species = "Canis familiaris"

    def __init__(self, name, age, breed):
        self.name = name
        self.age = age
        self.breed = breed
```

在以上类中，之所以省略了方法的定义，是因为与本章需要讨论的内容无关。

通过点击F5保存并运行文件，你可以在交互式窗口中，创建各种不同狗的实例：

```python
>>> miles = Dog("Miles", 4, "Jack Russell Terrier")
>>> buddy = Dog("Buddy", 9, "Dachshund")
>>> jack = Dog("Jack", 3, "Bulldog")
>>> jim = Dog("Jim", 5, "Bulldog")
```

不同品种的狗通常有不同的行为。例如，牛头犬的叫声比较低，声音类似于`woof`，但是腊肠犬的叫声比较高，声音类似于`yap`。

使用`Dog`类的时候，你必须为`.speak()`方法提供一个声音的参数`sound`，每次调用`Dog`实例的时候如下：

```python
>>> buddy.speak("Yap")
'Buddy says Yap'

>>> jim.speak("Woof")
'Jim says Woof'

>>> jack.speak("Woof")
'Jack says Woof'
```

每次调用`.speak()`方法的时候，都要传递一个参数，这样既显得重复，又不太方便。此外，每次传递参数的时候，还需要根据狗的品种`.breed`来决定对应的声音参数。

你可以通过为每一种狗创建一个子类的方法，来简化以上问题。这使得你可以扩展子类从父类继承的方法，例如为`.speak()`指定默认的参数。

### 父类和子类

接下来我们为三种不同品种的狗各自创建一个子类：Jack Russell Terrier, Dachshund, and Bulldog:

```python
class Dog:
    species = "Canis familiaris"

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return f"{self.name} is {self.age} years old"

    def speak(self, sound):
        return f"{self.name} says {sound}"
```

创建子类的时候，你需要为子类定义一个自己的名称，然后在括号中填写父类的名称：

```python
class JackRussellTerrier(Dog):
    pass

class Dachshund(Dog):
    pass

class Bulldog(Dog):
    pass
```

现在你可以在交互式窗口中通过以下方式创建各种实例：

```python
>>> miles = JackRussellTerrier("Miles", 4)
>>> buddy = Dachshund("Buddy", 9)
>>> jack = Bulldog("Jack", 3)
>>> jim = Bulldog("Jim", 5)
```

子类的实例继承了父类所有的特性和方法：

```python
>>> miles.species
'Canis familiaris'

>>> buddy.name
'Buddy'

>>> print(jack)
Jack is 3 years old

>>> jim.speak("Woof")
'Jim says Woof'
```

如果要判断某一个对象属于哪一个类，你可以使用内建函数`type()`:

```python
>>> type(miles)
<class '__main__.JackRussellTerrier'>
```

如果你还想判断`miles`是否是`Dog`类的实例，可以i使用内建函数`isinstance()`:

```python
>>> isinstance(miles, Dog)
True
```

注意到`isinstance`需要两个参数，一个对象和一个类。以上例子中，`isinstance()`检查 `miles`是否是`Dog`类的使用，返回值为`True`。

对象`miles`，`buddy`，`jack`和`jim`都是`Dog`类的实例，但是`miles`不是`Bulldog`的实例，`jack`不是`Dachshund`的实例。

```python
>>> isinstance(miles, Bulldog)
False

>>> isinstance(jack, Dachshund)
False
```

概而言之，所有子类的对象，同时也是父类的对象，但是它们并不一定是其它子类的对象。

### 扩展父类的功能

由于不同品种的狗有不同的叫声，如果你想要为每一种狗各自的`.speak()`方法指定一个默认的`sound`参数值，你可以在各自的子类中重新定义`.speak()`方法。

为了覆盖父类中的某一个方法，你需要在子类中定义相同名字的方法。下面以`JackRussellTerrier`子类为例：

```python
class JackRussellTerrier(Dog):
    def speak(self, sound="Arf"):
        return f"{self.name} says {sound}"
```

通过在子类`JackRussellTerrier`中重新定义方法`.speak()`后，现在JackRussellTerrier品种的狗有了一种默认的叫声“Arf”。

现在，如果你可以通过`JackRussellTerrier`的实例调用`.speak()`方法，并且不传递任何参数：

```python
>>> miles = JackRussellTerrier("Miles", 4)
>>> miles.speak()
'Miles says Arf'
```

有时候，有些狗在愤怒的时候会发出不同的叫声，这是你仍然可以调用`.speak()`方法，并传递相应的参数值：

```python
>>> miles.speak("Grrr")
'Miles says Grrr'
```

请记住，如果对父类做了更改，会自动传递给子类。但是，如果子类已经重新定义了父类的特性或者方法，那么父类的更改并不会传递给子类。

例如，在`Dog`类中，更改`.speak()`中的返回字符串内容，将`says`更改为`barks`:

```python
class Dog:
    # Leave other attributes and methods as they are

    # Change the string returned by .speak()
    def speak(self, sound):
        return f"{self.name} barks: {sound}"
```

现在，你创建一个新的`Bulldog`实例，名称为`jim`，`jim.speak()`会返回新的字符串：

```python
>>> jim = Bulldog("Jim", 5)
>>> jim.speak("Woof")
'Jim barks: Woof'
```

但是，如果调用`JackRussellTerrier`实例的`.speak()`方法，会发现并不会返回新的字符串：

```python
>>> miles = JackRussellTerrier("Miles", 4)
>>> miles.speak()
'Miles says Arf'
```

有时候，可能需要完全覆盖父类的方法，但是在这个例子中，我们想让子类`JackRussellTerrier`继续使用父类中`.speak()`方法返回的字符串格式。

为了实现这个目的，你仍然需要在子类`JackRussellTerrier`中定义`.speak()`方法。但是，你在子类的`.speak()`方法中需要调用父类的`.speak()`方法，并且将相应的参数传递给父类的`.speak()`方法。

在子类中的某一个方法中，可以使用`super()`来访问父类：

```python
class JackRussellTerrier(Dog):
    def speak(self, sound="Arf"):
        return super().speak(sound)
```

当你在子类`JackRussellTerrier`中调用`super().speak(sound)`的时候，Python会在父类`Dog`中查找`.speak()`方法，然后调用并传递参数`sound`。

下面，我们可以测试一下新定义的子类`JackRussellTerrier`：

```python
>>> miles = JackRussellTerrier("Miles", 4)
>>> miles.speak()
'Miles barks: Arf'
```

现在，当你调用`miles.speak()`的时候，你可以看到返回的结果是`Dog`类中定义的格式。

> 注意：在上面的例子中，类的继承结构非常简单。`JackRussellTerrier`子类有一个父类`Dog`。在实际的应用场景中，类的结构十分复杂。
>
> `super()`不仅只是在父类中查找某个方法或者特性，它还可以在整个类的结构中查找匹配的类和特性。如果你使用`super()`的时候不太小心，容易导致意外的结果。



## 总结

通过本指南，你学到了Python中面向对象编程的知识。大多数编程语言，如Java, C#和C++等都是基于面向对象编程的原理，所以本指南的知识同样适用于以上语言。

在本指南中，你学到了以下内容：

- 定义一个类
- 从一个类实例化一个对象
- 使用特性和方法来定义对象的属性和行为
- 通过继承，从父类创建一个子类
- 使用`super()`访问父类的某一个方法
- 使用`isinstance()`判断一个对象是否继承于另外一个类
