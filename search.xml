<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>在树莓派上部署Hexo博客</title>
    <url>/2023/12/28/raspberrypi/zai-shu-mei-pai-shang-bu-shu-hexo-bo-ke/</url>
    <content><![CDATA[<p>本文主要介绍如何将Hexo博客部署在树莓派上，从而实现在本地局域网直接访问博客内容。由于博客的源码保存在本地PC，并已经同步到Github。因此，只需将Hexo生成的网页文件发布到树莓派的Nginx服务器。</p>
<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p>首先在树莓派上安装nginx服务器，用于发布博客网站。</p>
<p>获取并更新软件列表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p>安装 nginx服务器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<p>查看nginx服务器的版本，确认已安装成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nginx -v</span><br><span class="line">nginx version: nginx/1.18.0</span><br></pre></td></tr></table></figure>

<p>配置nginx服务器随机启动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable nginx.service</span><br></pre></td></tr></table></figure>

<p>创建一个新的文件夹<code>/var/www/hexo</code>，用于存放博客的网页文件，并将该文件夹作为nginx服务器的根目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /var/www/hexo</span><br><span class="line">sudo <span class="built_in">chown</span> -R <span class="variable">$USER</span>:<span class="variable">$USER</span> /var/www/hexo</span><br><span class="line">sudo <span class="built_in">chmod</span> -R 755 /var/www/hexo</span><br></pre></td></tr></table></figure>

<p>打开nginx的配置文件，将根目录设置为<code>/var/www/hexo</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure>

<p>将配置文件中默认的根目录<code>root /var/www/html</code>用#号注释掉，并在下方添加新的根目录为<code>root /var/www/hexo</code>。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Default server configuration</span><br><span class="line">#</span><br><span class="line">server &#123;</span><br><span class="line">	listen 80 default_server;</span><br><span class="line">	listen [::]:80 default_server;</span><br><span class="line"></span><br><span class="line">	# SSL configuration</span><br><span class="line">	#</span><br><span class="line">	# listen 443 ssl default_server;</span><br><span class="line">	# listen [::]:443 ssl default_server;</span><br><span class="line">	#</span><br><span class="line">	# Note: You should disable gzip for SSL traffic.</span><br><span class="line">	# See: https://bugs.debian.org/773332</span><br><span class="line">	#</span><br><span class="line">	# Read up on ssl_ciphers to ensure a secure configuration.</span><br><span class="line">	# See: https://bugs.debian.org/765782</span><br><span class="line">	#</span><br><span class="line">	# Self signed certs generated by the ssl-cert package</span><br><span class="line">	# Don&#x27;t use them in a production server!</span><br><span class="line">	#</span><br><span class="line">	# include snippets/snakeoil.conf;</span><br><span class="line"></span><br><span class="line">	#root /var/www/html;</span><br><span class="line">	root /var/www/hexo;</span><br></pre></td></tr></table></figure>

<p>配置完成后，重启 nginx服务器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service nginx restart</span><br></pre></td></tr></table></figure>

<h2 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h2><p>查看树莓派上是否已安装git，如果没有安装，可以执行以下命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<p>安装完成后，查看版本，确认已安装成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git --version</span><br><span class="line">git version 2.30.2</span><br></pre></td></tr></table></figure>

<h2 id="远程Git仓库"><a href="#远程Git仓库" class="headerlink" title="远程Git仓库"></a>远程Git仓库</h2><p>在树莓派上建立一个远程仓库，这样本地PC就可以将网页文件提交到该仓库。</p>
<p>创建一个新的文件夹，并在该文件夹下面建立一个新的Git仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /home/pi/myapps/git_repository</span><br><span class="line"><span class="built_in">cd</span> /home/pi/myapps/git_repository</span><br><span class="line">git init --bare myblog.git</span><br></pre></td></tr></table></figure>

<p><strong>git init</strong> - 创建一个空的Git仓库或者重新初始化现有的仓库。<br><strong>–bare</strong> - 创建一个全新的Git仓库。<br><strong>myblog.git</strong> - 仓库的名称为myblog，并添加后缀.git。</p>
<p>然后在仓库 <code>myblog.git</code> 下创建一个钩子，将网页文件传送到nginx服务器的根目录下，即 <code>/var/www/hexo</code>下面：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#在仓库下创建一个新的钩子文件</span><br><span class="line">sudo vi /home/pi/myblog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>

<p>在文件中添加以下命令，然后保存文件。该命令中的<code>--work-tree</code>参数可以将目录<code>/var/www/hexo</code>映射到仓库中，本地提交的网页文件会自动存储到<code>/var/www/hexo</code>目录下。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">git --work-tree=/var/www/hexo --git-dir=/home/pi/myapps/git_repository/myblog.git checkout -f</span><br></pre></td></tr></table></figure>

<p>为文件<code>post-receive</code>添加可执行权限。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo chmod +x /var/repo/web_blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>

<h2 id="配置SSH公钥登录"><a href="#配置SSH公钥登录" class="headerlink" title="配置SSH公钥登录"></a>配置SSH公钥登录</h2><p>在本地 PC上生成公钥文件<code>id_rsa.pub</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -P &#x27;&#x27;</span><br><span class="line">		</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/user/.ssh/id_rsa):</span><br><span class="line">Your identification has been saved in /user/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /user/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">3f:35:7c:d2:33:65:d6:69:7f:34:92:31:38:1d:c1:94 user@bogon</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+--[ RSA 2048]----+</span><br><span class="line">|            =B==B|</span><br><span class="line">|           o E*o=|</span><br><span class="line">|            ... o|</span><br><span class="line">|         . . .  .|</span><br><span class="line">|        S + o    |</span><br><span class="line">|         o o     |</span><br><span class="line">|          +      |</span><br><span class="line">|         . .     |</span><br><span class="line">|                 |</span><br><span class="line">+————————+</span><br></pre></td></tr></table></figure>

<p>本地PC的公钥上传到树莓派。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub pi@pi</span><br></pre></td></tr></table></figure>

<p>以上命令会将本地PC的公钥写入到树莓派的<code>~/.ssh/authorized_keys</code>文件中。如果树莓派上不存在文件<code>authorized_keys</code>，<code>ssh-copy-id</code>会新建文件。</p>
<h2 id="配置本地Hexo"><a href="#配置本地Hexo" class="headerlink" title="配置本地Hexo"></a>配置本地Hexo</h2><p>打开Hexo的配置文件<code>_config.yml</code>，设置部署博客的方式。</p>
<p>type: git<br>repo: pi@pi:&#x2F;home&#x2F;pi&#x2F;myapps&#x2F;git_repository&#x2F;myblog<br>branch: main</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  - type: git</span><br><span class="line">    repo: pi@pi:/home/pi/myapps/git_repository/myblog</span><br><span class="line">    branch: main</span><br></pre></td></tr></table></figure>

<p>在本地PC执行命令<code>hexo g -d</code>后，本地生成的网页文件会自动部署到树莓派上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>RaspberryPi</category>
      </categories>
      <tags>
        <tag>#raspberrypi</tag>
        <tag>#hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Home Assistant配置HTTPS</title>
    <url>/2021/10/19/home-assistant/home-assistant-https/</url>
    <content><![CDATA[<p>默认情况下，Home Assistant安装完成后，使用HTTP访问。如果在内网使用，HTTP相对还比较安全。但是，为了能让手机在外网访问HA网关，需要将其发布到外网（Internet）。因此，首先必须要配置HTTPS，确保数据传输的安全性。</p>
<p>为了节约成本，可以使用自签的SSL证书。或者，也可以选用官方推荐的免费TLS&#x2F;SSL证书服务：<a href="https://www.home-assistant.io/docs/ecosystem/certificates/lets_encrypt/">Let’s Encrypt</a>和<a href="https://www.home-assistant.io/integrations/duckdns/">Duck DNS integrating Let’s Encrypt</a>。</p>
<h2 id="制作自签的证书"><a href="#制作自签的证书" class="headerlink" title="制作自签的证书"></a>制作自签的证书</h2><p>证书的制作过程都是在树莓派上使用<code>openssl</code>完成。</p>
<p>首先创建目录<code>certs</code>，并进入该目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir certs</span><br><span class="line">cd certs</span><br></pre></td></tr></table></figure>

<h3 id="制作根证书"><a href="#制作根证书" class="headerlink" title="制作根证书"></a>制作根证书</h3><p>首先，需要创建根证书密钥，该密钥用于为证书签名。安全起见，该密钥不能泄露给其他人：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl genrsa -des3 -out rootCA.key 4096</span><br></pre></td></tr></table></figure>

<p><strong>该命令生成的Key默认使用密码保护，如果要取消密码保护，只需要移除选项-des3。</strong></p>
<p>然后用根证书密钥制作根证书：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 3650 -out rootCA.pem</span><br></pre></td></tr></table></figure>

<p>如果需要使用苹果设备**macOS vs 10.15 &#x2F; iOS 13 (or above)**，请使用以下命令制作根证书，区别是根证书的有效期只有 825 天：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 825 -out rootCA.pem</span><br></pre></td></tr></table></figure>

<h3 id="制作服务器证书"><a href="#制作服务器证书" class="headerlink" title="制作服务器证书"></a>制作服务器证书</h3><p>请根据以下步骤，制作Home Assistant服务器的证书。</p>
<p>创建<code>rootCA.csr.cnf</code>文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch rootCA.csr.cnf</span><br><span class="line">vi rootCA.csr.cnf</span><br></pre></td></tr></table></figure>

<p>将以下内容复制-粘贴到文件<code>rootCA.csr.cnf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># rootCA.csr.cnf</span><br><span class="line">[req]</span><br><span class="line">default_bits = 2048</span><br><span class="line">prompt = no</span><br><span class="line">default_md = sha256</span><br><span class="line">distinguished_name = dn</span><br><span class="line">             </span><br><span class="line">[dn]</span><br><span class="line">C=CN</span><br><span class="line">ST=Shanghai</span><br><span class="line">L=Shanghai</span><br><span class="line">O=HA</span><br><span class="line">OU=HAU</span><br><span class="line">emailAddress=admin@ha.com</span><br><span class="line">CN = ivpn.asuscomm.com   </span><br></pre></td></tr></table></figure>

<p>创建<code>v3.ext</code>文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch v3.ext</span><br><span class="line">vi v3.ext</span><br></pre></td></tr></table></figure>

<p>将以下内容复制-粘贴到文件<code>v3.ext</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># v3.ext</span><br><span class="line">authorityKeyIdentifier=keyid,issuer</span><br><span class="line">basicConstraints=CA:FALSE</span><br><span class="line">keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span><br><span class="line">subjectAltName = @alt_names</span><br><span class="line">extendedKeyUsage=serverAuth</span><br><span class="line">                </span><br><span class="line">[alt_names]</span><br><span class="line">DNS.1 = ivpn.asuscomm.com</span><br><span class="line">IP.1 = 192.168.1.65</span><br></pre></td></tr></table></figure>

<p>创建证书密钥<code>hassio.csr</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req -new -sha256 -nodes -out hassio.csr -newkey rsa:2048 -keyout hassio.key -config &lt;( <span class="built_in">cat</span> rootCA.csr.cnf )</span><br></pre></td></tr></table></figure>

<p>如果在Windows平台上运行该命令，需要注意-config参数后面rootCA.csr.cnf文件的路径地址。请参考以下例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req -new -sha256 -nodes -out hassio.csr -newkey rsa:2048 -keyout hassio.key -config <span class="string">&quot;C:\Program Files\Git\usr\bin\rootCA.csr.cnf&quot;</span></span><br></pre></td></tr></table></figure>

<p>创建证书<code>hassio.csr</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -<span class="keyword">in</span> hassio.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out hassio.crt -days 3650 -sha256 -extfile v3.ext</span><br></pre></td></tr></table></figure>

<p>如果需要使用苹果设备**macOS vs 10.15 &#x2F; iOS 13 (or above)**，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -<span class="keyword">in</span> hassio.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out hassio.crt -days 825 -sha256 -extfile v3.ext</span><br></pre></td></tr></table></figure>

<h2 id="配置Home-Assistant"><a href="#配置Home-Assistant" class="headerlink" title="配置Home Assistant"></a>配置Home Assistant</h2><p>将服务器证书和私钥重新命名为.pem格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rename hassio.crt fullchain.pem</span><br><span class="line">rename hassio.key privkey.pem</span><br></pre></td></tr></table></figure>

<p>将证书复制到<code>/PATH_TO_YOUR_CONFIG/ssl</code>目录：</p>
<p><strong>这里需要注意的是，由于采用了Docker方式安装HA，没有权限访问&#x2F;etc目录，所以，只能将证书复制到&#x2F;PATH_TO_YOUR_CONFIG&#x2F;ssl。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /PATH_TO_YOUR_CONFIG/ssl</span><br><span class="line"><span class="built_in">cp</span> fullchain.pem /PATH_TO_YOUR_CONFIG/ssl/</span><br><span class="line"><span class="built_in">cp</span> privkey.pem /PATH_TO_YOUR_CONFIG/ssl/</span><br></pre></td></tr></table></figure>

<p>修改配置文件<code>configuration.yaml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">http:</span>                                                                       </span><br><span class="line">	<span class="attr">ssl_certificate:</span> <span class="string">./ssl/fullchain.pem</span>                                     </span><br><span class="line">	<span class="attr">ssl_key:</span> <span class="string">./ssl/privkey.pem</span>  </span><br></pre></td></tr></table></figure>

<h2 id="将Home-Assistant发布到公网"><a href="#将Home-Assistant发布到公网" class="headerlink" title="将Home Assistant发布到公网"></a>将Home Assistant发布到公网</h2><p>由于本地网络没有公网IP地址，因此通过SSH Tunnel的方式，将Home Assistant网关映射到远端网络，并发布到公网上。</p>
<p>在HA网关上运行以下命令，该命令会将本地的8123端口映射到远端树莓派的10000端口。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">autossh -f -M 0 -NR 0.0.0.0:10000:localhost:8123 pi@ivpn.asuscomm.com -p 30100</span><br></pre></td></tr></table></figure>

<p>然后，创建计划任务，每次HA网关重启后，会自动执行以上命令。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">@reboot autossh -f -M 0 -NR 0.0.0.0:10000:localhost:8123 pi@ivpn.asuscomm.com -p 30100 &amp;</span><br></pre></td></tr></table></figure>

<p>在远端路由器上，选择<strong>外部网络(WAN) - 端口转发 - 自定义设置</strong> ，添加端口转发的条目。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">服务名称：Home-Assistant</span><br><span class="line">通信协议：TCP</span><br><span class="line">外部端口：10000</span><br><span class="line">内部端口：10000</span><br><span class="line">本地IP地址：192.168.100.100</span><br></pre></td></tr></table></figure>

<h2 id="iOS如何安装根证书"><a href="#iOS如何安装根证书" class="headerlink" title="iOS如何安装根证书"></a>iOS如何安装根证书</h2><p>点击<code>rootCA.pem</code>文件，安装根证书。</p>
<p><img src="/2021/10/19/home-assistant/home-assistant-https/20211019_001515000_iOS.png"></p>
<p>打开<strong>设置</strong>应用，找到<strong>已下载描述文件</strong>，点击<strong>安装</strong>，安装过程中需要输入手机密码。</p>
<p><img src="/2021/10/19/home-assistant/home-assistant-https/20211019_001547000_iOS.png"></p>
<p>安装完成后，需要在<strong>设置 - 通用 - 关于本机 - 证书信任设置</strong>中，启用安装的根证书。</p>
<p><img src="/2021/10/19/home-assistant/home-assistant-https/20211019_001714000_iOS.png"></p>
<h2 id="Android如何安装根证书"><a href="#Android如何安装根证书" class="headerlink" title="Android如何安装根证书"></a>Android如何安装根证书</h2><p>重新命名<code>rootCA.pem</code>文件为<code>rootCA.crt</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rename rootCA.pem rootCA.crt</span><br></pre></td></tr></table></figure>

<p>在Android设备上点击安装<code>rootCA.crt</code>文件。</p>
<h2 id="Mac如何安装根证书"><a href="#Mac如何安装根证书" class="headerlink" title="Mac如何安装根证书"></a>Mac如何安装根证书</h2><p>打开终端工具，输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CERT=&quot;/path/to/my/cert/my-root.crt&quot;</span><br><span class="line">sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain $CERT</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Home_Assistant</category>
      </categories>
      <tags>
        <tag>home_assistant</tag>
      </tags>
  </entry>
  <entry>
    <title>安装Home Assistant容器</title>
    <url>/2021/10/17/home-assistant/an-zhuang-home-assistant-rong-qi/</url>
    <content><![CDATA[<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>1 更新树莓派的系统。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>

<p>2 下载Docker安装脚本，然后执行脚本安装Docker。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是，由于国内访问Docker官方的安装源很慢，因此可以添加参数<code>--mirror Aliyun</code>，将安装源更改为阿里云镜像，从而提高安装速度。</strong></p>
<span id="more"></span>

<p>3 默认情况下，只有拥有管理员权限的账号才可以运行docker，如果登录的账号是普通用户，需要通过sudo来运行docker。或者，也可以将普通用户账号添加到docker用户组，这样该用户就可以直接运行docker的命令。</p>
<p>以下命令可以将用户<code>pi</code>添加到docker用户组中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker pi</span><br></pre></td></tr></table></figure>


<p>4 使用命令<code>docker version</code>和<code>docker info</code>查看Docker的版本信息和运行状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker version</span><br><span class="line"></span><br><span class="line">Client:</span><br><span class="line"> Version:           20.10.5+dfsg1</span><br><span class="line"> API version:       1.41</span><br><span class="line"> Go version:        go1.15.15</span><br><span class="line"> Git commit:        55c4c88</span><br><span class="line"> Built:             Mon May 30 18:34:49 2022</span><br><span class="line"> OS/Arch:           linux/arm64</span><br><span class="line"> Context:           default</span><br><span class="line"> Experimental:      <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          20.10.5+dfsg1</span><br><span class="line">  API version:      1.41 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.15.15</span><br><span class="line">  Git commit:       363e9a8</span><br><span class="line">  Built:            Mon May 30 18:34:49 2022</span><br><span class="line">  OS/Arch:          linux/arm64</span><br><span class="line">  Experimental:     <span class="literal">false</span></span><br><span class="line"> containerd:</span><br><span class="line">  Version:          1.4.13~ds1</span><br><span class="line">  GitCommit:        1.4.13~ds1-1~deb11u4</span><br><span class="line"> runc:</span><br><span class="line">  Version:          1.0.0~rc93+ds1</span><br><span class="line">  GitCommit:        1.0.0~rc93+ds1-5+deb11u2</span><br><span class="line"> docker-init:</span><br><span class="line">  Version:          0.19.0</span><br><span class="line">  GitCommit:</span><br><span class="line"></span><br><span class="line">docker info</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker info</span><br><span class="line"></span><br><span class="line">Client:</span><br><span class="line"> Context:    default</span><br><span class="line"> Debug Mode: <span class="literal">false</span></span><br><span class="line"> Plugins:</span><br><span class="line">  buildx: Docker Buildx (Docker Inc., v0.10.4)</span><br><span class="line">  compose: Docker Compose (Docker Inc., v2.17.3)</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Containers: 1</span><br><span class="line">  Running: 1</span><br><span class="line">  Paused: 0</span><br><span class="line">  Stopped: 0</span><br><span class="line"> Images: 1</span><br><span class="line"> Server Version: 20.10.5+dfsg1</span><br><span class="line"> Storage Driver: overlay2</span><br><span class="line">  Backing Filesystem: extfs</span><br><span class="line">  Supports d_type: <span class="literal">true</span></span><br><span class="line">  Native Overlay Diff: <span class="literal">true</span></span><br><span class="line"> Logging Driver: json-file</span><br><span class="line"> Cgroup Driver: systemd</span><br><span class="line"> Cgroup Version: 2</span><br><span class="line"> Plugins:</span><br><span class="line">  Volume: <span class="built_in">local</span></span><br><span class="line">  Network: bridge host ipvlan macvlan null overlay</span><br><span class="line">  Log: awslogs fluentd gcplogs gelf journald json-file <span class="built_in">local</span> logentries splunk syslog</span><br><span class="line"> Swarm: inactive</span><br><span class="line"> Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc</span><br><span class="line"> Default Runtime: runc</span><br><span class="line"> Init Binary: docker-init</span><br><span class="line"> containerd version: 1.4.13~ds1-1~deb11u4</span><br><span class="line"> runc version: 1.0.0~rc93+ds1-5+deb11u2</span><br><span class="line"> init version:</span><br><span class="line"> Security Options:</span><br><span class="line">  seccomp</span><br><span class="line">   Profile: default</span><br><span class="line">  cgroupns</span><br><span class="line"> Kernel Version: 6.1.21-v8+</span><br><span class="line"> Operating System: Debian GNU/Linux 11 (bullseye)</span><br><span class="line"> OSType: linux</span><br><span class="line"> Architecture: aarch64</span><br><span class="line"> CPUs: 4</span><br><span class="line"> Total Memory: 7.629GiB</span><br><span class="line"> Name: pi4-8g</span><br><span class="line"> ID: AT4S:WDKG:SCHA:D56T:SRNU:TJJB:ZEMH:YR67:6GRF:KLVC:B6MI:SVIE</span><br><span class="line"> Docker Root Dir: /var/lib/docker</span><br><span class="line"> Debug Mode: <span class="literal">false</span></span><br><span class="line"> Registry: https://index.docker.io/v1/</span><br><span class="line"> Labels:</span><br><span class="line"> Experimental: <span class="literal">false</span></span><br><span class="line"> Insecure Registries:</span><br><span class="line">  127.0.0.0/8</span><br><span class="line"> Registry Mirrors:</span><br><span class="line">  https://docker.mirrors.ustc.edu.cn/</span><br><span class="line"> Live Restore Enabled: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">WARNING: No memory <span class="built_in">limit</span> support</span><br><span class="line">WARNING: No swap <span class="built_in">limit</span> support</span><br><span class="line">WARNING: Support <span class="keyword">for</span> cgroup v2 is experimental</span><br></pre></td></tr></table></figure>

<h2 id="安装Home-Assistant"><a href="#安装Home-Assistant" class="headerlink" title="安装Home Assistant"></a>安装Home Assistant</h2><p>通过Docker方式安装Home Assistant，不支持<a href="https://www.home-assistant.io/addons">add-ons</a>（add-ons是指通过安装第三方的应用程序来扩展Home Assistant的功能），并且无法从管理界面中更新Home Assistant的版本。</p>
<h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><ul>
<li>Docker至少是19.03.9或者以上版本</li>
<li><code>libseccomp</code>的版本至少是 2.4.2或者以上</li>
</ul>
<h3 id="Raspberry-pi-3"><a href="#Raspberry-pi-3" class="headerlink" title="Raspberry pi 3"></a>Raspberry pi 3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name homeassistant \</span><br><span class="line">  --privileged \</span><br><span class="line">  --restart=unless-stopped \</span><br><span class="line">  -e TZ=MY_TIME_ZONE \</span><br><span class="line">  -v /PATH_TO_YOUR_CONFIG:/config \</span><br><span class="line">  --network=host \</span><br><span class="line">  ghcr.io/home-assistant/raspberrypi3-homeassistant:stable</span><br></pre></td></tr></table></figure>

<h3 id="Raspberry-pi-4"><a href="#Raspberry-pi-4" class="headerlink" title="Raspberry pi 4"></a>Raspberry pi 4</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name homeassistant \</span><br><span class="line">  --privileged \</span><br><span class="line">  --restart=unless-stopped \</span><br><span class="line">  -e TZ=MY_TIME_ZONE \</span><br><span class="line">  -v /PATH_TO_YOUR_CONFIG:/config \</span><br><span class="line">  -v /run/dbus:/run/dbus:ro \</span><br><span class="line">  --network=host \</span><br><span class="line">  ghcr.io/home-assistant/raspberrypi4-homeassistant:stable</span><br></pre></td></tr></table></figure>

<p>以上安装命令中，一定要将<code>/PATH_TO_YOUR_CONFIG</code>修改成指定的安装路径，例如<code>/home/pi/homeassistant</code>，如果忘记修改，配置文件就会保存到<code>/PATH_TO_YOUR_CONFIG</code>目录。</p>
<p>更改<code>MY_TIME_ZONE</code>为本地时区，例如<code>Asia/Shanghai</code>。</p>
<p>如果要使用<a href="https://www.home-assistant.io/integrations/bluetooth">Bluetooth integration</a>, 需要设置<code>D-Bus</code>，即<code>-v /run/dbus:/run/dbus:ro</code></p>
<p>安装成功后，打开浏览器访问<code>http://&lt;host&gt;:8123</code>，登录Home Assistant的Web界面。</p>
<h2 id="更新Home-Assistant"><a href="#更新Home-Assistant" class="headerlink" title="更新Home Assistant"></a>更新Home Assistant</h2><p>下载最新版本的Home Assistant，如果命令结果返回”Image is up to date”，则说明目前已经是最新版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ghcr.io/home-assistant/home-assistant:stable</span><br></pre></td></tr></table></figure>

<p>停止运行Home Assistant容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop homeassistant</span><br></pre></td></tr></table></figure>

<p>删除Home Assistant容器，<strong>该操作不会删除原有的配置文件</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> homeassistant</span><br></pre></td></tr></table></figure>

<p>运行最新版本的Home Assistant，将<code>PATH_TO_YOUR_CONFIG</code>设置为原配置文件所在的路径，例如<code>/home/pi/homeassistant</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">	--name homeassistant \</span><br><span class="line">	--restart=unless-stopped \ </span><br><span class="line">	--privileged \ </span><br><span class="line">	-e TZ=MY_TIME_ZONE \ </span><br><span class="line">	-v /PATH_TO_YOUR_CONFIG:/config \ </span><br><span class="line">	-v /run/dbus:/run/dbus:ro \ </span><br><span class="line">	--network=host \ </span><br><span class="line">	ghcr.io/home-assistant/home-assistant:stable</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Home_Assistant</category>
      </categories>
      <tags>
        <tag>home_assistant</tag>
      </tags>
  </entry>
  <entry>
    <title>Requests库使用指南</title>
    <url>/2022/02/08/python/requests-ku-shi-yong-zhi-nan/</url>
    <content><![CDATA[<blockquote>
<p>注：本文翻译自<a href="https://realpython.com/python-requests/">Python’s Requests Library (Guide)</a>。</p>
</blockquote>
<p>在Python中，<code>requests</code>库是处理HTTP请求的标准。它使得复杂的HTTP请求变得简单、易用，用户只需要专注于处理与Web服务之间的交互过程，并获取所需的数据。</p>
<p>通过本文，你可以学到许多<code>requests</code>库中的有用功能，并且可以根据实际的使用场景，定制和优化这些功能。你还会学到如何有效地使用<code>requests</code>库，避免由于网络的原因影响应用的响应速度。</p>
<p>在本指南中，你将学到以下内容：</p>
<ul>
<li>最常见的HTTP方式</li>
<li>定制HTTP请求中的报头和数据，使用查询字符和消息内容</li>
<li>检查请求和响应中的数据</li>
<li>发送认证请求</li>
<li>配置请求，防止应用的响应速度变慢</li>
</ul>
<span id="more"></span>

<h2 id="开始使用requests"><a href="#开始使用requests" class="headerlink" title="开始使用requests"></a>开始使用requests</h2><p>首先，需要安装<code>requests</code>库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">pip install requests</span></span><br></pre></td></tr></table></figure>

<p>安装完成后，需要先导入<code>requests</code>库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br></pre></td></tr></table></figure>

<h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><p>HTTP有很多种请求方式，例如GET和POST，不同的请求方式，所执行的操作是不同的。其中，GET是最常用的HTTP请求。GET主要是用来获取Web数据。如果发起一个GET请求，就会调用<code>requests.get()</code>。</p>
<p>以下例子中，你可以看到通过调用<code>get()</code>发送GET请求给Github的<a href="https://developer.github.com/v3/#root-endpoint">Root REST API</a>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">&#x27;https://api.github.com&#x27;</span>)</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure>
<h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><p>通过发送GET请求以后，我们可以得到一个Response的对象。将该对象存储到一个变量中后，我们可以查看该对象的属性和方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>response = requests.get(<span class="string">&#x27;https://api.github.com&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在以上例子中，我们将响应对象存储到<code>response</code>变量中。</p>
<h3 id="状态码（Status-Codes）"><a href="#状态码（Status-Codes）" class="headerlink" title="状态码（Status Codes）"></a>状态码（Status Codes）</h3><p>从响应<code>Response</code>中首先可以获取状态码，通过状态码来判断请求是否成功。</p>
<p>例如，如果状态码是<code>200 OK</code>，那么说明请求是成功的，但是如果状态码是<code>404 NOT FOUND</code>，则说明未找到需要获取的资源。关于状态码的详细说明，请参考文档：<a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">many other possible status codes</a></p>
<p>通过访问响应<code>response</code>的属性<code>.status_code</code>，可以看到服务器返回的状态码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>response.status_code</span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure>

<p><code>.status_code</code>返回的是<code>200</code>，说明请求时成功的，并且服务器返回了你需要获取的数据。</p>
<p>有些情况下，你可能想要通过状态码来作为判断条件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Success!&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> response.status_code == <span class="number">404</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Not Found.&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>以上例子中，如果服务器返回<code>200</code>的状态码，那么程序就会打印<code>Success!</code>。如果服务器返回<code>404</code>的状态码，程序就会打印<code>Not Found.</code>。</p>
<p><code>requests</code>提供了一种更为简便的方法。如果直接使用<code>Response</code>实例作为判断的条件，假设状态码在<code>200</code>和<code>400</code>之间，那么表达式就会被评估为<code>True</code>，否则就会被评估为<code>False</code>。</p>
<p>因此，你可以将之前的例子改写如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> response:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Success!&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;An error has occurred.&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>技术细节：This <a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing">Truth Value Test</a> is made possible because <a href="https://realpython.com/operator-function-overloading/#making-your-objects-truthy-or-falsey-using-bool"><code>__bool__()</code> is an overloaded method</a> on <code>Response</code>.</p>
<p>This means that the default behavior of <code>Response</code> has been redefined to take the status code into account when determining the truth value of the object.</p>
</blockquote>
<p>记住这种方式并不是检验状态码是否等于<code>200</code>，而是检验状态码是否在<code>200</code>到<code>400</code>之间，例如<code>204 NO CONTENT</code>和<code>304 NOT MODIFIED</code>，也被认为是请求成功的。</p>
<p>例如，<code>204</code>是说明请求是成功的，但是返回的消息正文并没有任何内容。</p>
<p>因此，如果只是为了知道请求是否成功，可以使用这种简便的方法，否则，建议还是根据具体的状态码来判断。</p>
<p>有时候，可能你不希望用<code>if</code>语句来检查状态码，而是希望在请求失败的情况下，引发异常。那么你就可以使用<code>.raise_for_status()</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> HTTPError</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> [<span class="string">&#x27;https://api.github.com&#x27;</span>, <span class="string">&#x27;https://api.github.com/invalid&#x27;</span>]:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># If the response was successful, no Exception will be raised</span></span><br><span class="line">        response.raise_for_status()</span><br><span class="line">    <span class="keyword">except</span> HTTPError <span class="keyword">as</span> http_err:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;HTTP error occurred: <span class="subst">&#123;http_err&#125;</span>&#x27;</span>)  <span class="comment"># Python 3.6</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Other error occurred: <span class="subst">&#123;err&#125;</span>&#x27;</span>)  <span class="comment"># Python 3.6</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Success!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>如果你调用<code>.raise_for_status()</code>，就会对某些失败的状态码引发<code>HTTPError</code>的异常错误。如果状态码显示请求是成功的，那么程序就不会引发异常。</p>
<p>通过以上内容，你了解了很多关于如何处理状态码的知识。下面，你将看到如何查看服务器返回的具体数据内容。</p>
<h3 id="内容（Content）"><a href="#内容（Content）" class="headerlink" title="内容（Content）"></a>内容（Content）</h3><p>GET请求得到的响应经常包含很多有价值的信息，如消息正文中的payload。通过使用<code>Response</code>的属性和方法，你可以用不同的格式来查看payload。</p>
<p>用bytes的格式查看响应的内容，你可以使用<code>.content</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>response = requests.get(<span class="string">&#x27;https://api.github.com&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response.content</span><br><span class="line"><span class="string">b&#x27;&#123;&quot;current_user_url&quot;:&quot;https://api.github.com/user&quot;,&quot;current_user_authorizations_html_url&quot;:&quot;https://github.com/settings/connections/applications&#123;/client_id&#125;&quot;,&quot;authorizations_url&quot;:&quot;https://api.github.com/authorizations&quot;,&quot;code_search_url&quot;:&quot;https://api.github.com/search/code?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;commit_search_url&quot;:&quot;https://api.github.com/search/commits?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;emails_url&quot;:&quot;https://api.github.com/user/emails&quot;,&quot;emojis_url&quot;:&quot;https://api.github.com/emojis&quot;,&quot;events_url&quot;:&quot;https://api.github.com/events&quot;,&quot;feeds_url&quot;:&quot;https://api.github.com/feeds&quot;,&quot;followers_url&quot;:&quot;https://api.github.com/user/followers&quot;,&quot;following_url&quot;:&quot;https://api.github.com/user/following&#123;/target&#125;&quot;,&quot;gists_url&quot;:&quot;https://api.github.com/gists&#123;/gist_id&#125;&quot;,&quot;hub_url&quot;:&quot;https://api.github.com/hub&quot;,&quot;issue_search_url&quot;:&quot;https://api.github.com/search/issues?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;issues_url&quot;:&quot;https://api.github.com/issues&quot;,&quot;keys_url&quot;:&quot;https://api.github.com/user/keys&quot;,&quot;notifications_url&quot;:&quot;https://api.github.com/notifications&quot;,&quot;organization_repositories_url&quot;:&quot;https://api.github.com/orgs/&#123;org&#125;/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;organization_url&quot;:&quot;https://api.github.com/orgs/&#123;org&#125;&quot;,&quot;public_gists_url&quot;:&quot;https://api.github.com/gists/public&quot;,&quot;rate_limit_url&quot;:&quot;https://api.github.com/rate_limit&quot;,&quot;repository_url&quot;:&quot;https://api.github.com/repos/&#123;owner&#125;/&#123;repo&#125;&quot;,&quot;repository_search_url&quot;:&quot;https://api.github.com/search/repositories?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;current_user_repositories_url&quot;:&quot;https://api.github.com/user/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;starred_url&quot;:&quot;https://api.github.com/user/starred&#123;/owner&#125;&#123;/repo&#125;&quot;,&quot;starred_gists_url&quot;:&quot;https://api.github.com/gists/starred&quot;,&quot;team_url&quot;:&quot;https://api.github.com/teams&quot;,&quot;user_url&quot;:&quot;https://api.github.com/users/&#123;user&#125;&quot;,&quot;user_organizations_url&quot;:&quot;https://api.github.com/user/orgs&quot;,&quot;user_repositories_url&quot;:&quot;https://api.github.com/users/&#123;user&#125;/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;user_search_url&quot;:&quot;https://api.github.com/search/users?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过<code>.content</code>读取到的是字节格式的payload，如果你想要将其转换成UTF-8编码的字符串，你可以使用<code>.text</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>response.text</span><br><span class="line"><span class="string">&#x27;&#123;&quot;current_user_url&quot;:&quot;https://api.github.com/user&quot;,&quot;current_user_authorizations_html_url&quot;:&quot;https://github.com/settings/connections/applications&#123;/client_id&#125;&quot;,&quot;authorizations_url&quot;:&quot;https://api.github.com/authorizations&quot;,&quot;code_search_url&quot;:&quot;https://api.github.com/search/code?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;commit_search_url&quot;:&quot;https://api.github.com/search/commits?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;emails_url&quot;:&quot;https://api.github.com/user/emails&quot;,&quot;emojis_url&quot;:&quot;https://api.github.com/emojis&quot;,&quot;events_url&quot;:&quot;https://api.github.com/events&quot;,&quot;feeds_url&quot;:&quot;https://api.github.com/feeds&quot;,&quot;followers_url&quot;:&quot;https://api.github.com/user/followers&quot;,&quot;following_url&quot;:&quot;https://api.github.com/user/following&#123;/target&#125;&quot;,&quot;gists_url&quot;:&quot;https://api.github.com/gists&#123;/gist_id&#125;&quot;,&quot;hub_url&quot;:&quot;https://api.github.com/hub&quot;,&quot;issue_search_url&quot;:&quot;https://api.github.com/search/issues?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;issues_url&quot;:&quot;https://api.github.com/issues&quot;,&quot;keys_url&quot;:&quot;https://api.github.com/user/keys&quot;,&quot;notifications_url&quot;:&quot;https://api.github.com/notifications&quot;,&quot;organization_repositories_url&quot;:&quot;https://api.github.com/orgs/&#123;org&#125;/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;organization_url&quot;:&quot;https://api.github.com/orgs/&#123;org&#125;&quot;,&quot;public_gists_url&quot;:&quot;https://api.github.com/gists/public&quot;,&quot;rate_limit_url&quot;:&quot;https://api.github.com/rate_limit&quot;,&quot;repository_url&quot;:&quot;https://api.github.com/repos/&#123;owner&#125;/&#123;repo&#125;&quot;,&quot;repository_search_url&quot;:&quot;https://api.github.com/search/repositories?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;current_user_repositories_url&quot;:&quot;https://api.github.com/user/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;starred_url&quot;:&quot;https://api.github.com/user/starred&#123;/owner&#125;&#123;/repo&#125;&quot;,&quot;starred_gists_url&quot;:&quot;https://api.github.com/gists/starred&quot;,&quot;team_url&quot;:&quot;https://api.github.com/teams&quot;,&quot;user_url&quot;:&quot;https://api.github.com/users/&#123;user&#125;&quot;,&quot;user_organizations_url&quot;:&quot;https://api.github.com/user/orgs&quot;,&quot;user_repositories_url&quot;:&quot;https://api.github.com/users/&#123;user&#125;/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;user_search_url&quot;:&quot;https://api.github.com/search/users?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>因为将<code>bytes</code>转换成<code>str</code>需要指定编码的方式，<code>requests</code>会根据响应中的<code>hearders</code>内容来猜测编码的方式，或者，你也可以通过设置<code>.encoding</code>指定编码的方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>response.encoding = <span class="string">&#x27;utf-8&#x27;</span> <span class="comment"># Optional: requests infers this internally</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response.text</span><br><span class="line"><span class="string">&#x27;&#123;&quot;current_user_url&quot;:&quot;https://api.github.com/user&quot;,&quot;current_user_authorizations_html_url&quot;:&quot;https://github.com/settings/connections/applications&#123;/client_id&#125;&quot;,&quot;authorizations_url&quot;:&quot;https://api.github.com/authorizations&quot;,&quot;code_search_url&quot;:&quot;https://api.github.com/search/code?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;commit_search_url&quot;:&quot;https://api.github.com/search/commits?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;emails_url&quot;:&quot;https://api.github.com/user/emails&quot;,&quot;emojis_url&quot;:&quot;https://api.github.com/emojis&quot;,&quot;events_url&quot;:&quot;https://api.github.com/events&quot;,&quot;feeds_url&quot;:&quot;https://api.github.com/feeds&quot;,&quot;followers_url&quot;:&quot;https://api.github.com/user/followers&quot;,&quot;following_url&quot;:&quot;https://api.github.com/user/following&#123;/target&#125;&quot;,&quot;gists_url&quot;:&quot;https://api.github.com/gists&#123;/gist_id&#125;&quot;,&quot;hub_url&quot;:&quot;https://api.github.com/hub&quot;,&quot;issue_search_url&quot;:&quot;https://api.github.com/search/issues?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;issues_url&quot;:&quot;https://api.github.com/issues&quot;,&quot;keys_url&quot;:&quot;https://api.github.com/user/keys&quot;,&quot;notifications_url&quot;:&quot;https://api.github.com/notifications&quot;,&quot;organization_repositories_url&quot;:&quot;https://api.github.com/orgs/&#123;org&#125;/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;organization_url&quot;:&quot;https://api.github.com/orgs/&#123;org&#125;&quot;,&quot;public_gists_url&quot;:&quot;https://api.github.com/gists/public&quot;,&quot;rate_limit_url&quot;:&quot;https://api.github.com/rate_limit&quot;,&quot;repository_url&quot;:&quot;https://api.github.com/repos/&#123;owner&#125;/&#123;repo&#125;&quot;,&quot;repository_search_url&quot;:&quot;https://api.github.com/search/repositories?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;,&quot;current_user_repositories_url&quot;:&quot;https://api.github.com/user/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;starred_url&quot;:&quot;https://api.github.com/user/starred&#123;/owner&#125;&#123;/repo&#125;&quot;,&quot;starred_gists_url&quot;:&quot;https://api.github.com/gists/starred&quot;,&quot;team_url&quot;:&quot;https://api.github.com/teams&quot;,&quot;user_url&quot;:&quot;https://api.github.com/users/&#123;user&#125;&quot;,&quot;user_organizations_url&quot;:&quot;https://api.github.com/user/orgs&quot;,&quot;user_repositories_url&quot;:&quot;https://api.github.com/users/&#123;user&#125;/repos&#123;?type,page,per_page,sort&#125;&quot;,&quot;user_search_url&quot;:&quot;https://api.github.com/search/users?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果你仔细看一下响应的内容，你会发现实际上是序列化的<code>JSON</code>内容。因此，你可以通过<code>.text</code>的方式先获取字符串，然后再通过<a href="https://realpython.com/python-json/#deserializing-json"><code>json.loads()</code></a>的方式获取字典。其实，还有一种更为简单的方法，可以使用<code>.json()</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>response.json()</span><br><span class="line">&#123;<span class="string">&#x27;current_user_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/user&#x27;</span>, <span class="string">&#x27;current_user_authorizations_html_url&#x27;</span>: <span class="string">&#x27;https://github.com/settings/connections/applications&#123;/client_id&#125;&#x27;</span>, <span class="string">&#x27;authorizations_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/authorizations&#x27;</span>, <span class="string">&#x27;code_search_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/search/code?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&#x27;</span>, <span class="string">&#x27;commit_search_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/search/commits?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&#x27;</span>, <span class="string">&#x27;emails_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/user/emails&#x27;</span>, <span class="string">&#x27;emojis_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/emojis&#x27;</span>, <span class="string">&#x27;events_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/events&#x27;</span>, <span class="string">&#x27;feeds_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/feeds&#x27;</span>, <span class="string">&#x27;followers_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/user/followers&#x27;</span>, <span class="string">&#x27;following_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/user/following&#123;/target&#125;&#x27;</span>, <span class="string">&#x27;gists_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/gists&#123;/gist_id&#125;&#x27;</span>, <span class="string">&#x27;hub_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/hub&#x27;</span>, <span class="string">&#x27;issue_search_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/search/issues?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&#x27;</span>, <span class="string">&#x27;issues_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/issues&#x27;</span>, <span class="string">&#x27;keys_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/user/keys&#x27;</span>, <span class="string">&#x27;notifications_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/notifications&#x27;</span>, <span class="string">&#x27;organization_repositories_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/orgs/&#123;org&#125;/repos&#123;?type,page,per_page,sort&#125;&#x27;</span>, <span class="string">&#x27;organization_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/orgs/&#123;org&#125;&#x27;</span>, <span class="string">&#x27;public_gists_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/gists/public&#x27;</span>, <span class="string">&#x27;rate_limit_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/rate_limit&#x27;</span>, <span class="string">&#x27;repository_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/repos/&#123;owner&#125;/&#123;repo&#125;&#x27;</span>, <span class="string">&#x27;repository_search_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/search/repositories?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&#x27;</span>, <span class="string">&#x27;current_user_repositories_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/user/repos&#123;?type,page,per_page,sort&#125;&#x27;</span>, <span class="string">&#x27;starred_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/user/starred&#123;/owner&#125;&#123;/repo&#125;&#x27;</span>, <span class="string">&#x27;starred_gists_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/gists/starred&#x27;</span>, <span class="string">&#x27;team_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/teams&#x27;</span>, <span class="string">&#x27;user_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/users/&#123;user&#125;&#x27;</span>, <span class="string">&#x27;user_organizations_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/user/orgs&#x27;</span>, <span class="string">&#x27;user_repositories_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/users/&#123;user&#125;/repos&#123;?type,page,per_page,sort&#125;&#x27;</span>, <span class="string">&#x27;user_search_url&#x27;</span>: <span class="string">&#x27;https://api.github.com/search/users?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>.json()</code>返回的结果是一个字典，因此你可以通过键来访问字典中的值。</p>
<p>除了状态码和消息正文，你还可以查看响应中的Headers。</p>
<h2 id="报头（Headers）"><a href="#报头（Headers）" class="headerlink" title="报头（Headers）"></a>报头（Headers）</h2><p>响应中的报头通常包含很多有用的信息，例如内容类型，缓存内容的时间限制。</p>
<p>可以通过<code>.headers</code>来查看报头的内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>response.headers</span><br><span class="line">&#123;<span class="string">&#x27;Server&#x27;</span>: <span class="string">&#x27;GitHub.com&#x27;</span>, <span class="string">&#x27;Date&#x27;</span>: <span class="string">&#x27;Mon, 10 Dec 2018 17:49:54 GMT&#x27;</span>, <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json; charset=utf-8&#x27;</span>, <span class="string">&#x27;Transfer-Encoding&#x27;</span>: <span class="string">&#x27;chunked&#x27;</span>, <span class="string">&#x27;Status&#x27;</span>: <span class="string">&#x27;200 OK&#x27;</span>, <span class="string">&#x27;X-RateLimit-Limit&#x27;</span>: <span class="string">&#x27;60&#x27;</span>, <span class="string">&#x27;X-RateLimit-Remaining&#x27;</span>: <span class="string">&#x27;59&#x27;</span>, <span class="string">&#x27;X-RateLimit-Reset&#x27;</span>: <span class="string">&#x27;1544467794&#x27;</span>, <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;public, max-age=60, s-maxage=60&#x27;</span>, <span class="string">&#x27;Vary&#x27;</span>: <span class="string">&#x27;Accept&#x27;</span>, <span class="string">&#x27;ETag&#x27;</span>: <span class="string">&#x27;W/&quot;7dc470913f1fe9bb6c7355b50a0737bc&quot;&#x27;</span>, <span class="string">&#x27;X-GitHub-Media-Type&#x27;</span>: <span class="string">&#x27;github.v3; format=json&#x27;</span>, <span class="string">&#x27;Access-Control-Expose-Headers&#x27;</span>: <span class="string">&#x27;ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type&#x27;</span>, <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;Strict-Transport-Security&#x27;</span>: <span class="string">&#x27;max-age=31536000; includeSubdomains; preload&#x27;</span>, <span class="string">&#x27;X-Frame-Options&#x27;</span>: <span class="string">&#x27;deny&#x27;</span>, <span class="string">&#x27;X-Content-Type-Options&#x27;</span>: <span class="string">&#x27;nosniff&#x27;</span>, <span class="string">&#x27;X-XSS-Protection&#x27;</span>: <span class="string">&#x27;1; mode=block&#x27;</span>, <span class="string">&#x27;Referrer-Policy&#x27;</span>: <span class="string">&#x27;origin-when-cross-origin, strict-origin-when-cross-origin&#x27;</span>, <span class="string">&#x27;Content-Security-Policy&#x27;</span>: <span class="string">&quot;default-src &#x27;none&#x27;&quot;</span>, <span class="string">&#x27;Content-Encoding&#x27;</span>: <span class="string">&#x27;gzip&#x27;</span>, <span class="string">&#x27;X-GitHub-Request-Id&#x27;</span>: <span class="string">&#x27;E439:4581:CF2351:1CA3E06:5C0EA741&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>.headers</code>返回的是字典类型的<strong>对象</strong>，因此，你可以像访问字典一样来获取值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>response.headers[<span class="string">&#x27;Content-Type&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;application/json; charset=utf-8&#x27;</span></span><br></pre></td></tr></table></figure>

<p>headers对象有一个特殊的地方。由于HTTP标准定义headers不区分大小写，所以，我们访问headers的时候，不需要担心大小写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>response.headers[<span class="string">&#x27;content-type&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;application/json; charset=utf-8&#x27;</span></span><br></pre></td></tr></table></figure>

<p>以上例子中，无论使用<code>content-type</code>还是<code>Content-Type</code>，你都能得到相同的结果。</p>
<h2 id="查询字符串参数（Query-String-Parameters）"><a href="#查询字符串参数（Query-String-Parameters）" class="headerlink" title="查询字符串参数（Query String Parameters）"></a>查询字符串参数（Query String Parameters）</h2><p>通过在URL中传递查询字符串参数，可以定制GET请求。在方法<code>get()</code>中，可以传递参数<code>params</code>。例如，你可以使用GitHub的查询API来查找<code>requests</code>库。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># Search GitHub&#x27;s repositories for requests</span></span><br><span class="line">response = requests.get(</span><br><span class="line">    <span class="string">&#x27;https://api.github.com/search/repositories&#x27;</span>,</span><br><span class="line">    params=&#123;<span class="string">&#x27;q&#x27;</span>: <span class="string">&#x27;requests+language:python&#x27;</span>&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Inspect some attributes of the `requests` repository</span></span><br><span class="line">json_response = response.json()</span><br><span class="line">repository = json_response[<span class="string">&#x27;items&#x27;</span>][<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Repository name: <span class="subst">&#123;repository[<span class="string">&quot;name&quot;</span>]&#125;</span>&#x27;</span>)  <span class="comment"># Python 3.6+</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Repository description: <span class="subst">&#123;repository[<span class="string">&quot;description&quot;</span>]&#125;</span>&#x27;</span>)  <span class="comment"># Python 3.6+</span></span><br></pre></td></tr></table></figure>

<p>在方法<code>.get()</code>中，通过将字典<code>&#123;&#39;q&#39;: &#39;requests+language:python&#39;&#125;</code>传递给参数<code>params</code>，你可以改变从查询API返回的结果。</p>
<p>你也可以用字典作为参数<code>params</code>的值，也可以使用以元组为成员的数组作为参数<code>params</code>的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(</span><br><span class="line"><span class="meta">... </span>    <span class="string">&#x27;https://api.github.com/search/repositories&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>    params=[(<span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;requests+language:python&#x27;</span>)],</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure>

<p>甚至，你还可以传递bytes作为值传递给参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(</span><br><span class="line"><span class="meta">... </span>    <span class="string">&#x27;https://api.github.com/search/repositories&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>    params=<span class="string">b&#x27;q=requests+language:python&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure>

<p>查询字符串对于自定义GET请求非常有用。同时，你还可以通过添加或者修改报头来自定义GET请求。</p>
<h2 id="请求报头（Request-Headers）"><a href="#请求报头（Request-Headers）" class="headerlink" title="请求报头（Request Headers）"></a>请求报头（Request Headers）</h2><p>在方法<code>.get()</code>中，你可以通过将字典作为值传递给参数<code>headers</code>的方式，来自定义报头。例如，在之前的查询例子中，你可以通过在<code>Accept</code>报头中指定<code>text-match</code>类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">response = requests.get(</span><br><span class="line">    <span class="string">&#x27;https://api.github.com/search/repositories&#x27;</span>,</span><br><span class="line">    params=&#123;<span class="string">&#x27;q&#x27;</span>: <span class="string">&#x27;requests+language:python&#x27;</span>&#125;,</span><br><span class="line">    headers=&#123;<span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;application/vnd.github.v3.text-match+json&#x27;</span>&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># View the new `text-matches` array which provides information</span></span><br><span class="line"><span class="comment"># about your search term within the results</span></span><br><span class="line">json_response = response.json()</span><br><span class="line">repository = json_response[<span class="string">&#x27;items&#x27;</span>][<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Text matches: <span class="subst">&#123;repository[<span class="string">&quot;text_matches&quot;</span>]&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><code>Accept</code>报头可以告诉服务器，你的应用可以处理的消息正文类型。在本例中，你使用的报头值是<code>application/vnd.github.v3.text-match+json</code>，这是GitHub网站<code>Accept</code>报头的专有属性，正文内容是一种特殊的JSON格式。</p>
<p>在学习其它自定义请求的方式之前，我们先简单了解一下其它的HTTP方法。</p>
<h2 id="其它的HTTP方法"><a href="#其它的HTTP方法" class="headerlink" title="其它的HTTP方法"></a>其它的HTTP方法</h2><p>除了GET以前，HTTP还支持<code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>HEAD</code>, <code>PATCH</code>和<code>OPTIONS</code>。在<code>requests</code>库中给，这些方法的使用方法和<code>get()</code>相似：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.post(<span class="string">&#x27;https://httpbin.org/post&#x27;</span>, data=&#123;<span class="string">&#x27;key&#x27;</span>:<span class="string">&#x27;value&#x27;</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.put(<span class="string">&#x27;https://httpbin.org/put&#x27;</span>, data=&#123;<span class="string">&#x27;key&#x27;</span>:<span class="string">&#x27;value&#x27;</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.delete(<span class="string">&#x27;https://httpbin.org/delete&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.head(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.patch(<span class="string">&#x27;https://httpbin.org/patch&#x27;</span>, data=&#123;<span class="string">&#x27;key&#x27;</span>:<span class="string">&#x27;value&#x27;</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.options(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>以下例子中，每一个函数调用都会对httpbin服务发起相应的HTTP方法。每一种方法，你都可以使用和之前相同的方式，查看服务器响应的内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>response = requests.head(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response.headers[<span class="string">&#x27;Content-Type&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;application/json&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response = requests.delete(<span class="string">&#x27;https://httpbin.org/delete&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json_response = response.json()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json_response[<span class="string">&#x27;args&#x27;</span>]</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>报头、响应正文、状态码和其它信息都会包含在每一种HTTP方法的<code>Response</code>中。接下来，你将更为详细地了解<code>POST</code>，<code>PUT</code>和<code>PATCH</code>方法，以及它们之间的区别。</p>
<h2 id="消息正文"><a href="#消息正文" class="headerlink" title="消息正文"></a>消息正文</h2><p>根据HTTP的规格说明，<code>POST</code>，<code>PUT</code>和<code>PATCH</code>都是通过将数据传递给消息正文，而不是通过将查询字符串传递给参数的方式。通过使用<code>requests</code>，你可以将<code>payload</code>传递给<code>data</code>参数。</p>
<p>你可以将字典，元组为成员的列表或者文件对象传递给参数<code>data</code>。在请求的正文中，根据具体的类型需要，你可以采用不同的数据类型：</p>
<p>例如，如果你请求的内容类型为<code>application/x-www-form-urlencoded</code>，那么你就可以将字典作为表格数据，传递给参数<code>data</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.post(<span class="string">&#x27;https://httpbin.org/post&#x27;</span>, data=&#123;<span class="string">&#x27;key&#x27;</span>:<span class="string">&#x27;value&#x27;</span>&#125;)</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure>

<p>你也可以使用以元组为成员的列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.post(<span class="string">&#x27;https://httpbin.org/post&#x27;</span>, data=[(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>)])</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure>

<p>但是，如果你需要发送JSON格式的数据，你可以使用参数<code>json</code>。当你将值传递给参数<code>json</code>后，<code>requests</code>库会序列化你的数据和正确的<code>Content-Type</code>报头。</p>
<p><a href="https://httpbin.org/">httpbin.org</a>是由<code>requests</code>库的开发者 <a href="https://realpython.com/interview-kenneth-reitz/">Kenneth Reitz</a>创建的一个用于测试的网站。该网站可以用来测试<code>requests</code>发起的各种请求。例如，你可以用它来测试POST请求：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>response = requests.post(<span class="string">&#x27;https://httpbin.org/post&#x27;</span>, json=&#123;<span class="string">&#x27;key&#x27;</span>:<span class="string">&#x27;value&#x27;</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json_response = response.json()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json_response[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;&#123;&quot;key&quot;: &quot;value&quot;&#125;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json_response[<span class="string">&#x27;headers&#x27;</span>][<span class="string">&#x27;Content-Type&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;application/json&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="检查请求"><a href="#检查请求" class="headerlink" title="检查请求"></a>检查请求</h2><p>在发送请求到服务器之前，<code>requests</code>库会先将请求准备好。请求的准备包括验证报头以及序列化JSON内容。</p>
<p>你可以通过<code>.request</code>来访问准备请求（<code>PrepareRequest</code>）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>response = requests.post(<span class="string">&#x27;https://httpbin.org/post&#x27;</span>, json=&#123;<span class="string">&#x27;key&#x27;</span>:<span class="string">&#x27;value&#x27;</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response.request.headers[<span class="string">&#x27;Content-Type&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;application/json&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response.request.url</span><br><span class="line"><span class="string">&#x27;https://httpbin.org/post&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response.request.body</span><br><span class="line"><span class="string">b&#x27;&#123;&quot;key&quot;: &quot;value&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>检查准备请求可以让你访问各种信息，包括payload, URL, headers, authentication等等。</p>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>认证可以让服务器知道你是谁。通常情况下，你可以通过<code>Authorization</code>报头提供你的身份信息，或者也可以通过自定义的报头来提供身份信息。在<code>requests</code>中，你可以使用参数<code>auth</code>来传递你的身份信息。</p>
<p>下面以GitHub的<a href="https://developer.github.com/v3/users/#get-the-authenticated-user">Authenticated User</a> API为例。为了访问该API，你需要通过一个元组来传递用户名和密码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> getpass <span class="keyword">import</span> getpass</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">&#x27;https://api.github.com/user&#x27;</span>, auth=(<span class="string">&#x27;username&#x27;</span>, getpass()))</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure>

<p>如果身份信息正确，request请求就会返回成功过。如果request请求中没有包含身份信息，服务器就会返回<code>401 Unauthorized</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">&#x27;https://api.github.com/user&#x27;</span>)</span><br><span class="line">&lt;Response [<span class="number">401</span>]&gt;</span><br></pre></td></tr></table></figure>

<p>当你通过以上这种方式传递身份信息的时候，实际上<code>requests</code>使用的是HTTP的 <a href="https://en.wikipedia.org/wiki/Basic_access_authentication">Basic access authentication scheme</a>。</p>
<p>因此，你还可以使用<code>HTTPBasicAuth</code>来传递身份信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> getpass <span class="keyword">import</span> getpass</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(</span><br><span class="line"><span class="meta">... </span>    <span class="string">&#x27;https://api.github.com/user&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>    auth=HTTPBasicAuth(<span class="string">&#x27;username&#x27;</span>, getpass())</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure>

<p>除了Basic认证方式以外，<code>requests</code>还支持其它认证方式，例如<code>HTTPDigestAuth</code>和<code>HTTPProxyAuth</code>。</p>
<p>你甚至还可以提供自定义的认证方式。但是，你必须首先创建一个继承<code>AuthBase</code>的子类。然后，你需要定义<code>__call__()</code>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.auth <span class="keyword">import</span> AuthBase</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TokenAuth</span>(<span class="title class_ inherited__">AuthBase</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Implements a custom authentication scheme.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, token</span>):</span><br><span class="line">        self.token = token</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, r</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Attach an API token to a custom auth header.&quot;&quot;&quot;</span></span><br><span class="line">        r.headers[<span class="string">&#x27;X-TokenAuth&#x27;</span>] = <span class="string">f&#x27;<span class="subst">&#123;self.token&#125;</span>&#x27;</span>  <span class="comment"># Python 3.6+</span></span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">requests.get(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>, auth=TokenAuth(<span class="string">&#x27;12345abcde-token&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>以上例子中，自定义的类<code>TokenAuth</code>会收到一个Token，然后将收到的token放到<code>x-TokenAuth</code>报头中。</p>
<p>不健全的认证机制会导致安全隐患，所以除非有特殊需求，否则应该使用成熟的认证机制，比如Basic或者OAuth。</p>
<h2 id="SSL证书验证"><a href="#SSL证书验证" class="headerlink" title="SSL证书验证"></a>SSL证书验证</h2><p>任何时候，当发送和接收的信息比较机密，安全往往是最重要的。因此，当你访问安全站点的时候，都会通过SSL建立安全连接，这时候对服务器的SSL证书进行验证显得尤为重要。</p>
<p>默认情况下，<code>requests</code>已经为你执行了SSL证书的验证。但是，在某些情况下，你可能希望改变这种默认的行为。</p>
<p>如果你想要关闭SSL证书的验证，你可以将参数<code>verify</code>设置为<code>False</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">&#x27;https://api.github.com&#x27;</span>, verify=<span class="literal">False</span>)</span><br><span class="line">InsecureRequestWarning: Unverified HTTPS request <span class="keyword">is</span> being made. Adding certificate verification <span class="keyword">is</span> strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html<span class="comment">#ssl-warnings</span></span><br><span class="line">  InsecureRequestWarning)</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure>

<p>当你正在访问一个不安全的站点时，<code>requests</code>会发出警告信息提醒你。</p>
<blockquote>
<p>注意：<code>requests</code>使用<a href="http://docs.python-requests.org/en/master/user/advanced/#ca-certificates"><code>certifi</code></a>来提供SSL证书的颁发机构（ Certificate Authorities）。这可以让<code>requests</code>知道有哪些可以信任的证书颁发机构。因此，你需要定期更新<code>certifi</code>来保证安全性。</p>
</blockquote>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>当在生产环境中使用<code>requests</code>的时候，特别需要考虑性能的影响。<code>requests</code>库的一些特性，例如超时控制（timeout control），会话（sessions）和重试限制（retry limits）可以使得应用运行得更流畅。</p>
<h3 id="Timeouts"><a href="#Timeouts" class="headerlink" title="Timeouts"></a>Timeouts</h3><p>当你向服务发送请求以后，你得应用将会等待服务端的响应，得到响应以后，才会执行下一步操作。如果应用等待的时间太长，请求就会一直处于等待状态，导致用户体验变差，或者后台任务挂起。</p>
<p>默认情况下，<code>requests</code>将会无限制地等待响应，所以你应该指定一个超时的时间值。你可以通过参数<code>timeout</code>来设置超时的时间值。<code>timeout</code>的值可以是整型或者浮点型，时间的单位是秒。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">&#x27;https://api.github.com&#x27;</span>, timeout=<span class="number">1</span>)</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">&#x27;https://api.github.com&#x27;</span>, timeout=<span class="number">3.05</span>)</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure>

<p>以上例子中，第一个请求的超时时间是1秒，第二个请求的超时时间是3.05秒。</p>
<p>你还可以传递一个<a href="http://docs.python-requests.org/en/master/user/advanced/#timeouts">元组</a>给参数<code>timeout</code>，元组中的第一个值是TCP连接的超时时间（客户端和服务器之间建立连接的时长，通常建议设置为比3的倍数大一点），第二个值是数据传输的超时时间（建立连接后，等待响应的超时时间）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">&#x27;https://api.github.com&#x27;</span>, timeout=(<span class="number">2</span>, <span class="number">5</span>))</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure>

<p>如果请求建立连接的时间在2秒以内，建立连接后，接收数据的时间在5秒以内，那么就可以正常获取到响应。但是，如果请求超时，那么函数就会抛出一个<code>Timeout</code>的异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> Timeout</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = requests.get(<span class="string">&#x27;https://api.github.com&#x27;</span>, timeout=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> Timeout:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The request timed out&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The request did not time out&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>你的程序可以捕获这个<code>Timeout</code>的异常，并做相应的处理。</p>
<h3 id="The-Session-Object"><a href="#The-Session-Object" class="headerlink" title="The Session Object"></a>The Session Object</h3><p>到目前为止，你都是使用<code>requests</code>的<code>get()</code>和<code>post()</code>来发送请求。这些函数隐藏了一些细节，例如连接是如何建立以及管理的。</p>
<p>实际上，这些细节都是由类<code>Session</code>来负责处理。如果你需要微调你的请求，或者改进性能，你需要直接使用<code>Session</code>的实例。</p>
<p>会话主要是在一些列的请求中，保持持久的参数。例如，如果你想要在多个请求中使用相同的认证信息，你就可以使用会话：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> getpass <span class="keyword">import</span> getpass</span><br><span class="line"></span><br><span class="line"><span class="comment"># By using a context manager, you can ensure the resources used by</span></span><br><span class="line"><span class="comment"># the session will be released after use</span></span><br><span class="line"><span class="keyword">with</span> requests.Session() <span class="keyword">as</span> session:</span><br><span class="line">    session.auth = (<span class="string">&#x27;username&#x27;</span>, getpass())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Instead of requests.get(), you&#x27;ll use session.get()</span></span><br><span class="line">    response = session.get(<span class="string">&#x27;https://api.github.com/user&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># You can inspect the response just like you did before</span></span><br><span class="line"><span class="built_in">print</span>(response.headers)</span><br><span class="line"><span class="built_in">print</span>(response.json())</span><br></pre></td></tr></table></figure>

<p>每次你用session发起请求，一旦该会话在初始化时，设定了认证的身份信息，那么该身份信息就可以在多个requests中重复使用。</p>
<p>通过session改进性能，主要是通过保持长连接的方式。当你的应用通过Session来发起请求，它就会在连接池中长时间保持该连接。当应用想要再次连接到同一个服务器的时候，就可以重复使用连接池中的连接，而不需要再新建连接。</p>
<h3 id="Max-Retries"><a href="#Max-Retries" class="headerlink" title="Max Retries"></a>Max Retries</h3><p>当请求失败的时候，你可能希望应用重新发起同样的请求。但是，<code>requests</code>默认并不会帮你重新发送请求。为了实现这个功能，你需要使用<a href="http://docs.python-requests.org/en/master/user/advanced/#transport-adapters">Transport Adapter</a>。</p>
<p>Transport Adapters可以让你为每一个需要访问的服务定义一组配置信息。例如，你想要所有访问<code>https://api.github.com</code>的请求失败后重复三次，你可以创建一个Transport Adapter，设置参数<code>max_retries</code>的值为3，并将其挂载到当前的会话上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.adapters <span class="keyword">import</span> HTTPAdapter</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> ConnectionError</span><br><span class="line"></span><br><span class="line">github_adapter = HTTPAdapter(max_retries=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">session = requests.Session()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use `github_adapter` for all requests to endpoints that start with this URL</span></span><br><span class="line">session.mount(<span class="string">&#x27;https://api.github.com&#x27;</span>, github_adapter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    session.get(<span class="string">&#x27;https://api.github.com&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> ConnectionError <span class="keyword">as</span> ce:</span><br><span class="line">    <span class="built_in">print</span>(ce)</span><br></pre></td></tr></table></figure>

<p>当你挂载github_adapter到会话的时候，会话会遵循该配置的设置。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上内容，你现在可以：</p>
<ul>
<li>发送不同的HTTP请求，例如：GET, POST, PUT</li>
<li>通过修改报头，认证，查询字符串和消息这个问，自定义请求</li>
<li>检查发送给服务器的数据，以及从服务器接收的数据</li>
<li>SSL证书验证</li>
<li>通过max_retries, timeout, Sessions和Transport Adapters，更有效的使用<code>requests</code></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Home Assistant更新DDNS记录</title>
    <url>/2024/09/26/home-assistant/ru-he-shi-yong-home-assistant-geng-xin-ddns-ji-lu/</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>由于家中的宽带运营商不提供公网IPv4地址，所以一直都没有将Home Assistant发布到公网。最近无意中从网上了解到可以使用IPv6的公网地址，经过测试，确实有效。</p>
<p>考虑到IPv6地址是动态分配的，间隔一段时间就会自动更新为新的IPv6地址，于是就在免费的DDNS服务商<a href="https://dynv6.com/">Dynv6</a>申请了动态域名。根据Dynv6官方API文档介绍，IPv6不支持用<code>Remote Access API</code>，也就意味着不支持用<a href="https://ddclient.net/">ddclient</a>作为客户端，来自动更新DDNS记录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### DynDNS API</span><br><span class="line"></span><br><span class="line">We implemented the dyn.com [Remote Access API](https://help.dyn.com/remote-access-api/) that is also known as the _Members NIC Update API_ or _DNS Update API_. It can only be used to update the IPv4 address of a zone.</span><br><span class="line"></span><br><span class="line">To use the endpoint https://dynv6.com/nic/update please set the server in your client to &#x27;dynv6.com&#x27;.</span><br></pre></td></tr></table></figure>

<p>根据<a href="https://dynv6.github.io/api-spec/">REST API for dynv6</a>文档，自己用Python写了一个脚本，用于自动更新DDNS记录。经过一段时间的使用，基本能满足需求，但是仍然有一些小瑕疵，比如运营商自动分配IPv6地址的过程中，有时候会出现短时间内（5-10分钟）多次分配IP地址的情况，并且网络也会变得很不稳定，这时会导致DDNS更新出现问题。</p>
<p>最近在使用Home Assistant的过程中，发现了<code>RESTful Command</code>的集成，于是想到为何不干脆使用Home Assistant来完成DDNS记录的更新，这样还省去了单独维护Python脚本的时间成本。</p>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>其实需求很简单，就是当Home Assistant的IPv6地址自动更新为新地址的时候，Home Assistant自动将新地址更新到<code>Dynv6</code>的动态域名记录中。</p>
<h3 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h3><p>为了实现上述需求，需要考虑以下细节：</p>
<ul>
<li><p>触发器</p>
<p>  Home Assistant会实时监控公网IPv6地址的变化，当IP地址发生变化，就会触发Home Assistant更新DDNS记录的动作。</p>
</li>
<li><p>触发的先决条件</p>
<p>  Home Assistant需要实时监控Dynv6 Rest API的网络连接，以确保可以成功更新DDNS记录。如果网络连接异常，即使公网IPv6地址发生改变，也不会触发Home Assistant的更新DDNS记录的动作。</p>
</li>
<li><p>动作</p>
<p>  Home Assistant执行更新DDNS记录的动作。</p>
</li>
</ul>
<h2 id="System-Monitor"><a href="#System-Monitor" class="headerlink" title="System Monitor"></a>System Monitor</h2><p><strong>System Monitor</strong>可以用来监控CPU、内存、硬盘等硬件信息，在这里，主要用来实时获取网口的IPv6地址信息。当IPv6地址发生改变时，就可以触发Home Assistant的自动化操作。</p>
<p><strong>System Monitor</strong>是Home Assistant的一个集成，或者说是扩展功能，使用之前需要手工添加和配置。</p>
<p>以下是网口IPv6地址的实体ID，该实体的值是IPv6地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">entity_id: sensor.system_monitor_ipv6_address_eth0</span><br></pre></td></tr></table></figure>

<h2 id="Dynv6-Rest-API"><a href="#Dynv6-Rest-API" class="headerlink" title="Dynv6 Rest API"></a>Dynv6 Rest API</h2><p><a href="https://dynv6.github.io/api-spec/">REST API for dynv6</a></p>
<p><strong>Rest API URL</strong><br><a href="https://dynv6.com/api/v2">https://dynv6.com/api/v2</a></p>
<p>Dynv6 Rest API主要分为两大类：<strong>Zones</strong>和<strong>Records</strong>。</p>
<h3 id="Zones"><a href="#Zones" class="headerlink" title="Zones"></a>Zones</h3><p><strong>GET</strong>          Get a list of records<br><strong>POST</strong>       Add a new record<br><strong>GET</strong>          Get details for a record<br><strong>PATCH</strong>     Update an existing record<br><strong>DEL</strong>           Delete a record</p>
<h3 id="Records"><a href="#Records" class="headerlink" title="Records"></a>Records</h3><p><strong>GET</strong>          Get a list of zones<br><strong>POST</strong>       Register a new zone<br><strong>GET</strong>          Get details for a zone<br><strong>PATCH</strong>     Update an existing zone<br><strong>DEL</strong>           Delete the zone<br><strong>GET</strong>           Get details of a zone by its name</p>
<p>下载：<a href="openapi.json">openapi.json</a></p>
<h2 id="Command-Line"><a href="#Command-Line" class="headerlink" title="Command Line"></a>Command Line</h2><p><strong>Command Line</strong>是Home Assistant中的一个集成功能，可以通过命令的方式，定义一种传感器实体。因此，通过该集成，可以定义一个二进制传感器，检测Dynv6 Rest API的网络连接性。</p>
<h3 id="nc工具"><a href="#nc工具" class="headerlink" title="nc工具"></a>nc工具</h3><p>为了检测Dynv6 Rest API的网络连接性，可以使用命令行工具<code>nc</code>。</p>
<p>以下命令可以用来检测Home Assistant和Dynv6 Rest API服务之间的网络连接性。如果Home Assistant与Dynv6 Rest API服务的TCP 443端口连接成功，返回“success”，否则返回“fail”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -6z -w 2 dynv6.com 443 &gt; /dev/null 2&gt;&amp;1 &amp;&amp; echo success || echo fail&#x27;&quot;	</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<p>-6        指定nc使用本机的IPv6地址。使用该选项，主要是为了确保IPv6已经更新完成，并能够与Dynv6 API服务之间正常通讯，这也是为了避免前面所提到的，自己写的脚本中的“小瑕疵”。<br>-z         nc只做端口扫描，不传输数据。<br>-w        如果连接不上，2秒后超时。</p>
<h3 id="SSH远程命令"><a href="#SSH远程命令" class="headerlink" title="SSH远程命令"></a>SSH远程命令</h3><p>另外，由于Home Assistant是通过容器的方式安装，并且容器中<code>nc</code>工具的版本不支持IPv6，所以只能考虑用主机的<code>nc</code>。为了能调用主机的<code>nc</code>，决定使用SSH的方式远程调用命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -o StrictHostKeychecking=no pi@pi -i /config/.ssh/id_rsa &#x27;nc -6z -w 2 \</span><br><span class="line">			 dynv6.com 443 &gt; /dev/null 2&gt;&amp;1 &amp;&amp; echo success || echo fail&#x27;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<p>-o StrictHostKeychecking&#x3D;no      登录时不需要验证目标主机的Key<br>-i &#x2F;config&#x2F;.ssh&#x2F;id_rsa                        私钥文件的位置</p>
<h3 id="configuration-yaml"><a href="#configuration-yaml" class="headerlink" title="configuration.yaml"></a>configuration.yaml</h3><p>以下是Home Assistant的配置文件<code>configuration.yaml</code>中的详细配置信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- binary_sensor:	</span><br><span class="line">	name: &#x27;Dynv6 API&#x27;	</span><br><span class="line">	command: &quot;ssh -o StrictHostKeychecking=no pi@pi -i /config/.ssh/id_rsa &#x27;nc -6z -w 2 \</span><br><span class="line">			 dynv6.com 443 &gt; /dev/null 2&gt;&amp;1 &amp;&amp; echo success || echo fail&#x27;&quot;	</span><br><span class="line">	payload_on: success	</span><br><span class="line">	payload_off: fail	</span><br><span class="line">	scan_interval: 60	</span><br><span class="line">	icon: mdi:api	</span><br><span class="line">	unique_id: cmd_dynv6_api	</span><br><span class="line">	device_class: connectivity</span><br></pre></td></tr></table></figure>

<p>以上配置定义了一个二进制传感器，该传感器的名字为“Dynv6 API”，每60秒执行一次网络连接性测试，如果成功则返回“success”，否则返回“fail”。</p>
<h2 id="RESTful-Command"><a href="#RESTful-Command" class="headerlink" title="RESTful Command"></a>RESTful Command</h2><p><strong>RESTful Command</strong>是Home Assistant中的一个集成功能，通过该集成，可以定义一个对Rest API的操作请求，执行DDNS记录的更新。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rest_command:</span><br><span class="line">	dynv6_update_zone:</span><br><span class="line">	url: https://dynv6.com/api/v2/zones/&lt;zone_id&gt;</span><br><span class="line">	method: patch</span><br><span class="line">	content_type: application/json</span><br><span class="line">	headers:	</span><br><span class="line">		authorization: &#x27;Bearer &lt;Token&gt;&#x27;</span><br><span class="line">	payload: &#x27;&#123;&quot;ipv6prefix&quot;:&quot;&#123;&#123; states(&quot;sensor.system_monitor_ipv6_address_eth0&quot;) &#125;&#125;&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>url               zone_id需要替换成与Zone对应的id。<br>method     更新Zone的方法需要用PATCH。<br>authorization        需要用Token。<br>payload:    更新后的IPv6地址，此处是读取传感器<code>sensor.system_monitor_ipv6_address_eth0</code>的值。</p>
<h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><p>在Home Assistant中，创建一个名为“DDNS｜自动更新动态域名”的自动化，该自动化可以实现自动更新DDNS记录的需求。</p>
<h3 id="trigger"><a href="#trigger" class="headerlink" title="trigger"></a>trigger</h3><p>如果传感器<code>sensor.system_monitor_ipv6_address_eth0</code>值发生变化，触发器就会被自动触发。</p>
<p>to: null 传感器的值发生任何变化都会导致触发器被触发。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trigger:</span><br><span class="line">  - platform: state</span><br><span class="line">    entity_id:</span><br><span class="line">      - sensor.system_monitor_ipv6_address_eth0</span><br><span class="line">    to: null</span><br><span class="line">    enabled: true</span><br></pre></td></tr></table></figure>

<h3 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h3><p>触发器被触发的先决条件是，二进制传感器<code>binary_sensor.dynv6_api</code>的状态必须是<code>on</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">condition:</span><br><span class="line">  - condition: state</span><br><span class="line">    entity_id: binary_sensor.dynv6_api</span><br><span class="line">    state: &quot;on&quot;</span><br></pre></td></tr></table></figure>

<h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>当自动化被触发器成功触发后，就会执行操作<code>rest_command.dynv6_update_zone</code>，该操作将执行DDNS记录的更新。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">action:</span><br><span class="line">  - action: rest_command.dynv6_update_zone</span><br><span class="line">    data: &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="configuration-yaml-1"><a href="#configuration-yaml-1" class="headerlink" title="configuration.yaml"></a>configuration.yaml</h3><p>以下是自动化的详细配置信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias: DDNS｜自动更新动态域名</span><br><span class="line">description: &quot;&quot;</span><br><span class="line">trigger:</span><br><span class="line">  - platform: state</span><br><span class="line">    entity_id:</span><br><span class="line">      - sensor.system_monitor_ipv6_address_eth0</span><br><span class="line">    to: null</span><br><span class="line">    enabled: true</span><br><span class="line">condition:</span><br><span class="line">  - condition: state</span><br><span class="line">    entity_id: binary_sensor.dynv6_api</span><br><span class="line">    state: &quot;on&quot;</span><br><span class="line">action:</span><br><span class="line">  - action: rest_command.dynv6_update_zone</span><br><span class="line">    data: &#123;&#125;</span><br><span class="line">mode: single</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Home_Assistant</category>
      </categories>
      <tags>
        <tag>home_assistant</tag>
      </tags>
  </entry>
  <entry>
    <title>用Home Assistanat跟踪汽油价格</title>
    <url>/2024/09/29/home-assistant/yong-home-assistanat-gen-zong-qi-you-jie-ge/</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>虽然新能源汽车越来越普及，但是就目前而言，传统的燃油车仍然是占比最高的车型。因此，每次油价的调整自然会备受车主的关注。</p>
<p>由于平时懒得打开App查看油价，所以每次加油时才会看一眼加油站的标价。因此，其实本人对汽油的价格并不感冒。但是，最近一直在“折腾”Home Assistant，脑海中浮现的想法都是围绕着它展开，于是就想到了用Home Assistant来跟踪油价的变化。</p>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>首先，汽油的价格能够被实时获取，并且获得的数据能够被存储到Home Assistant中。当汽油的价格发生变化时，例如上涨或者下跌，Home Assistant可以发送通知到本人的手机。</p>
<h2 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h2><p>在网上查找了一下关于汽油价格的网站，发现以下网站的信息比较全面，并且提供的油价可以精确到区级。</p>
<p><a href="http://www.qiyoujiage.com/">http://www.qiyoujiage.com/</a></p>
<p>下面以上海为例，访问的网址是： <a href="http://www.qiyoujiage.com/shanghai.shtml">http://www.qiyoujiage.com/shanghai.shtml</a> ，网页的部分源代码如下：</p>
<p>&lt;dl&gt; &lt;dt&gt; &lt;dd&gt;是HTML中的一套组合标签，可以用于制作网页中的表格。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;youjia&quot;&gt;</span><br><span class="line">	&lt;dl&gt;</span><br><span class="line">		&lt;dt&gt;上海92#汽油&lt;/dt&gt;</span><br><span class="line">		&lt;dd&gt;7.34&lt;/dd&gt;</span><br><span class="line">	&lt;/dl&gt;</span><br><span class="line">	&lt;dl&gt;</span><br><span class="line">		&lt;dt&gt;上海95#汽油&lt;/dt&gt;</span><br><span class="line">		&lt;dd&gt;7.81&lt;/dd&gt;</span><br><span class="line">	&lt;/dl&gt;</span><br><span class="line">	&lt;dl&gt;</span><br><span class="line">		&lt;dt&gt;上海98#汽油&lt;/dt&gt;</span><br><span class="line">		&lt;dd&gt;9.71&lt;/dd&gt;</span><br><span class="line">	&lt;/dl&gt;</span><br><span class="line">	&lt;dl&gt;</span><br><span class="line">		&lt;dt&gt;上海0#柴油&lt;/dt&gt;</span><br><span class="line">		&lt;dd&gt;6.99&lt;/dd&gt;</span><br><span class="line">	&lt;/dl&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Beautiful-Soup"><a href="#Beautiful-Soup" class="headerlink" title="Beautiful Soup"></a>Beautiful Soup</h2><p><code>Beautiful Soup</code>是一款非常著名的Python第三方库，可以用来解析HTML文本，且非常简单易用。</p>
<p>首先，用<code>Requests</code>获取网页的内容，并将返回的结果存储到<code>response</code>变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://www.qiyoujiage.com/shanghai.shtml&#x27;</span></span><br><span class="line">response = requests.get(url, timeout=(<span class="number">5</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<p>用<code>Beautiful Soup</code>来解析网页内容（<code>response.content</code>），先查找所有<code>dl</code>标签，然后用<code>for</code>循环语句迭代每一个<code>dl</code>标签的内容，如果找到关键字<code>92</code>，就结束循环，并返回<code>name</code>和<code>price</code>。</p>
<p>为了便于Home Assistant处理脚本返回的值，此处最终结果以JSON字符串的格式输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">format_string = <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span></span><br><span class="line">now = datetime.strftime(datetime.now(), format_string)</span><br><span class="line"></span><br><span class="line">youjia_92 = &#123;&#125;</span><br><span class="line">soup = BeautifulSoup(response.content, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> dl <span class="keyword">in</span> soup.find_all(<span class="string">&#x27;dl&#x27;</span>):</span><br><span class="line">	name = dl.find(<span class="string">&#x27;dt&#x27;</span>).text.strip()</span><br><span class="line">	value = <span class="built_in">float</span>(dl.find(<span class="string">&#x27;dd&#x27;</span>).text.strip())</span><br><span class="line">	<span class="keyword">if</span> <span class="string">&#x27;92&#x27;</span> <span class="keyword">in</span> name:</span><br><span class="line">		youjia_92[<span class="string">&#x27;name&#x27;</span>] = name</span><br><span class="line">		youjia_92[<span class="string">&#x27;price&#x27;</span>] = value</span><br><span class="line">		youjia_92[<span class="string">&#x27;last_update&#x27;</span>] = now</span><br><span class="line">		<span class="built_in">print</span>(json.dumps(youjia_92))</span><br><span class="line">		<span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>运行以上代码，就会得到下面的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;上海92#汽油&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="number">7.34</span>, <span class="string">&quot;last_update&quot;</span>: <span class="string">&quot;2024-09-28 12:33:01&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Command-Line"><a href="#Command-Line" class="headerlink" title="Command Line"></a>Command Line</h2><p>打开并编辑Home Assistant的配置文件<code>configuration.yaml</code>，添加传感器的配置内容。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">command_line:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">sensor:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">&quot;上海92#油价&quot;</span></span><br><span class="line">		<span class="attr">command:</span> <span class="string">python3</span> <span class="string">./scripts/oil_price/oil_price.py</span></span><br><span class="line">		<span class="attr">json_attributes:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">name</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">last_update</span></span><br><span class="line">		<span class="attr">value_template:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; value_json.price &#125;&#125;</span>&quot;</span></span><br><span class="line">		<span class="attr">device_class:</span> <span class="string">monetary</span></span><br><span class="line">		<span class="attr">unit_of_measurement:</span> <span class="string">元</span></span><br><span class="line">		<span class="attr">unique_id:</span> <span class="string">command_oil_price</span></span><br><span class="line">		<span class="attr">scan_interval:</span> <span class="number">7200</span></span><br><span class="line">		<span class="attr">command_timeout:</span> <span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>配置参数说明：</p>
<p>name                         传感器的名称<br>command                需要执行的命令或者脚本<br>json_attributes       传感器的属性，此处有两个属性：name和last_update<br>value_template      获取命令或者脚本返回的值<br>device_class           实体的类型，Home Assistant会根据设置的类型，在Dashboard中适配相应的图表<br>unit_of_measurement   值的单位<br>scan_interval          执行脚本的时间间隔，默认单位为“秒”<br>command_timeout  命令或者脚本默认15秒后超时，此处设置为60秒</p>
<p>完成以上配置，并重载命令行配置以后，在Home Assistant中就会新增一个实体，该实体的标识符为<br><code>sensor.shang_hai_92_you_jie</code>。</p>
<p>该实体的状态属性如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: 上海92#汽油</span><br><span class="line">last_update: &quot;2024-09-29 16:19:12&quot;</span><br><span class="line">price_changed: 油价下跌</span><br><span class="line">unit_of_measurement: 元</span><br><span class="line">device_class: monetary</span><br><span class="line">icon: mdi:gas-station</span><br><span class="line">friendly_name: 上海92#油价</span><br></pre></td></tr></table></figure>

<h2 id="油价涨跌变化"><a href="#油价涨跌变化" class="headerlink" title="油价涨跌变化"></a>油价涨跌变化</h2><p>为了能跟踪油价的涨跌变化，并且可以在第一时间接收到关于油价涨跌的信息，需要根据油价在发生变化前后的比较，来判断油价的涨跌。</p>
<p><strong>弯路：</strong> 根据文档<a href="https://www.home-assistant.io/docs/automation/templating/#state">automation | trigger state</a>，自动化的触发器可以提供触发前后的数据：<code>trigger.from_state</code>和<code>trigger.to_state</code>，但是实际测试过程中，发现如果触发器是基于状态（state）的变化，而不是数值区间（numeric_state）的变化，则无法在消息通知中通过<code>jinja</code>模板来进行数值对比。</p>
<p>因此，我决定通过执行脚本来反映油价的涨跌情况。那么，如何在脚本中获取油价变化前的数据呢？此时，我想到了用<a href="https://developers.home-assistant.io/docs/api/rest/">home assistant rest api</a>。在获取最新油价之前，先从Home Assistant获取当前的油价信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> requests.packages.urllib3.exceptions <span class="keyword">import</span> InsecureRequestWarning</span><br><span class="line"></span><br><span class="line">rest_url = <span class="string">&#x27;https://localhost:8123/api/states/&lt;entity_id&gt;&#x27;</span></span><br><span class="line">token = &lt;token <span class="built_in">id</span>&gt;</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">	<span class="string">&quot;Authorization&quot;</span>: <span class="string">f&quot;Bearer <span class="subst">&#123;token&#125;</span>&quot;</span>,</span><br><span class="line">	<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请将<code>entity_id</code>换成实体的真实ID标识符。长期有效的Token需要在Home Assistant管理界面的个人配置文件中生成，具体可以参考文档：<a href="https://www.home-assistant.io/docs/authentication/#your-account-profile">Authentication</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">previous_price = <span class="number">0</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	requests.packages.urllib3.disable_warnings(InsecureRequestWarning)</span><br><span class="line">	response_api = requests.get(</span><br><span class="line">		rest_url, headers=headers, verify=<span class="literal">False</span>, timeout=(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">	)</span><br><span class="line">	previous_price = <span class="built_in">float</span>(response_api.json()[<span class="string">&#x27;state&#x27;</span>])</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>因为用<code>requests</code>访问API的时候会出现SSL证书错误的告警信息，且访问会失败，所以需要添加参数<code>verify=Fales</code>，这样就不会对SSL证书进行检查。但是，仍然会打印告警信息。因此，还需要用以下方法关闭告警信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> requests.packages.urllib3.exceptions <span class="keyword">import</span> InsecureRequestWarning</span><br><span class="line"></span><br><span class="line">requests.packages.urllib3.disable_warnings(InsecureRequestWarning)</span><br></pre></td></tr></table></figure>

<p>通过以上代码，就获取到了油价变化前的价格<code>previous_price</code>。</p>
<p>通过跟最新油价的比较，就可以判断油价的上涨和下跌。这样，油价传感器的属性又增加了一项<code>price_changed</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">current_price = youjia_92[<span class="string">&#x27;price&#x27;</span>]</span><br><span class="line"><span class="keyword">if</span> current_price &gt; previous_price:</span><br><span class="line">	youjia_92[<span class="string">&#x27;price_changed&#x27;</span>] = <span class="string">&#x27;油价上涨&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> current_price &lt; previous_price:</span><br><span class="line">	youjia_92[<span class="string">&#x27;price_changed&#x27;</span>] = <span class="string">&#x27;油价下跌&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	youjia_92[<span class="string">&#x27;price_changed&#x27;</span>] = <span class="string">&#x27;N/A&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><h3 id="trigger"><a href="#trigger" class="headerlink" title="trigger"></a>trigger</h3><p>当实体<code>sensor.hui_shan_92_you_jie</code>的属性<code>price_changed</code>值从<code>N/A</code>变化成任何其它状态，自动化都会被触发。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trigger:</span><br><span class="line">  - platform: state</span><br><span class="line">    entity_id:</span><br><span class="line">      - sensor.shang_hai_92_you_jie</span><br><span class="line">    attribute: price_changed</span><br><span class="line">    from: N/A</span><br></pre></td></tr></table></figure>

<h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>自动化触发后，执行通知动作，将通知消息发送到目标手机，消息的标题是实体<code>sensor.shang_hai_92_you_jie</code>的属性值<code>price_changed</code>，消息的正文是自动化触发前的价格<code>&#123;&#123; trigger.to_state.state &#125;&#125;</code>和触发后的价格<code>&#123;&#123; trigger.from_state.state &#125;&#125;</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">action:</span><br><span class="line">  - action: notify.mobile_app_iphone</span><br><span class="line">    metadata: &#123;&#125;</span><br><span class="line">    data:</span><br><span class="line">      message: 当前价格：&#123;&#123; trigger.to_state.state &#125;&#125; 以前价格：&#123;&#123; trigger.from_state.state &#125;&#125;</span><br><span class="line">      title: &quot;&#123;&#123; state_attr(&#x27;sensor.shang_hai_92_you_jie&#x27;, &#x27;price_changed&#x27;) &#125;&#125;&quot;</span><br><span class="line">      data:</span><br><span class="line">        push:</span><br><span class="line">          sound: Doorbell.caf</span><br></pre></td></tr></table></figure>

<p>手机上收到的通知消息见下图：</p>
<p><img src="/2024/09/29/home-assistant/yong-home-assistanat-gen-zong-qi-you-jie-ge/F8B7D9EE-6145-4C58-AF0D-72244715D40B_1_201_a.jpeg" alt="通知消息"></p>
<h2 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h2><p>Home Assistant的开发者工具中有两项功能对于测试很有帮助，分别是：<strong>设置状态</strong>和<strong>动作</strong>。</p>
<h3 id="设置状态"><a href="#设置状态" class="headerlink" title="设置状态"></a>设置状态</h3><p>设置状态可以改变实体的状态值，例如，可以改变实体<code>sensor.shang_hai_92_you_jie</code>的油价，这样就可以帮助测试自动化的运行结果是否正确。例如，真实油价是7.34，我们就可以将油价改成7.50，然后当传感器再次获取到真实油价的时候，就可以触发自动化的运行。</p>
<p>打开<strong>开发者工具</strong>，在<strong>状态</strong>中可以<strong>设置状态</strong>的选项。</p>
<p><img src="/2024/09/29/home-assistant/yong-home-assistanat-gen-zong-qi-you-jie-ge/Pasted_image_20240929162823.png" alt="开发者工具_设置状态"></p>
<h3 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h3><p>由于传感器只能根据设定的时间间隔更新数据，没有手动更新的选项。但是，测试时需要立即获取到最新的数据，这时可以用<code>homeassistant.update_entity</code>来实现。</p>
<p>打开<strong>开发者工具</strong>，进入<strong>动作</strong>页面，进入<strong>YAML模式</strong>，输入以下内容，或者也可以在<strong>用户界面模式</strong>下操作。点击<strong>执行动作</strong>后，就会更新实体<code>sensor.shang_hai_92_you_jie</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">action: homeassistant.update_entity</span><br><span class="line">data:</span><br><span class="line">  entity_id:</span><br><span class="line">    - sensor.shang_hai_92_you_jie</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.home-assistant.io/docs/configuration/templating/">templating</a><br><a href="https://jinja.palletsprojects.com/en/latest/templates/">jinja | templates</a><br><a href="https://community.home-assistant.io/t/memory-of-previous-state/290288">memory of previous state</a><br><a href="https://www.home-assistant.io/docs/automation/templating/#state">automation | trigger state</a><br><a href="https://community.home-assistant.io/t/manually-refresh-rest-sensor/353208">manually refresh rest sensors</a><br><a href="https://www.home-assistant.io/docs/scripts/perform-actions/#homeassistant-services">perform actions</a><br><a href="https://community.home-assistant.io/t/automation-template-value-should-be-a-string-for-dictionary-value-data-value-template-got-none/419519">Automation: template value should be a string for dictionary value @ data[‘value_template’]. Got None</a><br><a href="https://developers.home-assistant.io/docs/api/rest/">home assistant rest api</a><br><a href="https://www.slingacademy.com/article/python-requests-module-how-to-disable-warnings/"># Python ‘requests’ Module: How to Disable Warnings</a></p>
]]></content>
      <categories>
        <category>Home_Assistant</category>
      </categories>
      <tags>
        <tag>home_assistant</tag>
      </tags>
  </entry>
</search>
